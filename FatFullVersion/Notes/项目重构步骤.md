# 项目重构执行步骤

本文档基于 `项目重构思路.md` 中定义的重构计划，将其分解为更具体、可执行的操作步骤。

## 阶段零：模型准备 (预备步骤)

### 步骤 0：修改 `ChannelMapping.cs` 模型
1.  **打开文件**: `FatFullVersion/FatFullVersion/Models/ChannelMapping.cs` (或 `Entities` 目录，取决于实际位置)。
2.  **统一浮点数类型为 `float` 或 `float?`**:
    *   将所有原为 `double` 或 `double?` 的业务相关属性（例如 `ExpectedValue`, `ActualValue`, `Value0Percent` 至 `Value100Percent`）更改为 `float` 或 `float?`。
    *   对于原为 `float` 类型的属性，如果业务上允许其为空或表示"未设置/不适用"，并且之前可能使用 `float.NaN` 作为标记，请将其更改为 `float?` 类型，并使用 `null` 表示该状态。
    *   例如：
        *   `public double ExpectedValue { get; set; }` -> `public float? ExpectedValue { get; set; }`
        *   `public float SLLSetValueNumber { get; set; }` -> `public float? SLLSetValueNumber { get; set; }` (如果它可以因Excel原始值为空而为null)
        *   `public double Value50Percent { get; set; }` -> `public float? Value50Percent { get; set; }`
3.  **调整计算属性**:
    *   检查所有依赖于已修改浮点数属性的计算属性（例如 `Deviation`, `DeviationPercent`, `LowLowLimit` 等）。
    *   确保它们的返回类型更改为 `float` 或 `float?`，并且其内部逻辑能正确处理可能为 `null` 的输入值（例如，使用 `.GetValueOrDefault()` 或进行空值检查）。
4.  **审阅所有更改**：确保模型更改后，所有相关的getters/setters和业务逻辑依然正确。

## 阶段一：核心 `IChannelStateManager` 服务实现

### 步骤 1：定义接口及支撑类型
1.  **创建文件**: `FatFullVersion/FatFullVersion/IServices/IChannelStateManager.cs`
2.  **定义 `ManualTestItem` 枚举**:
    ```csharp
    public enum ManualTestItem
    {
        ShowValue,
        LowLowAlarm,
        LowAlarm,
        HighAlarm,
        HighHighAlarm,
        AlarmValueSet,
        MaintenanceFunction,
        TrendCheck,
        ReportCheck
    }
    ```
3.  **定义 `HardPointTestRawResult` 结构体**:
    ```csharp
    public struct HardPointTestRawResult
    {
        public bool IsSuccess { get; }
        public string Detail { get; }
        public HardPointTestRawResult(bool isSuccess, string detail = null)
        {
            IsSuccess = isSuccess;
            Detail = detail;
        }
    }
    ```
4.  **定义 `IChannelStateManager` 接口**:
    ```csharp
    public interface IChannelStateManager
    {
        void InitializeChannelFromImport(ChannelMapping channel, ExcelPointData pointData, DateTime importTime);
        void ApplyAllocationInfo(ChannelMapping channel, string testBatch, string testPlcChannelTag, string testPlcCommAddress);
        void ClearAllocationInfo(ChannelMapping channel);
        void MarkAsSkipped(ChannelMapping channel, string reason, DateTime skipTime);
        void PrepareForWiringConfirmation(ChannelMapping channel, DateTime confirmTime);
        void BeginHardPointTest(ChannelMapping channel, DateTime startTime);
        void SetHardPointTestOutcome(ChannelMapping channel, HardPointTestRawResult rawOutcome, DateTime outcomeTime);
        void BeginManualTest(ChannelMapping channel);
        void SetManualSubTestOutcome(ChannelMapping channel, ManualTestItem itemType, bool isSuccess, DateTime outcomeTime, string details = null);
        void ResetForRetest(ChannelMapping channel);
    }
    ```

### 步骤 2：实现 `ChannelStateManager` 类 - 核心逻辑
1.  **创建文件**: `FatFullVersion/FatFullVersion/Services/ChannelStateManager.cs`
2.  **实现类签名**: `public class ChannelStateManager : IChannelStateManager`
3.  **实现 `private void EvaluateOverallStatus(ChannelMapping channel, DateTime? eventTimeForFinalTest = null)`**:
    *   根据 `channel.ModuleType`, `channel.HardPointTestResult`, 及所有相关手动子测试状态，计算并设置 `channel.TestResultStatus`, `channel.ResultText`, `channel.FinalTestTime`。
    *   详细处理不同模块类型的逻辑。
    *   考虑 `channel.Status` 的处理或废弃。

### 步骤 3：实现 `ChannelStateManager` 类的公共方法
1.  **逐个实现 `IChannelStateManager` 接口中的所有方法**:
    *   **`InitializeChannelFromImport(ChannelMapping channel, ExcelPointData pointData, DateTime importTime)`**:
        *   设置从 `pointData` 映射的基础属性。
        *   **处理空值与类型转换**: 
            *   对于从 `pointData` (其属性可能是 `string` 或 `double`) 读取的表示数值的字段，安全地尝试解析为 `float`。
            *   如果 `pointData` 字段为空、null或无法解析，则 `channel` 中对应的 `float?` 属性应设为 `null`。
                *   例如: `channel.SLLSetValueNumber = float.TryParse(pointData.SLLSetValue, out var val) ? val : (float?)null;`
            *   `RangeLowerLimitValue`, `RangeUpperLimitValue` (如果已改为 `float?`) 也按此方式处理，或根据业务规则（AI/AO点必需）进行特定错误标记或处理。
        *   基于解析后的（可能为 `null` 的）`float?` 数值属性，初始化相关的**状态属性** (如 `LowAlarmStatus`, `AlarmValueSetStatus` 等)，具体逻辑参照 `项目重构思路.md` 3.1节。
        *   初始化核心测试状态 (`TestResultStatus = 0`, `ResultText = "未测试"`等)。
        *   将时间戳设为 `null`。
        *   最后调用 `EvaluateOverallStatus(channel);`
    *   **`ApplyAllocationInfo`**:
        *   更新分配字段 (`TestBatch` 等)。
        *   评估是否需要重置测试状态，如果需要则执行并调用 `EvaluateOverallStatus(channel);`
    *   **`ClearAllocationInfo`**:
        *   清空分配字段。
        *   重置所有测试状态到初始导入后状态。
        *   清除所有时间戳。
        *   调用 `EvaluateOverallStatus(channel);`
    *   **`MarkAsSkipped`**:
        *   设置 `TestResultStatus` 为跳过状态码 (例如 3)。
        *   设置 `HardPointTestResult = "跳过"`。
        *   更新 `ResultText`。
        *   设置 `FinalTestTime = skipTime`。
        *   将相关子测试状态设为 "N/A" 或 "跳过"。
        *   调用 `EvaluateOverallStatus(channel, skipTime);`
    *   **`PrepareForWiringConfirmation`**:
        *   如果 `HardPointTestResult` 是 "未测试"，更新为 "等待测试"。
        *   相应更新 `ResultText`。
    *   **`BeginHardPointTest`**:
        *   设置 `TestTime = startTime`。若 `StartTime` 为空, 也设置 `StartTime = startTime`。
        *   设置 `FinalTestTime = null`。
        *   设置 `HardPointTestResult = "测试中"`。
        *   更新 `ResultText`。
    *   **`SetHardPointTestOutcome`**:
        *   根据 `rawOutcome` 设置 `HardPointTestResult` 文本。
        *   调用 `EvaluateOverallStatus(channel, outcomeTime);`
    *   **`BeginManualTest`**:
        *   重置相关手动子测试状态为 "未测试" (如果它们不是 "通过" 或 "N/A")。
        *   更新 `ResultText` (例如，附加 "手动测试中")。
        *   设置 `FinalTestTime = null`。
    *   **`SetManualSubTestOutcome`**:
        *   更新 `itemType` 指定的子测试状态属性。
        *   调用 `EvaluateOverallStatus(channel, outcomeTime);`
    *   **`ResetForRetest`**:
        *   重置 `TestResultStatus`, `HardPointTestResult`, 所有子测试状态, `ResultText` 到适合复测的初始状态。
        *   设置 `FinalTestTime = null`。
        *   调用 `EvaluateOverallStatus(channel);`

### 步骤 4：配置依赖注入
1.  **打开DI配置文件** (例如 Prism 的 `App.xaml.cs` 或相关模块的 `Initialize` 方法)。
2.  **注册服务**: `containerRegistry.RegisterSingleton<IChannelStateManager, ChannelStateManager>();`

## 阶段二：重构服务层依赖

### 步骤 5：重构 `ChannelMappingService`
1.  **打开文件**: `FatFullVersion/FatFullVersion/Services/ChannelMappingService.cs`
2.  **注入依赖**: 在构造函数中注入 `IChannelStateManager _channelStateManager;`。
3.  **修改 `ExcelPointData` 处理逻辑**:
    *   找到从 `ExcelPointData` 创建 `ChannelMapping` 对象的地方。
    *   移除对 `TestResultStatus`, `ResultText` 等初始业务状态的直接赋值。
    *   在对象实例化和基础数据映射后，调用 `_channelStateManager.InitializeChannelFromImport(channel, pointData, importDateTime);`。
4.  **修改通道分配逻辑** (如 `AllocateChannelsTestAsync`):
    *   在确定分配信息后，为每个受影响的通道调用 `_channelStateManager.ApplyAllocationInfo(channel, ...);`。
5.  **修改清除分配逻辑** (如 `ClearAllChannelAllocationsAsync`):
    *   为每个受影响的通道调用 `_channelStateManager.ClearAllocationInfo(channel);`。

### 步骤 6：重构 `ChannelTask` 子类
1.  **针对每个任务类进行修改** (例如 `AITestTask.cs`, `DITestTask.cs` 等位于 `FatFullVersion/FatFullVersion/Services/ChannelTask/` 目录下)。
2.  **移除状态修改**: 删除所有直接修改 `this.ChannelMapping.HardPointTestResult`, `this.ChannelMapping.TestResultStatus`, 或 `this.ChannelMapping.ResultText` 的代码。
3.  **返回原始结果**:
    *   修改执行测试的核心方法 (如 `ExecuteAsync`)，使其返回 `HardPointTestRawResult`。
    *   在该方法中，根据测试的实际成功/失败情况和原因详情，构造并返回 `HardPointTestRawResult` 实例。

### 步骤 7：重构 `TestTaskManager`
1.  **打开文件**: `FatFullVersion/FatFullVersion/Services/TestTaskManager.cs`
2.  **注入依赖**: 在构造函数中注入 `IChannelStateManager _channelStateManager;`。
3.  **修改任务完成处理逻辑** (如 `ProcessTaskResult` 或任务回调):
    *   接收从 `ChannelTask` 返回的 `HardPointTestRawResult`。
    *   调用 `_channelStateManager.SetHardPointTestOutcome(task.ChannelMapping, rawResult, DateTime.Now);`。
    *   移除任何对 `task.ChannelMapping` 属性的直接状态赋值。
4.  **修改准备测试逻辑** (如 `StartAllTasksAsync` 内部，或任务即将运行时):
    *   调用 `_channelStateManager.BeginHardPointTest(channel, DateTime.Now);`。
5.  **修改 `RetestChannelAsync`**:
    *   在重新调度测试前，调用 `_channelStateManager.ResetForRetest(channelToRetest);`。
6.  **修改接线确认逻辑** (如 `ConfirmWiringCompleteAsync`):
    *   对于相关通道，调用 `_channelStateManager.PrepareForWiringConfirmation(channel, DateTime.Now);`。
7.  **(可选) 事件发布**: 如果决定由 `TestTaskManager` 发布状态变更事件，在此处（调用 `_channelStateManager` 之后）实现事件发布逻辑。

## 阶段三：重构UI层 (`DataEditViewModel`)

### 步骤 8：注入 `IChannelStateManager` 并移除旧逻辑
1.  **打开文件**: `FatFullVersion/FatFullVersion/ViewModels/DataEditViewModel.cs`
2.  **注入依赖**: 在构造函数中注入 `IChannelStateManager _channelStateManager;`。
3.  **移除辅助方法**: 删除或重构任何进行复杂状态计算的私有方法 (如 `CheckAllSubTestsCompleted`, `UpdateTestResultStatus` 中的状态计算部分)。

### 步骤 9：修改命令和相关方法的逻辑
1.  **`ImportConfigCommand` (`ImportConfig` -> `ProcessImportedDataAsync`)**:
    *   确认 `ChannelMappingService` 已按步骤 5 重构，ViewModel 接收的是已由 `_channelStateManager` 初始化的对象。
2.  **`SkipModuleCommand` (`ConfirmSkipModule`)**:
    *   替换直接状态赋值为 `_channelStateManager.MarkAsSkipped(channel, reason, DateTime.Now);`。
3.  **`FinishWiringCommand` (或 `ExecuteConfirmWiringComplete`)**:
    *   替换直接状态赋值为 `_channelStateManager.PrepareForWiringConfirmation(channel, DateTime.Now);`。
4.  **手动测试窗口打开命令 (如 `OpenAIManualTestCommand`)**:
    *   在 `OpenAIManualTest` 等方法中，调用 `_channelStateManager.BeginManualTest(CurrentChannel);`。移除对子测试状态的直接初始化。
5.  **手动测试子项确认命令 (如 `ConfirmAIValueCommand`, `ConfirmAIHighAlarmCommand`)**:
    *   替换直接状态赋值为 `_channelStateManager.SetManualSubTestOutcome(channel, ManualTestItem.Xxx, isSuccess, DateTime.Now, details);`。
6.  **`AllocateChannelsCommand` / `ClearChannelAllocationsCommand`**:
    *   确保通过 `ChannelMappingService` 的调用最终会使用 `IChannelStateManager` 的 `ApplyAllocationInfo` / `ClearAllocationInfo`。
7.  **UI更新**:
    *   在每次调用 `_channelStateManager` 的方法并可能导致 `ChannelMapping` 状态变化后，立即调用相关的UI刷新逻辑：
        *   `RaisePropertyChanged(nameof(CurrentChannel))` (如果适用)。
        *   刷新 `CurrentChannels` 集合视图（如果多项受影响）。
        *   调用 `UpdatePointStatistics();`
        *   调用 `RefreshBatchStatus();`
        *   调用 `ExportTestResultsCommand.RaiseCanExecuteChanged();`

### 步骤 10：修改事件处理逻辑
1.  **检查 `OnTestResultsUpdated` 方法** (或其新名称，如果事件已更改)。
2.  **移除状态修改**: 删除所有重新计算或设置 `ChannelMapping` 属性的代码。
3.  **简化职责**:
    *   根据事件 payload 识别受影响的 `ChannelMapping` 对象。
    *   触发这些对象或相关集合的UI刷新。
    *   调用 `UpdatePointStatistics()`, `RefreshBatchStatus()`, `ExportTestResultsCommand.RaiseCanExecuteChanged()`。

## 阶段四：测试与验证

### 步骤 11：单元测试
1.  **`ChannelStateManager`**:
    *   为每个公共方法编写测试用例。
    *   提供不同初始状态的 `ChannelMapping` 对象。
    *   验证方法调用后 `ChannelMapping` 的所有相关属性（状态、子状态、时间戳）是否符合预期。
    *   重点测试内部 `EvaluateOverallStatus` 的逻辑。
2.  **调用方类 (ViewModel, `TestTaskManager`, `ChannelMappingService`)**:
    *   更新现有测试，模拟 `IChannelStateManager`。
    *   验证是否以正确的参数调用了正确的 `IChannelStateManager` 方法。
    *   确认它们不再直接修改状态。
3.  **`ChannelTask` 子类**:
    *   验证它们是否正确返回 `HardPointTestRawResult`。

### 步骤 12：集成测试
1.  编写或执行测试用例，覆盖多个服务和 `ChannelStateManager` 之间的交互。
2.  模拟典型的用户操作序列（导入 -> 分配 -> 测试 -> 跳过 -> 复测），验证每一步的状态是否正确。

### 步骤 13：手动端到端验证
1.  在应用程序中执行所有主要的用户工作流程。
2.  仔细检查UI显示（状态文本、颜色、按钮可用性）是否与预期一致。
3.  验证导出数据和历史记录恢复功能的正确性。

### 步骤 14：代码审查
1.  对所有重构的代码进行同行评审。
2.  关注点：新架构的遵循情况、`ChannelStateManager` 逻辑的正确性、模块间交互的清晰度、以及测试的覆盖率。

---
完成这些步骤后，`ChannelMapping` 的状态管理将更加集中和健壮，并且数据模型在处理浮点数和空值方面将更加一致和明确。
