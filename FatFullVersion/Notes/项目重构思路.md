# 项目重构：DataEditViewModel 与 ChannelMapping 状态管理

## 1. 引言

本文档旨在为 `FatFullVersion` 项目中 `DataEditViewModel.cs` 及相关模块的重构提供指导。当前 `DataEditViewModel` 类以及一些服务和任务类直接管理和修改 `ChannelMapping` 领域模型的大量状态属性，导致代码分散、逻辑重复、难以维护和测试。

**重构目标**：遵循"方案一"的核心思想，将 `ChannelMapping` 的状态管理职责从 `DataEditViewModel`、`TestTaskManager`、`ChannelTask`子类等组件中剥离出来，引入一个新的领域服务 `IChannelStateManager`。该服务将集中处理 `ChannelMapping` 对象的所有状态转换、业务规则计算以及复杂操作，成为修改 `ChannelMapping` 核心业务状态的唯一入口。

**核心模型**：`ChannelMapping` 对象及其众多状态属性是本次重构的核心关注点。

## 2. `ChannelMapping` 核心状态属性概览

以下是 `ChannelMapping` 对象中与状态管理密切相关的关键属性。本次重构将确保这些属性的修改都通过 `IChannelStateManager` 进行。

*   **标识与上下文信息**:
    *   `Id`: Guid (唯一标识)
    *   `TestTag`: string (测试标签，包含创建时间等)
    *   `TestId`: string (来自Excel的序列号，建议在 `InitializeChannelFromImport` 中确保其唯一性或处理方式)
    *   `ChannelTag`: string (通道标签，如 "机架1_槽2_AI_点1")
    *   `VariableName`: string (变量名)
    *   `ModuleType`: string (模块类型: "AI", "AO", "DI", "DO", "AINone", etc.)
    *   `ModuleName`: string (模块名)
    *   `StationName`: string (站名)
    *   `VariableDescription`: string (变量描述)
    *   `DataType`: string (数据类型)
    *   `WireSystem`, `PowerSupplyType`: string (线制和有源/无源)
*   **通信与范围**:
    *   `PlcCommunicationAddress`: string (被测PLC通讯地址)
    *   `TestPLCCommunicationAddress`: string (测试PLC通讯地址)
    *   `RangeLowerLimitValue`: `float` (假定AI/AO点表此值必填且有效，否则应为 `float?`)
    *   `RangeUpperLimitValue`: `float` (同上)
*   **核心测试状态 (将由 `IChannelStateManager` 管理)**:
    *   `HardPointTestResult`: string (硬点测试结果: "未测试", "等待测试", "测试中", "通过", "失败: [原因]", "跳过")
    *   `TestResultStatus`: int (整体测试结果: `0`=未测试, `1`=通过, `2`=失败, `3`=跳过 - *建议为"跳过"明确一个状态码，例如3*)
    *   `ResultText`: string (综合的、用户可见的测试结果文本描述)
    *   `Status`: string (此属性与 `ResultText` 和 `TestResultStatus` 高度相关，建议在重构中评估其必要性，可能统一或废弃，以减少冗余。若保留，也由 `IChannelStateManager` 管理。)
*   **时间戳 (将由 `IChannelStateManager` 管理)**:
    *   `StartTime`: `DateTime?` (测试开始时间，可能是批次或单个通道的首次测试动作时间)
    *   `TestTime`: `DateTime?` (一般指硬点测试开始或重要阶段的时间)
    *   `FinalTestTime`: `DateTime?` (通道最终测试完成时间，无论是通过、失败还是跳过)
*   **手动测试子状态 (根据 `ModuleType` 相关性不同，将由 `IChannelStateManager` 管理)**:
    *   `ShowValueStatus`: string (显示值核对: "未测试", "通过", "失败")
    *   **AI 特有**:
        *   `SLLSetValue`: string (Excel原始值)
        *   `SLSetValue`: string (Excel原始值)
        *   `SHSetValue`: string (Excel原始值)
        *   `SHHSetValue`: string (Excel原始值)
        *   `SLLSetValueNumber`: `float?` (由 `InitializeChannelFromImport` 从 `SLLSetValue` 解析，若空则为 `null`)
        *   `SLSetValueNumber`: `float?` (同上)
        *   `SHSetValueNumber`: `float?` (同上)
        *   `SHHSetValueNumber`: `float?` (同上)
        *   `SLLSetPointCommAddress`, `SLSetPointCommAddress`, `SHSetPointCommAddress`, `SHHSetPointCommAddress`: string (报警设定值通讯地址)
        *   `LowLowAlarmStatus`, `LowAlarmStatus`, `HighAlarmStatus`, `HighHighAlarmStatus`: string (各报警测试状态: "未测试", "通过", "失败")
        *   `AlarmValueSetStatus`: string (报警值设定核对状态: "未测试", "通过", "失败")
        *   `MaintenanceFunction`: string (维护功能测试状态: "未测试", "通过", "失败", "N/A")
        *   `MaintenanceEnableSwitchPointCommAddress`: string (维护使能开关通讯地址)
        *   `TrendCheck`, `ReportCheck`: string (趋势/报表检查状态: "未测试", "通过", "失败", "N/A")
    *   **AO 特有**:
        *   `TrendCheck`, `ReportCheck`: string (趋势/报表检查状态: "未测试", "通过", "失败", "N/A")
        *   `Value0Percent`, `Value25Percent`, `Value50Percent`, `Value75Percent`, `Value100Percent`: `float?` (用于记录测试中的实际值，如果未记录则为 `null`)
    *   **DI/DO 特有**:
        *   (多种AI/AO子状态对它们为 "N/A")
*   **分配与批次信息**:
    *   `TestBatch`: string (所属测试批次名称)
    *   `TestPLCChannelTag`: string (映射的测试PLC通道标签)
    *   (这些分配信息字段的设置，如果仅为信息存储，可直接赋值；如果其变更会触发复杂的状态重置或评估，则应通过 `IChannelStateManager` 的特定方法处理)

## 3. `ChannelMapping` 状态变更核心流程与场景

以下流程描述了 `ChannelMapping` 对象状态在各个业务场景中如何发生变化。重构后，所有核心状态的设定将由 `IChannelStateManager` 封装。

### 3.1. 初始化与数据导入 (原 `ProcessImportedDataAsync`)
*   **流程**: `DataEditViewModel` (通过 `_pointDataService`) 读取Excel数据 -> `ChannelMappingService` (或 `DataEditViewModel` 内部逻辑) 为每条数据创建 `ChannelMapping` 实例 -> 对每个新创建的 `channel` 对象，调用 `_channelStateManager.InitializeChannelFromImport(channel, excelPointData, importTime)`。
*   **`IChannelStateManager` 职责 (`InitializeChannelFromImport`)**:
    *   设置所有从 `excelPointData` 映射的基础属性（如 `VariableName`, `ModuleType`, `PlcCommunicationAddress` 等）。
    *   初始化核心测试状态：`TestResultStatus = 0` (未测试)，`ResultText = "未测试"`，`HardPointTestResult = "未测试"`，`Status = "未测试"` (如果保留)。
    *   时间戳设为 `null`。
    *   **空值与类型处理**:
        *   对于 `excelPointData` 中表示数值的字符串字段 (如 `SLLSetValue`, `RangeLowerLimit` 等)，尝试解析为 `float`。如果字符串为空、null或无法解析：
            *   对应的 `ChannelMapping` 数值属性 (如 `SLLSetValueNumber`，应为 `float?` 类型) 设置为 `null`。
            *   `RangeLowerLimitValue`, `RangeUpperLimitValue` 如果在 `excelPointData` 中为空或无效，对于AI/AO点应记录错误或标记为不可测，而不是简单设为 `null` (除非业务允许无量程测试)。若统一为 `float?` 且业务允许，则可设为 `null`。
        *   基于解析后的数值属性 (可能为 `null`) 初始化相关的状态属性。例如：
            *   AI报警状态：如果 `SLLSetValueNumber` 和 `SLSetValueNumber` 均为 `null` (因Excel中对应项为空)，则 `LowLowAlarmStatus = "通过"` (或 "N/A"), `LowAlarmStatus = "通过"` (或 "N/A")。如果只有一个为空，则对应的报警状态设为 "通过" (或 "N/A")，另一个设为 "未测试"。如果两者都有值，则都设为 "未测试"。
            *   `AlarmValueSetStatus` 根据所有报警设定值是否有效及其对应状态来综合判断。
        *   AO的 `MaintenanceFunction` 根据现有业务规则（可能默认为 "通过"）在 `InitializeChannelFromImport` 中设定。
        *   其他子状态根据 `ModuleType` 初始化为 "未测试" 或 "N/A"。
    *   其他属性如 `WireSystem`, `PowerSupplyType`, `RangeLowerLimitValue`, `RangeUpperLimitValue` 根据导入数据设置。

### 3.2. 通道分配与清除
*   **3.2.1. 执行通道分配 (原 `ExecuteAllocateChannels`)**
    *   **流程**: `DataEditViewModel` 调用 `_channelMappingService.AllocateChannelsTestAsync()`。该服务返回分配好测试信息的 `ChannelMapping` 集合后，`DataEditViewModel` (或服务内部) 遍历受影响的通道，调用 `_channelStateManager.ApplyAllocationInfo(channel, testBatchName, testPlcChannelTag, testPlcCommAddress)`。
    *   **`IChannelStateManager` 职责 (`ApplyAllocationInfo`)**:
        *   更新 `channel.TestBatch`, `channel.TestPLCChannelTag`, `channel.TestPLCCommunicationAddress`。
        *   如果通道分配的动作本身意味着之前的测试结果（如果有）需要被视为无效并重置，则此方法内部会重置相关的测试状态属性（例如，回到 "未测试" 状态，清除时间戳）。通常，重新分配可能意味着需要重新测试。

*   **3.2.2. 清除通道分配 (原 `ClearChannelAllocationsAsync`)**
    *   **流程**: `DataEditViewModel` 调用 `_channelMappingService.ClearAllChannelAllocationsAsync()`。该服务处理完后，`DataEditViewModel` (或服务内部) 遍历受影响的通道，调用 `_channelStateManager.ClearAllocationInfo(channel)`。
    *   **`IChannelStateManager` 职责 (`ClearAllocationInfo`)**:
        *   清空 `channel.TestBatch`, `channel.TestPLCChannelTag`, `channel.TestPLCCommunicationAddress`。
        *   重置所有测试状态到初始导入后的状态（`TestResultStatus = 0`, `ResultText = "未测试"` 等），清除所有时间戳。因为通道已无分配，之前的测试结果不再有效。

### 3.3. 批次选择与接线确认
*   **3.3.1. 批次选择 (原 `ConfirmBatchSelection`, `OnBatchSelected`)**
    *   **流程**: 用户在UI上选择一个 `TestBatch`。
    *   **`IChannelStateManager` 影响**: 此操作主要影响 `DataEditViewModel` 中 `CurrentChannels` 的筛选，通常不直接改变 `ChannelMapping` 实例的核心测试状态。如果切换批次需要重置某些UI相关的临时状态，那在ViewModel层面处理。

*   **3.3.2. 确认接线完成 (原 `ExecuteConfirmWiringComplete`)**
    *   **流程**: `DataEditViewModel` 在用户确认当前选定批次的接线完成后，遍历该批次中所有通道，对每个需要准备测试的 `channel` 调用 `_channelStateManager.PrepareForWiringConfirmation(channel, DateTime.Now)`。
    *   **`IChannelStateManager` 职责 (`PrepareForWiringConfirmation`)**:
        *   如果 `channel.HardPointTestResult` 当前为 "未测试" (或类似初始状态)，则更新为 `HardPointTestResult = "等待测试"`。
        *   相应地更新 `channel.ResultText` 以反映 "等待测试" 状态。
        *   不改变 `TestResultStatus` (仍为0)。

### 3.4. 模块跳过 (原 `ConfirmSkipModule`)
*   **流程**: `DataEditViewModel` 在用户选择一个或多个模块并确认跳过操作后，遍历这些模块包含的所有 `channel` 对象，调用 `_channelStateManager.MarkAsSkipped(channel, reason, DateTime.Now)`。
*   **`IChannelStateManager` 职责 (`MarkAsSkipped`)**:
    *   设置 `channel.TestResultStatus = 3` (或一个代表"跳过"的特定状态码)。
    *   设置 `channel.HardPointTestResult = "跳过"`。
    *   设置 `channel.ResultText = $"已跳过测试，原因: {reason}"`。
    *   设置 `channel.FinalTestTime = skipTime` (传入的当前时间)。
    *   将所有相关的具体手动子测试状态 (如 `ShowValueStatus`, 报警状态等) 更新为 "N/A" 或 "跳过"，以反映它们未被执行。

### 3.5. 硬点自动测试
*   **3.5.1. 测试启动 (原 `StartTest`)**
    *   **流程**: `DataEditViewModel` 调用 `_testTaskManager.StartAllTasksAsync()`。对于每个即将开始硬点测试的 `channel`，`TestTaskManager` (或被其调度的具体 `ChannelTask` 在执行前) 调用 `_channelStateManager.BeginHardPointTest(channel, DateTime.Now)`。
    *   **`IChannelStateManager` 职责 (`BeginHardPointTest`)**:
        *   设置 `channel.TestTime = startTime` (传入的当前时间)。如果 `channel.StartTime` 为空，也设置 `channel.StartTime = startTime`。
        *   设置 `channel.FinalTestTime = null` (清除任何旧的完成时间)。
        *   更新 `channel.HardPointTestResult = "测试中"`。
        *   更新 `channel.ResultText`，例如，如果原为 "等待测试"，则变为 "硬点通道测试中"；如果已有其他信息，则附加 ", 硬点通道测试中"。

*   **3.5.2. 测试结果处理**
    *   **流程**:
        1.  某个具体的 `ChannelTask` (如 `AITestTask`) 完成其PLC交互和逻辑判断，得到一个原始的测试结果（例如，成功/失败的布尔值，或更详细的错误描述）。
        2.  `ChannelTask` 将此原始结果返回给 `TestTaskManager`。
        3.  `TestTaskManager` 接收到原始结果后，针对相应的 `channel` 调用 `_channelStateManager.SetHardPointTestOutcome(channel, rawTestResult, DateTime.Now)`。
    *   **`IChannelStateManager` 职责 (`SetHardPointTestOutcome`)**:
        1.  根据传入的 `rawTestResult` (这是一个包含成功/失败及可选详情的结构或对象) 来设置 `channel.HardPointTestResult` 的文本描述。例如，如果成功，则为 "通过"；如果失败，则为 "失败: {rawTestResult.Detail}"。
        2.  调用内部的 `EvaluateOverallStatus(channel, outcomeTime)` 方法。此方法会：
            *   根据新的 `HardPointTestResult` 以及现有的手动测试状态（如果有），计算并设置 `channel.TestResultStatus` (例如，1=通过, 2=失败)。
            *   相应地更新 `channel.ResultText` 以提供综合的状态描述。
            *   如果硬点测试失败，或者硬点测试通过且该通道类型没有后续手动测试步骤，则设置 `channel.FinalTestTime = outcomeTime`。

### 3.6. 手动测试流程 (以 AI 通道为例，DI/DO/AO 流程类似但子测试项不同)
*   **3.6.1. 打开手动测试窗口 (e.g., 原 `OpenAIManualTest`)**
    *   **流程**: `DataEditViewModel` 在为某个 `channel` 打开手动测试窗口时，调用 `_channelStateManager.BeginManualTest(channel)`。
    *   **`IChannelStateManager` 职责 (`BeginManualTest`)**:
        *   检查该 `channel` 的所有相关手动子测试项状态。如果某个子项不是 "通过" 或 "N/A" (即之前未成功完成或不适用)，则将其状态重置/初始化为 "未测试"。
        *   更新 `channel.ResultText`，例如，如果通道整体尚在测试中，可以更新为 (或附加) "手动测试中"。
        *   设置 `channel.FinalTestTime = null` (因为手动测试刚开始或仍在进行中，之前的完成时间无效)。

*   **3.6.2. 执行并确认手动子测试项 (e.g., 原 `ExecuteConfirmAIValue`, `ExecuteConfirmAIHighAlarm`)**
    *   **流程**: 用户在 `DataEditViewModel` 提供的UI上手动执行某项操作后，点击对应的"确认XX"按钮。`DataEditViewModel` 随后调用 `_channelStateManager.SetManualSubTestOutcome(channel, manualTestItem, isSuccess, DateTime.Now, details)`。
        *   `manualTestItem`: 一个枚举，指明是哪个子测试项 (如 `ManualTestItem.ShowValue`, `ManualTestItem.HighAlarm`)。
        *   `isSuccess`: 布尔值，表示该子项测试是否通过。
        *   `details`: 可选字符串，用于失败时的附加说明。
    *   **`IChannelStateManager` 职责 (`SetManualSubTestOutcome`)**:
        1.  根据 `manualTestItem` 更新 `channel` 对应的子测试状态属性 (例如, `channel.ShowValueStatus = isSuccess ? "通过" : "失败";` 如果失败，可能还会记录 `details` 到某个地方或影响 `ResultText`)。
        2.  调用内部的 `EvaluateOverallStatus(channel, outcomeTime)` 方法。此方法会：
            *   检查该模块类型所有必需的手动子测试项以及硬点测试结果。
            *   如果所有部分均已 "通过"，则设置 `TestResultStatus = 1` (整体通过)，`ResultText = "测试已通过"`，`FinalTestTime = outcomeTime`。
            *   如果任何一个必需部分（硬点或手动子项）为 "失败"，则设置 `TestResultStatus = 2` (整体失败)，更新 `ResultText` 以指明失败环节，`FinalTestTime = outcomeTime`。
            *   如果尚有必需的测试项为 "未测试"，则 `TestResultStatus` 通常保持当前状态（或根据是否有失败项更新），`ResultText` 指示仍在测试中，`FinalTestTime` 保持 `null`。

### 3.7. 重新测试 (原 `Retest`)
*   **流程**: `DataEditViewModel` 接收用户复测请求后，调用 `_testTaskManager.RetestChannelAsync(channel)` (或其他类似方法)。`TestTaskManager` 在重新执行测试前，首先调用 `_channelStateManager.ResetForRetest(channel)`。
*   **`IChannelStateManager` 职责 (`ResetForRetest`)**:
    *   将 `channel.TestResultStatus` 重置为 `0` (未测试)。
    *   将 `channel.HardPointTestResult` 重置为 "未测试" (或 "等待测试"，取决于复测流程如何开始)。
    *   将所有相关的手动子测试状态重置为 "未测试"。
    *   更新 `channel.ResultText` 为 "等待复测" 或类似指示。
    *   设置 `channel.FinalTestTime = null`。
    *   `channel.StartTime` 和 `channel.TestTime` 可根据需要决定是否清除或保留。
    *   后续的测试流程将遵循3.5 (硬点测试) 和/或 3.6 (手动测试) 的状态变更逻辑。

### 3.8. 测试记录恢复 (原 `RestoreTestRecords`)
*   **流程**: `DataEditViewModel` 调用 `_testRecordService.RestoreTestRecordsAsync(testTag)` 来获取指定历史批次的 `ChannelMapping` 对象集合。这些从数据库加载的对象已经包含了它们被保存时的所有状态。
*   **`IChannelStateManager` 职责**: 在此场景下，`IChannelStateManager` 通常不直接参与恢复过程，因为状态是由持久化数据源提供的。`DataEditViewModel` 直接使用这些恢复的 `ChannelMapping` 对象更新其 `AllChannels` 和 `OriginalAllChannels` 集合。如果恢复的数据格式与当前 `ChannelMapping` 定义有差异，或需要进行额外的状态验证或转换，则可以设计一个 `_channelStateManager.AdaptFromHistoricalData(channel, historicalData)` 之类的方法，但这超出了本次核心状态管理重构的范围，除非明确需要。

## 4. `IChannelStateManager` 服务接口定义

```csharp
// 建议的存放位置: FatFullVersion/IServices/IChannelStateManager.cs
public enum ManualTestItem
{
    ShowValue,          // 显示值核对 (适用于 AI, AO, DI, DO)
    LowLowAlarm,        // 低低报测试 (AI)
    LowAlarm,           // 低报测试 (AI)
    HighAlarm,          // 高报测试 (AI)
    HighHighAlarm,      // 高高报测试 (AI)
    AlarmValueSet,      // 报警值设定核对 (AI)
    MaintenanceFunction,// 维护功能测试 (AI, AO - AO可能默认通过)
    TrendCheck,         // 趋势检查 (AI, AO)
    ReportCheck         // 报表检查 (AI, AO)
}

// HardPointTestRawResult 结构体，如果包含数值，应考虑使用 float
public struct HardPointTestRawResult
{
    public bool IsSuccess { get; }
    public string Detail { get; } 
    // public float? RawValue { get; } // 示例：如果需要传递原始数值结果
    public HardPointTestRawResult(bool isSuccess, string detail = null /*, float? rawValue = null*/)
    {
        IsSuccess = isSuccess;
        Detail = detail;
        // RawValue = rawValue;
    }
}

public interface IChannelStateManager
{
    /// <summary>
    /// 根据从Excel导入的数据初始化ChannelMapping对象的状态。
    /// </summary>
    void InitializeChannelFromImport(ChannelMapping channel, ExcelPointData pointData, DateTime importTime);

    /// <summary>
    /// 应用通道分配信息到ChannelMapping对象，并可能重置测试状态。
    /// </summary>
    void ApplyAllocationInfo(ChannelMapping channel, string testBatch, string testPlcChannelTag, string testPlcCommAddress);

    /// <summary>
    /// 清除ChannelMapping对象的通道分配信息，并重置测试状态到初始。
    /// </summary>
    void ClearAllocationInfo(ChannelMapping channel);

    /// <summary>
    /// 将ChannelMapping对象标记为已跳过测试。
    /// </summary>
    void MarkAsSkipped(ChannelMapping channel, string reason, DateTime skipTime);

    /// <summary>
    /// 准备ChannelMapping对象以进行接线确认（通常设置为等待测试）。
    /// </summary>
    void PrepareForWiringConfirmation(ChannelMapping channel, DateTime confirmTime);

    /// <summary>
    /// 开始硬点测试前，设置ChannelMapping的初始测试中状态。
    /// </summary>
    void BeginHardPointTest(ChannelMapping channel, DateTime startTime);

    /// <summary>
    /// 根据原始的硬点测试结果，更新ChannelMapping的状态。
    /// 内部会调用EvaluateOverallStatus。
    /// </summary>
    void SetHardPointTestOutcome(ChannelMapping channel, HardPointTestRawResult rawOutcome, DateTime outcomeTime);

    /// <summary>
    /// 开始手动测试前，准备ChannelMapping的状态（如重置子项为未测试）。
    /// </summary>
    void BeginManualTest(ChannelMapping channel);

    /// <summary>
    /// 记录手动测试中某个子项的测试结果，并重新评估整体状态。
    /// 内部会调用EvaluateOverallStatus。
    /// </summary>
    void SetManualSubTestOutcome(ChannelMapping channel, ManualTestItem itemType, bool isSuccess, DateTime outcomeTime, string details = null);

    /// <summary>
    /// 重置ChannelMapping的状态以便进行重新测试。
    /// </summary>
    void ResetForRetest(ChannelMapping channel);

    // 注意: EvaluateOverallStatus 是 ChannelStateManager 内部的核心私有方法，
    // 它会被 SetHardPointTestOutcome 和 SetManualSubTestOutcome 等方法调用，
    // 不作为公共接口暴露。
}
```

## 5. 调用方职责变更

### 5.1. `DataEditViewModel`
*   **职责转变**：从状态的直接修改者和计算者，转变为用户意图的捕获者和 `IChannelStateManager` 的调用者，以及UI状态的管理者和更新者。
*   **交互示例**：
    ```csharp
    // 原 ExecuteConfirmAIValue:
    // channel.ShowValueStatus = "通过";
    // CheckAllSubTestsCompleted(channel); // 内部有复杂逻辑

    // 新 ExecuteConfirmAIValue:
    public void ExecuteConfirmAIValue(ChannelMapping channel)
    {
        if (channel != null && _channelStateManager != null)
        {
            _channelStateManager.SetManualSubTestOutcome(channel, ManualTestItem.ShowValue, true, DateTime.Now);
            // DataEditViewModel 负责触发UI更新，例如:
            // RaisePropertyChanged(nameof(CurrentChannel)); // 或更细粒度的通知
            // UpdatePointStatistics();
            // RefreshBatchStatus(); // 更新批次状态显示
        }
    }
    ```
*   不再包含 `CheckAllSubTestsCompleted`, `UpdateTestResultStatus` 等复杂的 `ChannelMapping` 状态计算逻辑。

### 5.2. `Services/ChannelMappingService.cs`
*   **职责转变**：在创建或修改 `ChannelMapping` 对象的分配信息时，通过 `IChannelStateManager` 来确保状态一致性。
*   **交互示例 (`ProcessImportedDataAsync` 内部片段):
    ```csharp
    // ... 创建 channel 对象后 ...
    _channelStateManager.InitializeChannelFromImport(channel, point, importDateTime);
    allChannels.Add(channel);
    ```

### 5.3. `Services/ChannelTask/*.cs` (例如 `AITestTask.cs`)
*   **职责转变**：执行具体的硬件交互和测试逻辑判断，然后将原始的、未加工的测试结果（成功/失败及原因）传递给 `IChannelStateManager`，而不是自己设定最终的 `HardPointTestResult` 或 `TestResultStatus` 字符串。
*   **交互示例** (在任务执行的核心方法中):
    ```csharp
    // ... 执行完PLC读写和判断逻辑后 ...
    bool success = // ... (测试是否成功的判断)
    string failureDetail = success ? null : "具体失败原因...";
    var rawResult = new HardPointTestRawResult(success, failureDetail);

    // 假设 _channelStateManager 已被注入或传递进来
    _channelStateManager.SetHardPointTestOutcome(this.ChannelMapping, rawResult, DateTime.Now);

    // 任务可以将 rawResult 或 ChannelMapping（现在状态已更新）返回给 TestTaskManager
    ```

### 5.4. `Services/TestTaskManager.cs`
*   **职责转变**：编排测试任务的执行流程，管理任务队列。当从 `ChannelTask` 收到原始测试结果，或需要启动/复位测试时，调用 `IChannelStateManager`。
*   **交互示例** (处理 `ChannelTask` 完成后的回调):
    ```csharp
    private void OnTaskCompleted(IChannelTask task, HardPointTestRawResult rawResult) // ChannelTask 返回原始结果
    {
        _channelStateManager.SetHardPointTestOutcome(task.ChannelMapping, rawResult, DateTime.Now);

        // 后续 TestTaskManager 可以发布事件通知UI更新（见第6节）
        // 或者根据 task.ChannelMapping 的最新状态更新内部管理信息
    }

    public async Task RetestChannelAsync(ChannelMapping channelToRetest)
    {
        _channelStateManager.ResetForRetest(channelToRetest);
        // ...后续重新创建并执行任务的逻辑...
    }
    ```

## 6. 事件处理机制调整

*   `IChannelStateManager` **不**发布任何事件。它的职责是原子性地、同步地更新传入的 `ChannelMapping` 对象的状态。
*   **通知责任上移**：当 `ChannelMapping` 的状态被 `IChannelStateManager` 更新后，需要通知UI或其他模块时，该通知责任由调用 `IChannelStateManager` 的组件承担，主要是 `TestTaskManager` 或 `DataEditViewModel`。
    *   **`TestTaskManager`**: 在异步执行硬点测试并调用 `IChannelStateManager` 更新多个通道状态后，可以发布一个事件，例如 `BatchChannelsStateModifiedEvent`，该事件可以携带受影响通道的ID列表或简要信息。
    *   **`DataEditViewModel`**:
        *   当它直接调用 `IChannelStateManager` (例如，在手动测试确认后)，它应该在调用之后立即触发必要的UI更新（通过 `RaisePropertyChanged`）和依赖属性的刷新（如点位统计）。
        *   当它订阅由 `TestTaskManager` 等服务发布的 `...StateModifiedEvent` 时，其事件处理器的职责将简化。
*   **`DataEditViewModel` 事件处理器简化** (以原 `OnTestResultsUpdated` 为例，假设它现在订阅 `ChannelStateModifiedEvent(Guid channelId)`):
    ```csharp
    private void OnChannelStateModified(Guid channelId) // 事件仅携带ID
    {
        var modifiedChannel = AllChannels.FirstOrDefault(c => c.Id == channelId);
        if (modifiedChannel != null)
        {
            // 仅触发UI刷新，因为状态已由 ChannelStateManager 完全更新
            // 如果UI绑定到集合项的属性，且ChannelMapping实现了INotifyPropertyChanged，
            // 属性更新可能已自动通知UI。
            // 如果没有，或者需要刷新整个项的显示，可以：
            // 1. 如果CurrentChannels是CollectionView，可以尝试Refresh()。
            // 2. 如果绑定到ObservableCollection<ChannelMapping>，且ChannelMapping是引用类型，
            //    其内部属性变化后，DataGrid等控件通常能感知（如果单元格模板绑定到具体属性）。
            //    最坏的情况是，如果需要强制重绘特定行，可能需要更复杂的处理或重新设置ItemsSource的某个子集。
            //    通常，调用RaisePropertyChanged针对整个AllChannels或CurrentChannels可能过于粗暴但有效。
            //    更优的是，如果DataGrid行绑定到一个ViewModel包装器，则在该包装器上RaisePropertyChanged。

            // 示例：简单地通知整个列表可能已更改（如果找不到更细粒度的方法）
            // RaisePropertyChanged(nameof(CurrentChannels));
            // 或者，如果知道哪些具体属性被绑定并可能影响显示：
            // Application.Current.Dispatcher.Invoke(() => modifiedChannel.RaisePropertyChangesForUIDisplay()); 
            // (假设ChannelMapping有这样一个辅助方法，或者ViewModel有办法针对特定项触发属性变更)
        }
        // 更新依赖于总体状态的ViewModel属性
        UpdatePointStatistics();
        RefreshBatchStatus(); // 如果批次状态依赖于通道状态
        ExportTestResultsCommand.RaiseCanExecuteChanged(); // 更新命令可用性
    }
    ```
    **核心**: `DataEditViewModel` 的事件处理器不再包含任何 `if (channel.HardPointTestResult == "通过" ...)` 之类的状态判断和赋值逻辑。这些都已移入 `IChannelStateManager`。

## 7. 后续步骤
1.  **评审并最终确定本文档**：确保所有细节清晰且达成共识。
2.  **定义并实现 `IChannelStateManager` 接口及其具体类 `ChannelStateManager`**：
    *   在 `FatFullVersion/IServices/` (或类似目录) 下创建 `IChannelStateManager.cs`。
    *   在 `FatFullVersion/Services/` (或类似目录) 下创建 `ChannelStateManager.cs`。
    *   重点实现内部的 `EvaluateOverallStatus(ChannelMapping channel, DateTime? eventTimeForFinalTest)` 核心逻辑，该逻辑将根据 `channel.ModuleType`, `channel.HardPointTestResult`, 以及所有相关的手动子测试项状态 (如 `ShowValueStatus`, `LowAlarmStatus` 等) 来综合判断并设置 `channel.TestResultStatus`, `channel.ResultText`, 和 `channel.FinalTestTime`。此方法需要处理不同模块类型（AI, AO, DI, DO）的特定规则。
3.  **依赖注入配置**：将 `ChannelStateManager` 注册到依赖注入容器中，以便其他服务和ViewModel可以获取其实例。
4.  **逐步重构调用方**：按照优先级和依赖关系：
    *   **`DataEditViewModel`**: 将其所有直接修改 `ChannelMapping` 状态的逻辑替换为对注入的 `_channelStateManager` 实例的调用。移除如 `CheckAllSubTestsCompleted`, `UpdateTestResultStatus` 等方法。
    *   **`TestTaskManager`**: 修改其方法，使其在处理任务生命周期和结果时调用 `_channelStateManager`。确保 `_channelStateManager` 实例被正确传递或注入。
    *   **各个 `ChannelTask` 子类** (`AITestTask`, `DITestTask` 等): 修改它们，使其返回原始测试结果给 `TestTaskManager`，并移除对 `ChannelMapping` 状态的直接修改。它们不再需要直接访问 `_channelStateManager`，除非设计上传递给它们。
    *   **`ChannelMappingService`**: 调整其涉及 `ChannelMapping` 初始化和分配信息更新的逻辑，以调用 `_channelStateManager`。
5.  **调整事件处理机制**：
    *   根据第6节的描述，修改或替换现有的 `TestResultsUpdatedEvent`。
    *   重写 `DataEditViewModel` 中相关的事件订阅和处理方法，简化其职责为UI刷新和ViewModel自身属性的更新。
6.  **单元测试**：
    *   为 `ChannelStateManager` 编写全面的单元测试，覆盖其所有公共方法和各种状态转换场景。模拟不同的 `ChannelMapping` 初始状态和输入参数，验证最终状态是否符合预期。
    *   对被修改的调用方（ViewModel, Services, Tasks）也应更新或补充单元测试，以验证它们现在能正确调用 `ChannelStateManager` 并处理其行为。
7.  **集成测试和手动验证**：
    *   执行端到端的测试，覆盖所有主要的业务流程（导入、分配、接线、跳过、硬点测试、各类手动测试、复测、导出、历史记录恢复）。
    *   确保UI显示的状态与后台逻辑一致，所有功能在重构后行为正确无误。
8.  **代码审查**：对重构的代码进行审查，确保质量和一致性。

通过以上步骤，可以将 `ChannelMapping` 的状态管理逻辑清晰地集中到 `ChannelStateManager` 中，从而提高代码的模块化、可维护性和可测试性。
