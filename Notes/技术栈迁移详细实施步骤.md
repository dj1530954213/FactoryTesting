# æŠ€æœ¯æ ˆè¿ç§»è¯¦ç»†å®æ–½æ­¥éª¤æ–¹æ¡ˆ (FAT_TEST é¡¹ç›®)

## ğŸ“‹ å®ŒæˆçŠ¶æ€æ€»è§ˆ

### âœ… å·²å®Œæˆçš„æ­¥éª¤

#### Phase 1: åç«¯æ ¸å¿ƒåŸºç¡€å»ºè®¾ - é¢†åŸŸæ¨¡å‹ä¸åŸºç¡€è®¾æ–½å±‚
- **(å®Œæˆ)æ­¥éª¤ 1.1**: å®šä¹‰æ ¸å¿ƒé¢†åŸŸæ¨¡å‹ (Rust Structs & Enums)
- **(å®Œæˆ)æ­¥éª¤ 1.2**: æ­å»º Rust é¡¹ç›®åŸºæœ¬ç»“æ„ã€é…ç½®ä¸ç»Ÿä¸€é”™è¯¯å¤„ç†
- **(å®Œæˆ)æ­¥éª¤ 1.3**: å®ç° `IPlcCommunicationService` æ¥å£åŠ Mock/åŸºæœ¬å®ç° (åŸºç¡€è®¾æ–½å±‚)
- **(å®Œæˆ)æ­¥éª¤ 1.4**: å®ç° `IPersistenceService` æ¥å£ (åŸºç¡€è®¾æ–½å±‚)
- **(å®Œæˆ)æ­¥éª¤ 1.5**: å®ç° `IChannelStateManager` æ¥å£åŠæ ¸å¿ƒé€»è¾‘ (é¢†åŸŸå±‚)

#### Phase 2: åç«¯æ ¸å¿ƒä¸šåŠ¡é€»è¾‘å®ç° - é¢†åŸŸå±‚ä¸åº”ç”¨å±‚
- **(å®Œæˆ)æ­¥éª¤ 2.1**: å®ç° `ISpecificTestStepExecutor` æ¥å£åŠè‹¥å¹²å…·ä½“æ‰§è¡Œå™¨ (é¢†åŸŸå±‚)
- **(å®Œæˆ)æ­¥éª¤ 2.2**: å®ç° `ITestExecutionEngine` æ¥å£åŠå¹¶å‘æ§åˆ¶é€»è¾‘ (é¢†åŸŸå±‚)
- **(å®Œæˆ)æ­¥éª¤ 2.3**: å®ç° `ITestRecordService` æ¥å£åŠåŸºæœ¬å®ç° (é¢†åŸŸå±‚)
- **(å®Œæˆ)æ­¥éª¤ 2.4**: å®ç° `IDataManagementService` æ¥å£åŠåˆæ­¥Excelå¯¼å…¥ä¸é…ç½®ç®¡ç†é€»è¾‘ (åº”ç”¨å±‚)
- **(å®Œæˆ)æ­¥éª¤ 2.5**: å®ç° `ITestOrchestrationService` æ¥å£éª¨æ¶åŠæ ¸å¿ƒæµç¨‹çš„åˆæ­¥ä¸²è” (åº”ç”¨å±‚)

#### Phase 3: Tauri é›†æˆä¸åç«¯æœåŠ¡å®Œå–„
- **(å®Œæˆ)æ­¥éª¤ 3.1**: å®Œå–„æ‰€æœ‰åç«¯æœåŠ¡æ¥å£çš„å…¶ä½™æ–¹æ³•å®ç°
- **(å®Œæˆ)æ­¥éª¤ 3.2**: æ­å»º Tauri åº”ç”¨éª¨æ¶
- **(å®Œæˆ)æ­¥éª¤ 3.3**: åœ¨ Tauri `main.rs` ä¸­è®¾ç½®åº”ç”¨çŠ¶æ€ï¼Œå®ä¾‹åŒ–å¹¶æ³¨å…¥æœåŠ¡ä¾èµ–
- **(å®Œæˆ)æ­¥éª¤ 3.4**: å®ç°æ ¸å¿ƒä¸šåŠ¡æµç¨‹çš„ Tauri Commands
- **(å®Œæˆ)æ­¥éª¤ 3.5**: å®ç°åç«¯åˆ°å‰ç«¯çš„äº‹ä»¶é€šçŸ¥æœºåˆ¶ (Tauri Events)

#### Phase 4: å‰ç«¯åŸºç¡€æ¶æ„ä¸æ ¸å¿ƒç»„ä»¶
- **(å®Œæˆ)æ­¥éª¤ 4.1**: åˆå§‹åŒ– Angular é¡¹ç›®å¹¶é›†æˆåˆ° Tauri
- **(å®Œæˆ)æ­¥éª¤ 4.2**: åˆ›å»º Angular æ ¸å¿ƒæœåŠ¡ä»¥å°è£… Tauri é€šä¿¡
- **(å®Œæˆ)æ­¥éª¤ 4.3**: åˆ›å»ºæ ¸å¿ƒé¡µé¢ç»„ä»¶éª¨æ¶
- **(å®Œæˆ)æ­¥éª¤ 4.4**: åˆæ­¥å®ç°æ ¸å¿ƒé¡µé¢çš„æ•°æ®ç»‘å®šå’Œäº¤äº’

#### Phase 5: UI/UX ç»†åŒ–ä¸åŠŸèƒ½å®Œå–„
- **(å®Œæˆ)æ­¥éª¤ 5.1**: UI ç»„ä»¶åº“é›†æˆä¸å…¨å±€æ ·å¼å®šä¹‰
- **(å®Œæˆ)æ­¥éª¤ 5.2**: å®Œå–„ `BatchManagementComponent` åŠŸèƒ½ä¸UI
- **(å®Œæˆ)æ­¥éª¤ 5.3**: å®Œå–„ `TestExecutionComponent` åŠŸèƒ½ä¸UI
- **(å®Œæˆ)æ­¥éª¤ 5.4**: å®ç° `ChannelDetailComponent` å’Œ `ManualTestComponent`
- **(å®Œæˆ)æ­¥éª¤ 5.5**: å®ç°åº”ç”¨é…ç½®çš„æŒä¹…åŒ–ä¸åŠ è½½ (`AppSettings`)
- **(å®Œæˆ)æ­¥éª¤ 5.6**: å®ç°ç³»ç»Ÿç›‘æ§ç»„ä»¶å’ŒæŠ¥å‘Šç”ŸæˆåŠŸèƒ½

### ğŸ”„ å¾…å®Œæˆçš„æ­¥éª¤

#### Phase 6: çœŸå®ç¡¬ä»¶è”è°ƒã€æ‰“åŒ…ä¸éƒ¨ç½²å‡†å¤‡
- **æ­¥éª¤ 6.1**: `IPlcCommunicationService` çœŸå®å®ç°
- **æ­¥éª¤ 6.2**: æ›¿æ¢ Mock æœåŠ¡ä¸ºçœŸå®å®ç°å¹¶è¿›è¡Œå®Œæ•´æµç¨‹è”è°ƒ
- **æ­¥éª¤ 6.3**: åº”ç”¨å›¾æ ‡ã€å…ƒæ•°æ®å’Œæ‰“åŒ…é…ç½®
- **æ­¥éª¤ 6.4**: æ„å»ºç”Ÿäº§ç‰ˆæœ¬å¹¶æµ‹è¯•å®‰è£…åŒ…
- **æ­¥éª¤ 6.5**: ç¼–å†™ç”¨æˆ·æ‰‹å†Œå’Œéƒ¨ç½²æ–‡æ¡£ (å¯é€‰)

### ğŸ“Š å®Œæˆè¿›åº¦ç»Ÿè®¡
- **æ€»æ­¥éª¤æ•°**: 21ä¸ªæ­¥éª¤
- **å·²å®Œæˆ**: 16ä¸ªæ­¥éª¤ (76.2%)
- **å¾…å®Œæˆ**: 5ä¸ªæ­¥éª¤ (23.8%)

### ğŸ¯ å½“å‰çŠ¶æ€
é¡¹ç›®å·²å®Œæˆå‰ç«¯Angularåº”ç”¨çš„å®Œæ•´å®ç°ï¼ŒåŒ…æ‹¬æ‰€æœ‰æ ¸å¿ƒåŠŸèƒ½æ¨¡å—ã€ç”¨æˆ·ç•Œé¢ç»„ä»¶å’Œç³»ç»Ÿé›†æˆã€‚åç«¯RustæœåŠ¡æ¶æ„å·²å»ºç«‹ï¼ŒMockæœåŠ¡å·²å®ç°ã€‚ä¸‹ä¸€æ­¥å°†è¿›å…¥çœŸå®ç¡¬ä»¶è”è°ƒå’Œç”Ÿäº§éƒ¨ç½²å‡†å¤‡é˜¶æ®µã€‚

---

## é¡¹ç›®ç›®å½•ç»“æ„ (Project Directory Structure)

ä»¥ä¸‹æ˜¯åŸºäº Rust + Angular + Tauri æŠ€æœ¯æ ˆçš„å®Œæ•´é¡¹ç›®ç›®å½•ç»“æ„ï¼Œæ¶µç›–äº†åç«¯æœåŠ¡ã€å‰ç«¯UIå’Œæ¡Œé¢åº”ç”¨æ‰“åŒ…çš„æ‰€æœ‰ç»„ä»¶ï¼š

```
fat-test-desktop-app/                          # Tauri é¡¹ç›®æ ¹ç›®å½•
â”œâ”€â”€ README.md                                  # é¡¹ç›®æ€»ä½“è¯´æ˜æ–‡æ¡£
â”œâ”€â”€ package.json                               # npm scripts for Tauri commands
â”œâ”€â”€ node_modules/                              # Node.js ä¾èµ– (Tauri CLI ç­‰)
â”‚
â”œâ”€â”€ src-tauri/                                 # Rust åç«¯ + Tauri é›†æˆ
â”‚   â”œâ”€â”€ Cargo.toml                            # Rust ä¾èµ–é…ç½®
â”‚   â”œâ”€â”€ Cargo.lock                            # é”å®šçš„ä¾èµ–ç‰ˆæœ¬
â”‚   â”œâ”€â”€ tauri.conf.json                       # Tauri åº”ç”¨é…ç½®
â”‚   â”œâ”€â”€ build.rs                              # æ„å»ºè„šæœ¬
â”‚   â”œâ”€â”€ icons/                                # åº”ç”¨å›¾æ ‡èµ„æº
â”‚   â”‚   â”œâ”€â”€ 32x32.png
â”‚   â”‚   â”œâ”€â”€ 128x128.png
â”‚   â”‚   â”œâ”€â”€ 128x128@2x.png
â”‚   â”‚   â”œâ”€â”€ icon.icns                         # macOS å›¾æ ‡
â”‚   â”‚   â”œâ”€â”€ icon.ico                          # Windows å›¾æ ‡
â”‚   â”‚   â”œâ”€â”€ installer.ico                     # å®‰è£…ç¨‹åºå›¾æ ‡
â”‚   â”‚   â””â”€â”€ Square***.png                     # Windows Store å›¾æ ‡
â”‚   â”‚
â”‚   â””â”€â”€ src/                                  # Rust æºä»£ç 
â”‚       â”œâ”€â”€ main.rs                           # Tauri åº”ç”¨å…¥å£ç‚¹
â”‚       â”œâ”€â”€ lib.rs                            # åº“æ ¹æ¨¡å— (å¯é€‰)
â”‚       â”‚
â”‚       â”œâ”€â”€ commands/                         # Tauri Commands (å‰ç«¯è°ƒç”¨æ¥å£)
â”‚       â”‚   â”œâ”€â”€ mod.rs
â”‚       â”‚   â”œâ”€â”€ batch_management.rs           # æ‰¹æ¬¡ç®¡ç†ç›¸å…³å‘½ä»¤
â”‚       â”‚   â”œâ”€â”€ test_orchestration.rs         # æµ‹è¯•ç¼–æ’ç›¸å…³å‘½ä»¤
â”‚       â”‚   â”œâ”€â”€ manual_test.rs                # æ‰‹åŠ¨æµ‹è¯•ç›¸å…³å‘½ä»¤
â”‚       â”‚   â”œâ”€â”€ data_management.rs            # æ•°æ®ç®¡ç†ç›¸å…³å‘½ä»¤
â”‚       â”‚   â”œâ”€â”€ channel_config.rs             # é€šé“é…ç½®ç›¸å…³å‘½ä»¤
â”‚       â”‚   â””â”€â”€ system_settings.rs            # ç³»ç»Ÿè®¾ç½®ç›¸å…³å‘½ä»¤
â”‚       â”‚
â”‚       â”œâ”€â”€ events/                           # Tauri Events (åç«¯æ¨é€ç»™å‰ç«¯)
â”‚       â”‚   â”œâ”€â”€ mod.rs
â”‚       â”‚   â”œâ”€â”€ channel_state_events.rs       # é€šé“çŠ¶æ€å˜æ›´äº‹ä»¶
â”‚       â”‚   â”œâ”€â”€ batch_progress_events.rs      # æ‰¹æ¬¡è¿›åº¦äº‹ä»¶
â”‚       â”‚   â”œâ”€â”€ log_events.rs                 # æ—¥å¿—äº‹ä»¶
â”‚       â”‚   â””â”€â”€ system_events.rs              # ç³»ç»ŸçŠ¶æ€äº‹ä»¶
â”‚       â”‚
â”‚       â”œâ”€â”€ state/                            # Tauri çŠ¶æ€ç®¡ç†
â”‚       â”‚   â”œâ”€â”€ mod.rs
â”‚       â”‚   â”œâ”€â”€ app_state.rs                  # åº”ç”¨å…¨å±€çŠ¶æ€
â”‚       â”‚   â””â”€â”€ service_container.rs          # æœåŠ¡å®¹å™¨/ä¾èµ–æ³¨å…¥
â”‚       â”‚
â”‚       â”œâ”€â”€ models/                           # æ•°æ®æ¨¡å‹å±‚
â”‚       â”‚   â”œâ”€â”€ mod.rs
â”‚       â”‚   â”œâ”€â”€ enums.rs                      # æ ¸å¿ƒæšä¸¾å®šä¹‰
â”‚       â”‚   â”‚   â””â”€â”€ # OverallTestStatus, SubTestStatus, ModuleType, 
â”‚       â”‚   â”‚       # PointDataType, SubTestItem, LogLevelEvent
â”‚       â”‚   â”œâ”€â”€ structs.rs                    # æ ¸å¿ƒç»“æ„ä½“å®šä¹‰
â”‚       â”‚   â”‚   â””â”€â”€ # ChannelPointDefinition, ChannelTestInstance, 
â”‚       â”‚   â”‚       # TestBatchInfo, RawTestOutcome, SubTestExecutionResult,
â”‚       â”‚   â”‚       # AnalogReadingPoint
â”‚       â”‚   â”œâ”€â”€ command_payloads.rs           # Tauri Command å‚æ•°/å“åº”æ¨¡å‹
â”‚       â”‚   â”‚   â””â”€â”€ # ImportExcelAndPrepareBatchCmdArgs, StartTestsForBatchCmdArgs,
â”‚       â”‚   â”‚       # ImportAndPrepareBatchResponse, BatchDetailsPayload,
â”‚       â”‚   â”‚       # ExecuteManualSubTestCmdArgs, ReadChannelValueCmdArgs
â”‚       â”‚   â”œâ”€â”€ event_payloads.rs             # Tauri Event Payload æ¨¡å‹
â”‚       â”‚   â”‚   â””â”€â”€ # ChannelStateChangedEventPayload, BatchProgressEventPayload,
â”‚       â”‚   â”‚       # LogMessageEventPayload
â”‚       â”‚   â””â”€â”€ settings.rs                   # åº”ç”¨è®¾ç½®æ•°æ®æ¨¡å‹
â”‚       â”‚       â””â”€â”€ # AppSettings, PlcConnectionSettings, TestConfiguration
â”‚       â”‚
â”‚       â”œâ”€â”€ services/                         # ä¸šåŠ¡æœåŠ¡å±‚
â”‚       â”‚   â”œâ”€â”€ mod.rs
â”‚       â”‚   â”‚
â”‚       â”‚   â”œâ”€â”€ application/                  # åº”ç”¨å±‚æœåŠ¡ (ç¼–æ’ä¸šåŠ¡ç”¨ä¾‹)
â”‚       â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚       â”‚   â”‚   â”œâ”€â”€ test_orchestration_service.rs  # æµ‹è¯•ç¼–æ’æœåŠ¡ (æ ¸å¿ƒ)
â”‚       â”‚   â”‚   â”œâ”€â”€ data_management_service.rs     # æ•°æ®ç®¡ç†æœåŠ¡ (å¯¼å…¥/å¯¼å‡º)
â”‚       â”‚   â”‚   â”œâ”€â”€ manual_test_service.rs         # æ‰‹åŠ¨æµ‹è¯•æœåŠ¡
â”‚       â”‚   â”‚   â”œâ”€â”€ channel_config_service.rs      # é€šé“é…ç½®æœåŠ¡
â”‚       â”‚   â”‚   â””â”€â”€ notification_service.rs        # é€šçŸ¥/äº‹ä»¶å‘å¸ƒæœåŠ¡
â”‚       â”‚   â”‚
â”‚       â”‚   â”œâ”€â”€ domain/                       # é¢†åŸŸæœåŠ¡å±‚ (æ ¸å¿ƒä¸šåŠ¡é€»è¾‘)
â”‚       â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚       â”‚   â”‚   â”œâ”€â”€ channel_state_manager.rs       # é€šé“çŠ¶æ€ç®¡ç†å™¨ (å”¯ä¸€çŠ¶æ€ä¿®æ”¹ç‚¹)
â”‚       â”‚   â”‚   â”œâ”€â”€ test_execution_engine.rs       # æµ‹è¯•æ‰§è¡Œå¼•æ“ (å¹¶å‘æ§åˆ¶)
â”‚       â”‚   â”‚   â”œâ”€â”€ specific_test_executors/       # ç‰¹å®šæµ‹è¯•æ­¥éª¤æ‰§è¡Œå™¨
â”‚       â”‚   â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚       â”‚   â”‚   â”‚   â”œâ”€â”€ ai_test_executor.rs        # AIç‚¹æµ‹è¯•æ‰§è¡Œå™¨
â”‚       â”‚   â”‚   â”‚   â”œâ”€â”€ ao_test_executor.rs        # AOç‚¹æµ‹è¯•æ‰§è¡Œå™¨
â”‚       â”‚   â”‚   â”‚   â”œâ”€â”€ di_test_executor.rs        # DIç‚¹æµ‹è¯•æ‰§è¡Œå™¨
â”‚       â”‚   â”‚   â”‚   â”œâ”€â”€ do_test_executor.rs        # DOç‚¹æµ‹è¯•æ‰§è¡Œå™¨
â”‚       â”‚   â”‚   â”‚   â”œâ”€â”€ communication_test_executor.rs # é€šä¿¡æµ‹è¯•
â”‚       â”‚   â”‚   â”‚   â””â”€â”€ generic_read_write_executor.rs # é€šç”¨è¯»å†™æ‰§è¡Œå™¨
â”‚       â”‚   â”‚   â”œâ”€â”€ statistics_service.rs          # ç»Ÿè®¡æœåŠ¡
â”‚       â”‚   â”‚   â””â”€â”€ test_record_service.rs         # æµ‹è¯•è®°å½•æœåŠ¡
â”‚       â”‚   â”‚
â”‚       â”‚   â””â”€â”€ infrastructure/               # åŸºç¡€è®¾æ–½å±‚ (å¤–éƒ¨ç³»ç»Ÿäº¤äº’)
â”‚       â”‚       â”œâ”€â”€ mod.rs
â”‚       â”‚       â”œâ”€â”€ plc/                      # PLC é€šä¿¡ç›¸å…³
â”‚       â”‚       â”‚   â”œâ”€â”€ mod.rs
â”‚       â”‚       â”‚   â”œâ”€â”€ plc_communication_service.rs  # PLCé€šä¿¡æœåŠ¡æ¥å£
â”‚       â”‚       â”‚   â”œâ”€â”€ mock_plc_service.rs           # Mock PLCæœåŠ¡ (å¼€å‘/æµ‹è¯•)
â”‚       â”‚       â”‚   â”œâ”€â”€ modbus_plc_service.rs         # Modbus TCP PLCæœåŠ¡
â”‚       â”‚       â”‚   â”œâ”€â”€ s7_plc_service.rs             # Siemens S7 PLCæœåŠ¡
â”‚       â”‚       â”‚   â””â”€â”€ opcua_plc_service.rs          # OPC UA PLCæœåŠ¡
â”‚       â”‚       â”œâ”€â”€ persistence/              # æ•°æ®æŒä¹…åŒ–ç›¸å…³
â”‚       â”‚       â”‚   â”œâ”€â”€ mod.rs
â”‚       â”‚       â”‚   â”œâ”€â”€ persistence_service.rs       # æŒä¹…åŒ–æœåŠ¡æ¥å£
â”‚       â”‚       â”‚   â”œâ”€â”€ app_settings_service.rs      # åº”ç”¨é…ç½®æœåŠ¡ (JSONæ–‡ä»¶)
â”‚       â”‚       â”‚   â”œâ”€â”€ sqlite_persistence.rs        # SQLiteæ•°æ®åº“æŒä¹…åŒ–
â”‚       â”‚       â”‚   â””â”€â”€ mock_persistence.rs          # MockæŒä¹…åŒ–æœåŠ¡
â”‚       â”‚       â””â”€â”€ excel/                    # Excel å¤„ç†ç›¸å…³
â”‚       â”‚           â”œâ”€â”€ mod.rs
â”‚       â”‚           â”œâ”€â”€ excel_importer.rs            # Excelå¯¼å…¥å™¨
â”‚       â”‚           â””â”€â”€ excel_exporter.rs            # Excelå¯¼å‡ºå™¨
â”‚       â”‚
â”‚       â”œâ”€â”€ utils/                            # å·¥å…·æ¨¡å—
â”‚       â”‚   â”œâ”€â”€ mod.rs
â”‚       â”‚   â”œâ”€â”€ error.rs                      # é”™è¯¯ç±»å‹å®šä¹‰ (AppError)
â”‚       â”‚   â”œâ”€â”€ logging.rs                    # æ—¥å¿—é…ç½®
â”‚       â”‚   â”œâ”€â”€ config.rs                     # é…ç½®åŠ è½½/ç®¡ç†
â”‚       â”‚   â””â”€â”€ conversion.rs                 # æ•°æ®ç±»å‹è½¬æ¢å·¥å…·
â”‚       â”‚
â”‚       â””â”€â”€ tests/                            # é›†æˆæµ‹è¯•
â”‚           â”œâ”€â”€ mod.rs
â”‚           â”œâ”€â”€ command_tests.rs              # Tauri Command æµ‹è¯•
â”‚           â”œâ”€â”€ service_integration_tests.rs  # æœåŠ¡é›†æˆæµ‹è¯•
â”‚           â””â”€â”€ mock_data.rs                  # æµ‹è¯•æ•°æ®ç”Ÿæˆ
â”‚
â”œâ”€â”€ fat-test-frontend/                        # Angular å‰ç«¯åº”ç”¨
â”‚   â”œâ”€â”€ README.md                             # å‰ç«¯é¡¹ç›®è¯´æ˜
â”‚   â”œâ”€â”€ package.json                          # npm ä¾èµ–å’Œè„šæœ¬
â”‚   â”œâ”€â”€ package-lock.json
â”‚   â”œâ”€â”€ angular.json                          # Angular é¡¹ç›®é…ç½®
â”‚   â”œâ”€â”€ tsconfig.json                         # TypeScript é…ç½®
â”‚   â”œâ”€â”€ tsconfig.app.json
â”‚   â”œâ”€â”€ tsconfig.spec.json
â”‚   â”œâ”€â”€ karma.conf.js                         # æµ‹è¯•é…ç½®
â”‚   â”œâ”€â”€ .eslintrc.json                        # ESLint é…ç½®
â”‚   â”‚
â”‚   â”œâ”€â”€ src/                                  # Angular æºä»£ç 
â”‚   â”‚   â”œâ”€â”€ main.ts                           # Angular åº”ç”¨å¯åŠ¨å…¥å£
â”‚   â”‚   â”œâ”€â”€ index.html                        # HTML å…¥å£
â”‚   â”‚   â”œâ”€â”€ styles.scss                       # å…¨å±€æ ·å¼
â”‚   â”‚   â”œâ”€â”€ favicon.ico
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ app/                              # Angular åº”ç”¨æ ¹æ¨¡å—
â”‚   â”‚   â”‚   â”œâ”€â”€ app.module.ts                 # æ ¹æ¨¡å—
â”‚   â”‚   â”‚   â”œâ”€â”€ app.component.ts              # æ ¹ç»„ä»¶
â”‚   â”‚   â”‚   â”œâ”€â”€ app.component.html
â”‚   â”‚   â”‚   â”œâ”€â”€ app.component.scss
â”‚   â”‚   â”‚   â”œâ”€â”€ app.component.spec.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ app-routing.module.ts         # è·¯ç”±é…ç½®
â”‚   â”‚   â”‚   â”‚
â”‚   â”‚   â”‚   â”œâ”€â”€ models/                       # TypeScript æ•°æ®æ¨¡å‹
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts                  # æ¨¡å‹å¯¼å‡ºç´¢å¼•
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ backend-models.ts         # åç«¯æ•°æ®æ¨¡å‹æ¥å£
â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ # (TS interfaces for all Rust structs/enums)
â”‚   â”‚   â”‚   â”‚   â”‚       # OverallTestStatus, SubTestStatus, ModuleType,
â”‚   â”‚   â”‚   â”‚   â”‚       # ChannelPointDefinition, ChannelTestInstance,
â”‚   â”‚   â”‚   â”‚   â”‚       # TestBatchInfo, RawTestOutcome, etc.
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ command-models.ts         # Tauri Command å‚æ•°/å“åº”æ¥å£
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ event-models.ts           # Tauri Event Payload æ¥å£
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ ui-models.ts              # å‰ç«¯ç‰¹æœ‰çš„UIæ¨¡å‹
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ form-models.ts            # è¡¨å•æ•°æ®æ¨¡å‹
â”‚   â”‚   â”‚   â”‚
â”‚   â”‚   â”‚   â”œâ”€â”€ services/                     # Angular æœåŠ¡å±‚
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ backend-comms.service.ts  # Tauri é€šä¿¡å°è£…æœåŠ¡
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ test-orchestration-api.service.ts    # æµ‹è¯•ç¼–æ’APIæœåŠ¡
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ data-management-api.service.ts       # æ•°æ®ç®¡ç†APIæœåŠ¡
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ manual-test-api.service.ts           # æ‰‹åŠ¨æµ‹è¯•APIæœåŠ¡
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ channel-config-api.service.ts        # é€šé“é…ç½®APIæœåŠ¡
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ event-listener.service.ts            # Tauriäº‹ä»¶ç›‘å¬æœåŠ¡
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ ui-state.service.ts                  # UIçŠ¶æ€ç®¡ç†æœåŠ¡
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ notification.service.ts              # é€šçŸ¥/æç¤ºæœåŠ¡
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ settings.service.ts                  # è®¾ç½®ç®¡ç†æœåŠ¡
â”‚   â”‚   â”‚   â”‚
â”‚   â”‚   â”‚   â”œâ”€â”€ components/                   # Angular ç»„ä»¶
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ shared/                   # å…±äº«ç»„ä»¶
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ header/
â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ header.component.ts
â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ header.component.html
â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ header.component.scss
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ sidebar/
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ loading-spinner/
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ confirmation-dialog/
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ status-indicator/      # æµ‹è¯•çŠ¶æ€æŒ‡ç¤ºå™¨
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ progress-bar/          # è¿›åº¦æ¡ç»„ä»¶
â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ data-table/            # é€šç”¨æ•°æ®è¡¨æ ¼
â”‚   â”‚   â”‚   â”‚   â”‚
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ batch-management/         # æ‰¹æ¬¡ç®¡ç†é¡µé¢
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ batch-management.component.ts
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ batch-management.component.html
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ batch-management.component.scss
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ batch-list/           # æ‰¹æ¬¡åˆ—è¡¨å­ç»„ä»¶
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ batch-create/         # åˆ›å»ºæ‰¹æ¬¡å­ç»„ä»¶
â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ batch-details/        # æ‰¹æ¬¡è¯¦æƒ…å­ç»„ä»¶
â”‚   â”‚   â”‚   â”‚   â”‚
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ data-import/              # æ•°æ®å¯¼å…¥é¡µé¢
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ data-import.component.ts
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ data-import.component.html
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ data-import.component.scss
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ excel-upload/         # Excelæ–‡ä»¶ä¸Šä¼ å­ç»„ä»¶
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ point-preview/        # ç‚¹ä½é¢„è§ˆå­ç»„ä»¶
â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ import-progress/      # å¯¼å…¥è¿›åº¦å­ç»„ä»¶
â”‚   â”‚   â”‚   â”‚   â”‚
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ test-execution/           # æµ‹è¯•æ‰§è¡Œé¡µé¢ (æ ¸å¿ƒ)
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ test-execution.component.ts
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ test-execution.component.html
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ test-execution.component.scss
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ channel-list/         # é€šé“åˆ—è¡¨å­ç»„ä»¶
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ channel-detail/       # é€šé“è¯¦æƒ…å­ç»„ä»¶
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ test-control-panel/   # æµ‹è¯•æ§åˆ¶é¢æ¿
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ batch-progress/       # æ‰¹æ¬¡è¿›åº¦æ˜¾ç¤º
â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ real-time-status/     # å®æ—¶çŠ¶æ€ç›‘æ§
â”‚   â”‚   â”‚   â”‚   â”‚
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ manual-test/              # æ‰‹åŠ¨æµ‹è¯•é¡µé¢
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ manual-test.component.ts
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ manual-test.component.html
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ manual-test.component.scss
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ manual-test-panel/    # æ‰‹åŠ¨æµ‹è¯•æ“ä½œé¢æ¿
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ value-input/          # æ•°å€¼è¾“å…¥å­ç»„ä»¶
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ alarm-test/           # æŠ¥è­¦æµ‹è¯•å­ç»„ä»¶
â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ reading-display/      # è¯»æ•°æ˜¾ç¤ºå­ç»„ä»¶
â”‚   â”‚   â”‚   â”‚   â”‚
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ channel-configuration/    # é€šé“é…ç½®é¡µé¢
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ channel-configuration.component.ts
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ channel-configuration.component.html
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ channel-configuration.component.scss
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ channel-editor/       # é€šé“ç¼–è¾‘å™¨
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ module-config/        # æ¨¡å—é…ç½®
â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ plc-address-config/   # PLCåœ°å€é…ç½®
â”‚   â”‚   â”‚   â”‚   â”‚
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ reports/                  # æŠ¥å‘Šä¸å¯¼å‡ºé¡µé¢
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ reports.component.ts
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ reports.component.html
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ reports.component.scss
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ test-results-report/  # æµ‹è¯•ç»“æœæŠ¥å‘Š
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ statistics-report/    # ç»Ÿè®¡æŠ¥å‘Š
â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ export-options/       # å¯¼å‡ºé€‰é¡¹
â”‚   â”‚   â”‚   â”‚   â”‚
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ system-settings/          # ç³»ç»Ÿè®¾ç½®é¡µé¢
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ system-settings.component.ts
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ system-settings.component.html
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ system-settings.component.scss
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ plc-settings/         # PLCè¿æ¥è®¾ç½®
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ test-parameters/      # æµ‹è¯•å‚æ•°è®¾ç½®
â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ application-settings/ # åº”ç”¨ç¨‹åºè®¾ç½®
â”‚   â”‚   â”‚   â”‚   â”‚
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ logs/                     # æ—¥å¿—æŸ¥çœ‹é¡µé¢
â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ logs.component.ts
â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ logs.component.html
â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ logs.component.scss
â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ log-viewer/           # æ—¥å¿—æŸ¥çœ‹å™¨
â”‚   â”‚   â”‚   â”‚       â””â”€â”€ log-filter/           # æ—¥å¿—ç­›é€‰å™¨
â”‚   â”‚   â”‚   â”‚
â”‚   â”‚   â”‚   â”œâ”€â”€ pipes/                        # Angular ç®¡é“
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ test-status.pipe.ts       # æµ‹è¯•çŠ¶æ€æ˜¾ç¤ºç®¡é“
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ duration.pipe.ts          # æ—¶é•¿æ ¼å¼åŒ–ç®¡é“
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ engineering-unit.pipe.ts  # å·¥ç¨‹å•ä½æ ¼å¼åŒ–ç®¡é“
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ safe-html.pipe.ts         # å®‰å…¨HTMLç®¡é“
â”‚   â”‚   â”‚   â”‚
â”‚   â”‚   â”‚   â”œâ”€â”€ directives/                   # Angular æŒ‡ä»¤
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ auto-focus.directive.ts   # è‡ªåŠ¨èšç„¦æŒ‡ä»¤
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ number-only.directive.ts  # ä»…æ•°å­—è¾“å…¥æŒ‡ä»¤
â”‚   â”‚   â”‚   â”‚
â”‚   â”‚   â”‚   â”œâ”€â”€ guards/                       # è·¯ç”±å®ˆå«
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ batch-loaded.guard.ts     # æ‰¹æ¬¡åŠ è½½å®Œæˆå®ˆå«
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ unsaved-changes.guard.ts  # æœªä¿å­˜æ›´æ”¹å®ˆå«
â”‚   â”‚   â”‚   â”‚
â”‚   â”‚   â”‚   â””â”€â”€ interceptors/                 # HTTP æ‹¦æˆªå™¨
â”‚   â”‚   â”‚       â”œâ”€â”€ index.ts
â”‚   â”‚   â”‚       â”œâ”€â”€ error-handler.interceptor.ts  # é”™è¯¯å¤„ç†æ‹¦æˆªå™¨
â”‚   â”‚   â”‚       â””â”€â”€ loading.interceptor.ts         # åŠ è½½çŠ¶æ€æ‹¦æˆªå™¨
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ assets/                           # é™æ€èµ„æº
â”‚   â”‚   â”‚   â”œâ”€â”€ images/                       # å›¾ç‰‡èµ„æº
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ logo.png
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ icons/                    # UIå›¾æ ‡
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ illustrations/            # æ’ç”»å›¾ç‰‡
â”‚   â”‚   â”‚   â”œâ”€â”€ i18n/                         # å›½é™…åŒ–æ–‡ä»¶
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ en.json                   # è‹±æ–‡è¯­è¨€åŒ…
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ zh-CN.json                # ä¸­æ–‡è¯­è¨€åŒ…
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ zh-TW.json                # ç¹ä½“ä¸­æ–‡è¯­è¨€åŒ…
â”‚   â”‚   â”‚   â””â”€â”€ styles/                       # æ ·å¼æ–‡ä»¶
â”‚   â”‚   â”‚       â”œâ”€â”€ _variables.scss           # SCSSå˜é‡
â”‚   â”‚   â”‚       â”œâ”€â”€ _mixins.scss              # SCSSæ··åˆ
â”‚   â”‚   â”‚       â”œâ”€â”€ _themes.scss              # ä¸»é¢˜æ ·å¼
â”‚   â”‚   â”‚       â””â”€â”€ _utilities.scss           # å·¥å…·ç±»æ ·å¼
â”‚   â”‚   â”‚
â”‚   â”‚   â””â”€â”€ environments/                     # ç¯å¢ƒé…ç½®
â”‚   â”‚       â”œâ”€â”€ environment.ts                # å¼€å‘ç¯å¢ƒé…ç½®
â”‚   â”‚       â”œâ”€â”€ environment.prod.ts           # ç”Ÿäº§ç¯å¢ƒé…ç½®
â”‚   â”‚       â””â”€â”€ environment.test.ts           # æµ‹è¯•ç¯å¢ƒé…ç½®
â”‚   â”‚
â”‚   â”œâ”€â”€ e2e/                                  # ç«¯åˆ°ç«¯æµ‹è¯•
â”‚   â”‚   â”œâ”€â”€ protractor.conf.js
â”‚   â”‚   â”œâ”€â”€ tsconfig.json
â”‚   â”‚   â””â”€â”€ src/
â”‚   â”‚       â”œâ”€â”€ app.e2e-spec.ts
â”‚   â”‚       â””â”€â”€ app.po.ts
â”‚   â”‚
â”‚   â””â”€â”€ dist/                                 # Angular æ„å»ºè¾“å‡º (ç”± ng build ç”Ÿæˆ)
â”‚       â””â”€â”€ fat-test-frontend/
â”‚
â”œâ”€â”€ docs/                                     # é¡¹ç›®æ–‡æ¡£
â”‚   â”œâ”€â”€ README.md                             # é¡¹ç›®æ€»ä½“æ–‡æ¡£
â”‚   â”œâ”€â”€ ARCHITECTURE.md                       # æ¶æ„è®¾è®¡æ–‡æ¡£
â”‚   â”œâ”€â”€ API.md                                # APIæ¥å£æ–‡æ¡£
â”‚   â”œâ”€â”€ DEPLOYMENT.md                         # éƒ¨ç½²è¯´æ˜æ–‡æ¡£
â”‚   â”œâ”€â”€ USER_MANUAL.md                        # ç”¨æˆ·ä½¿ç”¨æ‰‹å†Œ
â”‚   â”œâ”€â”€ DEVELOPMENT.md                        # å¼€å‘ç¯å¢ƒæ­å»ºæŒ‡å—
â”‚   â””â”€â”€ CHANGELOG.md                          # ç‰ˆæœ¬æ›´æ–°æ—¥å¿—
â”‚
â”œâ”€â”€ scripts/                                  # æ„å»ºå’Œéƒ¨ç½²è„šæœ¬
â”‚   â”œâ”€â”€ build-all.sh                          # å®Œæ•´æ„å»ºè„šæœ¬
â”‚   â”œâ”€â”€ dev-setup.sh                          # å¼€å‘ç¯å¢ƒé…ç½®è„šæœ¬
â”‚   â”œâ”€â”€ test-all.sh                           # è¿è¡Œæ‰€æœ‰æµ‹è¯•è„šæœ¬
â”‚   â””â”€â”€ release.sh                            # å‘å¸ƒè„šæœ¬
â”‚
â”œâ”€â”€ tests/                                    # ç«¯åˆ°ç«¯é›†æˆæµ‹è¯•
â”‚   â”œâ”€â”€ fixtures/                             # æµ‹è¯•æ•°æ®å’Œæ–‡ä»¶
â”‚   â”‚   â”œâ”€â”€ sample_excel_imports/             # ç¤ºä¾‹Excelå¯¼å…¥æ–‡ä»¶
â”‚   â”‚   â”œâ”€â”€ mock_plc_data/                    # Mock PLCæ•°æ®
â”‚   â”‚   â””â”€â”€ test_configurations/              # æµ‹è¯•é…ç½®æ–‡ä»¶
â”‚   â”œâ”€â”€ integration/                          # é›†æˆæµ‹è¯•ç”¨ä¾‹
â”‚   â”‚   â”œâ”€â”€ full_workflow_tests.rs
â”‚   â”‚   â”œâ”€â”€ plc_communication_tests.rs
â”‚   â”‚   â””â”€â”€ data_persistence_tests.rs
â”‚   â””â”€â”€ performance/                          # æ€§èƒ½æµ‹è¯•
â”‚       â”œâ”€â”€ load_tests.rs
â”‚       â””â”€â”€ stress_tests.rs
â”‚
â”œâ”€â”€ config/                                   # é…ç½®æ–‡ä»¶ç›®å½•
â”‚   â”œâ”€â”€ app_settings.json                     # åº”ç”¨é»˜è®¤è®¾ç½®
â”‚   â”œâ”€â”€ plc_configurations/                   # PLCé…ç½®æ–‡ä»¶æ¨¡æ¿
â”‚   â”‚   â”œâ”€â”€ modbus_tcp_template.json
â”‚   â”‚   â”œâ”€â”€ s7_template.json
â”‚   â”‚   â””â”€â”€ opcua_template.json
â”‚   â””â”€â”€ test_parameters/                      # æµ‹è¯•å‚æ•°é…ç½®
â”‚       â”œâ”€â”€ ai_test_params.json
â”‚       â”œâ”€â”€ ao_test_params.json
â”‚       â”œâ”€â”€ di_test_params.json
â”‚       â””â”€â”€ do_test_params.json
â”‚
â”œâ”€â”€ data/                                     # è¿è¡Œæ—¶æ•°æ®ç›®å½• (åº”ç”¨ç”Ÿæˆ)
â”‚   â”œâ”€â”€ batches/                              # æ‰¹æ¬¡æ•°æ®å­˜å‚¨
â”‚   â”œâ”€â”€ configurations/                       # ä¿å­˜çš„é…ç½®
â”‚   â”œâ”€â”€ logs/                                 # åº”ç”¨æ—¥å¿—æ–‡ä»¶
â”‚   â””â”€â”€ exports/                              # å¯¼å‡ºçš„æµ‹è¯•æŠ¥å‘Š
â”‚
â”œâ”€â”€ .gitignore                                # Git å¿½ç•¥æ–‡ä»¶é…ç½®
â”œâ”€â”€ .github/                                  # GitHub Actions CI/CD é…ç½®
â”‚   â””â”€â”€ workflows/
â”‚       â”œâ”€â”€ build-and-test.yml               # æ„å»ºå’Œæµ‹è¯•å·¥ä½œæµ
â”‚       â””â”€â”€ release.yml                       # å‘å¸ƒå·¥ä½œæµ
â”‚
â””â”€â”€ target/                                   # Rust æ„å»ºè¾“å‡º (ç”± cargo build ç”Ÿæˆ)
    â”œâ”€â”€ debug/                                # è°ƒè¯•ç‰ˆæœ¬æ„å»º
    â”œâ”€â”€ release/                              # å‘å¸ƒç‰ˆæœ¬æ„å»º
    â””â”€â”€ bundle/                               # Tauri æ‰“åŒ…è¾“å‡º
        â”œâ”€â”€ appimage/                         # Linux AppImage
        â”œâ”€â”€ deb/                              # Debian åŒ…
        â”œâ”€â”€ dmg/                              # macOS DMG
        â”œâ”€â”€ msi/                              # Windows MSI å®‰è£…åŒ…
        â””â”€â”€ nsis/                             # Windows NSIS å®‰è£…åŒ…
```

## ç›®å½•ç»“æ„è¯´æ˜

### åç«¯æ¶æ„å±‚æ¬¡æ˜ å°„
- **åº”ç”¨å±‚**: `src-tauri/src/services/application/` - ç¼–æ’ä¸šåŠ¡ç”¨ä¾‹ï¼Œå¯¹åº”æ¶æ„å›¾ä¸­çš„åº”ç”¨æœåŠ¡å±‚
- **é¢†åŸŸå±‚**: `src-tauri/src/services/domain/` - æ ¸å¿ƒä¸šåŠ¡é€»è¾‘ï¼ŒåŒ…å«çŠ¶æ€ç®¡ç†å’Œæµ‹è¯•æ‰§è¡Œå¼•æ“
- **åŸºç¡€è®¾æ–½å±‚**: `src-tauri/src/services/infrastructure/` - å¤–éƒ¨ç³»ç»Ÿäº¤äº’ï¼ŒPLCé€šä¿¡å’Œæ•°æ®æŒä¹…åŒ–
- **Taurié›†æˆå±‚**: `src-tauri/src/commands/` å’Œ `src-tauri/src/events/` - å‰åç«¯é€šä¿¡æ¡¥æ¢

### å‰ç«¯ç»„ä»¶æ¶æ„æ˜ å°„
- **è§†å›¾å±‚**: `fat-test-frontend/src/app/components/` - Angularç»„ä»¶å¯¹åº”æ¶æ„å›¾ä¸­çš„Viewå±‚
- **æœåŠ¡å±‚**: `fat-test-frontend/src/app/services/` - å°è£…Taurié€šä¿¡ï¼Œå¯¹åº”ViewModel/Component Logicå±‚
- **çŠ¶æ€ç®¡ç†**: `fat-test-frontend/src/app/services/ui-state.service.ts` - å‰ç«¯çŠ¶æ€ç®¡ç†

### å…³é”®è®¾è®¡åŸåˆ™ä½“ç°
- **å•ä¸€èŒè´£**: æ¯ä¸ªæœåŠ¡å’Œç»„ä»¶éƒ½æœ‰æ˜ç¡®çš„èŒè´£èŒƒå›´
- **ä¾èµ–å€’ç½®**: é€šè¿‡æ¥å£æŠ½è±¡å’Œä¾èµ–æ³¨å…¥å®ç°æ¾è€¦åˆ
- **åˆ†å±‚æ¶æ„**: æ¸…æ™°çš„åˆ†å±‚ç»“æ„ï¼Œä¸Šå±‚ä¾èµ–ä¸‹å±‚ï¼Œä¸‹å±‚ä¸ä¾èµ–ä¸Šå±‚
- **é¢†åŸŸé©±åŠ¨**: æ ¸å¿ƒä¸šåŠ¡é€»è¾‘é›†ä¸­åœ¨domainå±‚ï¼ŒçŠ¶æ€ç®¡ç†é›†ä¸­åœ¨ChannelStateManager

---

## 0. å¼•è¨€

æœ¬æ–‡æ¡£åŸºäºã€ŠæŠ€æœ¯æ ˆè¿ç§»ç³»ç»Ÿæ¶æ„è®¾è®¡ (FAT_TEST é¡¹ç›®)ã€‹æ–‡æ¡£ï¼Œæ—¨åœ¨æä¾›ä¸€ä¸ªè¯¦ç»†çš„ã€å¯æ“ä½œçš„æ­¥éª¤åŒ–å®æ–½æ–¹æ¡ˆï¼ŒæŒ‡å¯¼ FAT_TEST é¡¹ç›®ä»ç°æœ‰ C# WPF æŠ€æœ¯æ ˆå¹³ç¨³ã€é«˜æ•ˆåœ°è¿ç§»è‡³ `Rust + Angular + Tauri` æ–°æŠ€æœ¯æ ˆã€‚

æ¯ä¸ªæ­¥éª¤å°†åŒ…å«ä»¥ä¸‹å…³é”®ä¿¡æ¯ï¼š
*   **åŸå›  (Reason)**ï¼šä¸ºä»€ä¹ˆéœ€è¦æ‰§è¡Œæ­¤æ­¥éª¤ã€‚
*   **æœŸæœ›æ•ˆæœ (Expected Outcome)**ï¼šæ­¤æ­¥éª¤å®Œæˆååº”è¾¾æˆçš„å…·ä½“ç›®æ ‡å’Œäº§å‡ºç‰©ã€‚
*   **å®æ–½æè¿° (Implementation Description)**ï¼šå¦‚ä½•æ‰§è¡Œæ­¤æ­¥éª¤ï¼Œæ¶‰åŠçš„å…³é”®æŠ€æœ¯ç‚¹å’Œä»»åŠ¡ã€‚
*   **å¦‚ä½•æµ‹è¯• (How to Test)**ï¼šéªŒè¯æ­¤æ­¥éª¤æ˜¯å¦æˆåŠŸå®Œæˆçš„æ–¹æ³•å’Œæ ‡å‡†ã€‚

**æ€»ä½“è¿ç§»ç­–ç•¥ï¼š** é‡‡ç”¨å¢é‡å’Œè¿­ä»£çš„æ–¹å¼ï¼Œä¼˜å…ˆæ„å»ºæ ¸å¿ƒåç«¯é€»è¾‘å’Œæ•°æ®æµï¼Œç„¶åé€æ­¥å®Œå–„åº”ç”¨å±‚æœåŠ¡å’Œå‰ç«¯åŠŸèƒ½ã€‚å°½æ—©è¿›è¡Œé›†æˆæµ‹è¯•ï¼Œç¡®ä¿å„ç»„ä»¶ååŒå·¥ä½œã€‚

---

## Phase 1: åç«¯æ ¸å¿ƒåŸºç¡€å»ºè®¾ - é¢†åŸŸæ¨¡å‹ä¸åŸºç¡€è®¾æ–½å±‚ï¼ˆåˆæ­¥ï¼‰

**ç›®æ ‡ï¼š** æ­å»ºRuståç«¯é¡¹ç›®çš„åŸºæœ¬éª¨æ¶ï¼Œå®šä¹‰æ ¸å¿ƒé¢†åŸŸæ¨¡å‹ï¼Œå¹¶åˆæ­¥å®ç°åŸºç¡€è®¾æ–½æœåŠ¡çš„æ¥å£å’ŒMock/åŸºæœ¬å®ç°ï¼Œä¸ºä¸Šå±‚é€»è¾‘å¥ å®šåŸºç¡€ã€‚

### (å®Œæˆ)æ­¥éª¤ 1.1: å®šä¹‰æ ¸å¿ƒé¢†åŸŸæ¨¡å‹ (Rust Structs & Enums)

*   **åŸå›  (Reason)**:
    *   é¢†åŸŸæ¨¡å‹æ˜¯ç³»ç»Ÿçš„æ ¸å¿ƒï¼Œå®šä¹‰äº†ä¸šåŠ¡å®ä½“çš„æ•°æ®ç»“æ„å’ŒåŸºæœ¬è¡Œä¸ºçº¦æŸã€‚
    *   æ¸…æ™°ã€å‡†ç¡®çš„é¢†åŸŸæ¨¡å‹æ˜¯åç»­æ‰€æœ‰ä¸šåŠ¡é€»è¾‘å®ç°çš„åŸºç¡€ã€‚
    *   åœ¨é¡¹ç›®æ—©æœŸå°±ç»Ÿä¸€æ•°æ®ç»“æ„ï¼Œå¯ä»¥å‡å°‘åç»­å› æ¨¡å‹ä¸ä¸€è‡´å¯¼è‡´çš„è¿”å·¥ã€‚
*   **æœŸæœ›æ•ˆæœ (Expected Outcome)**:
    *   åœ¨ Rust é¡¹ç›®ä¸­åˆ›å»º `models.rs` (æˆ–ç±»ä¼¼æ¨¡å—)ï¼ŒåŒ…å«æ‰€æœ‰æ ¸å¿ƒæšä¸¾å’Œç»“æ„ä½“çš„å®šä¹‰ã€‚
    *   **æ ¸å¿ƒæšä¸¾å®šä¹‰ (Rust Enums)** (ä¸æ¶æ„æ–‡æ¡£åŒæ­¥):
        *   `OverallTestStatus`: (NotTested, Skipped, WiringConfirmed, HardPointTesting, HardPointTestCompleted, ManualTesting, TestCompletedPassed, TestCompletedFailed, Retesting)
        *   `SubTestStatus`: (NotTested, Testing, Passed, Failed, NotApplicable, Skipped)
        *   `ModuleType`: (AI, AO, DI, DO, AINone, AONone, DINone, DONone)
        *   `PointDataType`: (Bool, Float, Int)
        *   `SubTestItem`: (HardPoint, TrendCheck, ReportCheck, LowLowAlarm, LowAlarm, HighAlarm, HighHighAlarm, AlarmValueSetting, MaintenanceFunction, StateDisplay) - éœ€ `Eq, Hash`
    *   **æ ¸å¿ƒç»“æ„ä½“å®šä¹‰ (Rust Structs)** (ä¸æ¶æ„æ–‡æ¡£åŒæ­¥):
        *   `ChannelPointDefinition`
        *   `ChannelTestInstance`
        *   `SubTestExecutionResult`
        *   `AnalogReadingPoint`
        *   `TestBatchInfo`
        *   `RawTestOutcome`
    *   æ‰€æœ‰ç»“æ„ä½“å’Œæšä¸¾éƒ½åº”æ´¾ç”Ÿ `Debug`, `Clone`, `PartialEq` (æŒ‰éœ€)ã€‚ä¸ºäº†IPCå’ŒæŒä¹…åŒ–ï¼Œè¿˜éœ€æ´¾ç”Ÿ `Serialize`, `Deserialize` (ä½¿ç”¨ `serde`)ã€‚
    *   **é‡è¦**: è¿™äº›æ ¸å¿ƒç»“æ„ä½“ï¼ˆç‰¹åˆ«æ˜¯ `ChannelPointDefinition`, `ChannelTestInstance`, `TestBatchInfo`ï¼‰ä¹Ÿå°†ä½œä¸ºæ•°æ®åº“çš„å®ä½“ (Entities)ï¼Œå› æ­¤åœ¨é€‰æ‹©å¹¶é›†æˆ ORM (å¦‚ `SeaORM`, `Diesel`) åï¼Œå¯èƒ½éœ€è¦ä¸ºå®ƒä»¬æ·»åŠ  ORM ç‰¹å®šçš„ `derive` å® (ä¾‹å¦‚ `#[derive(EntityModel)]` for `SeaORM` or `#[derive(Queryable, Insertable)]` for `Diesel`) å¹¶å®šä¹‰å®ƒä»¬ä¸æ•°æ®åº“è¡¨çš„å…³ç³»ã€‚
    *   ä»£ç æäº¤åˆ°ç‰ˆæœ¬æ§åˆ¶ã€‚
*   **å®æ–½æè¿° (Implementation Description)**:
    1.  åœ¨ Rust é¡¹ç›®çš„ `src` ç›®å½•ä¸‹åˆ›å»º `models` æ¨¡å— (e.g., `src/models/mod.rs` å’Œ `src/models/enums.rs`, `src/models/structs.rs` æˆ–ç›´æ¥åœ¨ `src/models.rs`)ã€‚
    2.  æ·»åŠ  `serde` ä½œä¸ºä¾èµ–åˆ° `Cargo.toml` (`serde = { version = "1.0", features = ["derive"] }`)ã€‚
    3.  æ·»åŠ  `chrono` crate å¤„ç†æ—¥æœŸæ—¶é—´ (`chrono = { version = "0.4", features = ["serde"] }`)ã€‚
    4.  æ·»åŠ  `uuid` crate (`uuid = { version = "1.0", features = ["v4", "serde"] }`) ç”¨äºç”Ÿæˆå”¯ä¸€IDã€‚
    5.  **æšä¸¾å®šä¹‰ (ç¤ºä¾‹ `src/models/enums.rs` æˆ– `src/models.rs` - ä¸æ¶æ„æ–‡æ¡£å¯¹é½):**
        ```rust
        use serde::{Serialize, Deserialize};

        // ä¸æ¶æ„æ–‡æ¡£ä¸€è‡´
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum OverallTestStatus {
            NotTested,
            Skipped,
            WiringConfirmed,
            HardPointTesting,
            HardPointTestCompleted,
            ManualTesting,
            TestCompletedPassed,
            TestCompletedFailed,
            Retesting,
        }
        impl Default for OverallTestStatus { fn default() -> Self { OverallTestStatus::NotTested } }

        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum SubTestStatus {
            NotTested,
            Testing,
            Passed,
            Failed,
            NotApplicable,
            Skipped,
        }
        impl Default for SubTestStatus { fn default() -> Self { SubTestStatus::NotTested } }

        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum ModuleType {
            AI,
            AO,
            DI,
            DO,
            AINone,
            AONone,
            DINone,
            DONone,
        }

        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum PointDataType {
            Bool,
            Float,
            Int,
        }
        
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum SubTestItem {
            HardPoint,
            TrendCheck,
            ReportCheck,
            LowLowAlarm,
            LowAlarm,
            HighAlarm,
            HighHighAlarm,
            AlarmValueSetting,
            MaintenanceFunction,
            StateDisplay,
        }
        ```
    6.  **ç»“æ„ä½“å®šä¹‰ (ç¤ºä¾‹ `src/models/structs.rs` æˆ– `src/models.rs` - ä¸æ¶æ„æ–‡æ¡£å¯¹é½):**
        ```rust
        use serde::{Serialize, Deserialize};
        use std::collections::HashMap;
        use chrono::{DateTime, Utc};
        use uuid::Uuid; // ç”¨äºç”ŸæˆID
        use super::enums::*; // Assuming enums are in a sibling module or same file

        // Helper for default UUID
        fn default_uuid_string() -> String {
            Uuid::new_v4().to_string()
        }

        #[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
        pub struct ChannelPointDefinition {
            #[serde(default = "default_uuid_string")]
            pub id: String,
            pub tag: String,
            pub variable_name: String,
            pub variable_description: String,
            pub station_name: String,
            pub module_name: String,
            pub module_type: ModuleType,
            pub channel_tag_in_module: String,
            pub data_type: PointDataType,
            pub power_supply_type: String,
            pub wire_system: String,
            pub plc_absolute_address: Option<String>,
            pub plc_communication_address: String, // æ ¸å¿ƒ
            pub range_lower_limit: Option<f32>,
            pub range_upper_limit: Option<f32>,
            pub engineering_unit: Option<String>,
            pub sll_set_value: Option<f32>,
            pub sll_set_point_address: Option<String>,
            pub sll_feedback_address: Option<String>,
            pub sl_set_value: Option<f32>,
            pub sl_set_point_address: Option<String>,
            pub sl_feedback_address: Option<String>,
            pub sh_set_value: Option<f32>,
            pub sh_set_point_address: Option<String>,
            pub sh_feedback_address: Option<String>,
            pub shh_set_value: Option<f32>,
            pub shh_set_point_address: Option<String>,
            pub shh_feedback_address: Option<String>,
            pub maintenance_value_set_point_address: Option<String>,
            pub maintenance_enable_switch_point_address: Option<String>,
            pub access_property: Option<String>,
            pub save_history: Option<bool>,
            pub power_failure_protection: Option<bool>,
            pub test_rig_plc_address: Option<String>,
        }

        #[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
        pub struct SubTestExecutionResult {
            pub status: SubTestStatus,
            pub details: Option<String>,
            pub expected_value: Option<String>,
            pub actual_value: Option<String>,
            #[serde(with = "chrono::serde::ts_seconds")] // ä¿æŒä¸æ¶æ„æ–‡æ¡£ä¸€è‡´ï¼Œå°½ç®¡å…·ä½“æ ¼å¼å¯è°ƒæ•´
            pub timestamp: DateTime<Utc>,
        }

        #[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
        pub struct AnalogReadingPoint {
            pub set_percentage: f32,
            pub set_value_eng: f32,
            pub expected_reading_raw: Option<f32>,
            pub actual_reading_raw: Option<f32>,
            pub actual_reading_eng: Option<f32>,
            pub status: SubTestStatus,
        }

        #[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
        pub struct ChannelTestInstance {
            #[serde(default = "default_uuid_string")]
            pub instance_id: String,
            pub definition_id: String,
            pub test_batch_id: String,
            pub overall_status: OverallTestStatus,
            pub current_step_details: Option<String>,
            pub error_message: Option<String>,
            pub start_time: Option<DateTime<Utc>>,
            pub last_updated_time: DateTime<Utc>,
            pub final_test_time: Option<DateTime<Utc>>,
            pub total_test_duration_ms: Option<i64>,
            pub sub_test_results: HashMap<SubTestItem, SubTestExecutionResult>,
            pub hardpoint_readings: Option<Vec<AnalogReadingPoint>>,
            pub manual_test_current_value_input: Option<String>,
            pub manual_test_current_value_output: Option<String>,
        }
        
        impl Default for ChannelTestInstance {
            fn default() -> Self {
                ChannelTestInstance {
                    instance_id: default_uuid_string(),
                    definition_id: String::new(),
                    test_batch_id: String::new(),
                    overall_status: OverallTestStatus::default(),
                    current_step_details: None,
                    error_message: None,
                    start_time: None,
                    last_updated_time: Utc::now(),
                    final_test_time: None,
                    total_test_duration_ms: None,
                    sub_test_results: HashMap::new(),
                    hardpoint_readings: None,
                    manual_test_current_value_input: None,
                    manual_test_current_value_output: None,
                }
            }
        }

        #[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
        pub struct TestBatchInfo {
            #[serde(default = "default_uuid_string")]
            pub batch_id: String,
            pub product_model: Option<String>,
            pub serial_number: Option<String>,
            pub customer_name: Option<String>,
            pub creation_time: DateTime<Utc>,
            pub status_summary: Option<String>,
            pub total_points: u32,
            pub tested_points: u32,
            pub passed_points: u32,
            pub failed_points: u32,
        }

        impl Default for TestBatchInfo {
            fn default() -> Self {
                TestBatchInfo {
                    batch_id: default_uuid_string(),
                    product_model: None,
                    serial_number: None,
                    customer_name: None,
                    creation_time: Utc::now(),
                    status_summary: None,
                    total_points: 0,
                    tested_points: 0,
                    passed_points: 0,
                    failed_points: 0,
                }
            }
        }

        #[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
        pub struct RawTestOutcome {
            pub channel_instance_id: String,
            pub sub_test_item: SubTestItem,
            pub success: bool,
            pub raw_value_read: Option<String>,
            pub eng_value_calculated: Option<String>,
            pub message: Option<String>,
            pub timestamp: DateTime<Utc>,
            pub analog_reading_point: Option<AnalogReadingPoint>, 
        }
        ```
*   **å¦‚ä½•æµ‹è¯• (How to Test)**:
    *   **å•å…ƒæµ‹è¯•**:
        *   ç¼–å†™ç®€å•çš„å•å…ƒæµ‹è¯•æ¥éªŒè¯æ¨¡å‹çš„åˆ›å»ºã€å…‹éš†ã€‚
        *   æµ‹è¯• `serde` çš„åºåˆ—åŒ–å’Œååºåˆ—åŒ–åŠŸèƒ½ï¼Œç¡®ä¿æ¨¡å‹å¯ä»¥æ­£ç¡®è½¬æ¢ä¸ºJSONå­—ç¬¦ä¸²å¹¶ä»JSONå­—ç¬¦ä¸²æ¢å¤ã€‚
        *   ä¾‹å¦‚ï¼šåˆ›å»ºä¸€ä¸ª `ChannelPointDefinition` å®ä¾‹ï¼Œåºåˆ—åŒ–ä¸ºJSONï¼Œå†ååºåˆ—åŒ–å›æ¥ï¼Œæ¯”è¾ƒå‰åå¯¹è±¡æ˜¯å¦ä¸€è‡´ã€‚
    *   **ä»£ç å®¡æŸ¥**: æ£€æŸ¥å­—æ®µåã€ç±»å‹æ˜¯å¦ä¸æ¶æ„æ–‡æ¡£ä¸€è‡´ï¼Œ`derive` æ˜¯å¦å®Œæ•´ã€‚

### (å®Œæˆ)æ­¥éª¤ 1.2: æ­å»º Rust é¡¹ç›®åŸºæœ¬ç»“æ„ã€é…ç½®ä¸ç»Ÿä¸€é”™è¯¯å¤„ç†

*   **åŸå›  (Reason)**:
    *   ä¸€ä¸ªè‰¯å¥½ç»„ç»‡çš„é¡¹ç›®ç»“æ„ä¾¿äºä»£ç ç®¡ç†å’Œæ¨¡å—åŒ–å¼€å‘ã€‚
    *   ç»Ÿä¸€çš„é”™è¯¯å¤„ç†æœºåˆ¶èƒ½æé«˜ä»£ç çš„å¥å£®æ€§å’Œå¯ç»´æŠ¤æ€§ï¼Œæ–¹ä¾¿è°ƒè¯•ã€‚
*   **æœŸæœ›æ•ˆæœ (Expected Outcome)**:
    *   åˆ›å»º Rust åç«¯ä¸»é¡¹ç›® (e.g., `fat_test_backend`)ã€‚
    *   å®šä¹‰æ¸…æ™°çš„æ¨¡å—ç»“æ„ï¼Œå¦‚ `src/models`, `src/services`, `src/errors`, `src/config`, `src/main.rs`ã€‚
    *   å®ç°æ¶æ„æ–‡æ¡£ä¸­å®šä¹‰çš„ `AppError` æšä¸¾ï¼Œå¹¶é›†æˆ `thiserror` crateã€‚ç¡®ä¿ `AppError` èƒ½å¤Ÿå°è£…æ¥è‡ª ORM å’Œæ•°æ®åº“æ“ä½œçš„ç‰¹å®šé”™è¯¯ã€‚
    *   å»ºç«‹åˆæ­¥çš„é…ç½®ç®¡ç†æ–¹å¼ï¼ˆå¦‚ä»ç¯å¢ƒå˜é‡æˆ–é…ç½®æ–‡ä»¶è¯»å–ï¼‰ã€‚
*   **å®æ–½æè¿° (Implementation Description)**:
    1.  ä½¿ç”¨ `cargo new fat_test_backend --lib` (å¦‚æœä¸»è¦æ˜¯åº“) æˆ– `cargo new fat_test_backend` åˆ›å»ºé¡¹ç›®ã€‚å¦‚æœä½¿ç”¨Tauriï¼ŒTauriä¼šåˆ›å»ºé¡¹ç›®ç»“æ„ã€‚è¿™é‡Œå‡è®¾å…ˆç‹¬ç«‹æ„å»ºåç«¯æ ¸å¿ƒã€‚
    2.  åœ¨ `src` ç›®å½•ä¸‹è§„åˆ’æ¨¡å—ï¼š
        *   `errors.rs`: å®šä¹‰ `AppError`ã€‚
        *   `services/mod.rs`: ç”¨äºç»„ç»‡æœåŠ¡å±‚traitå’Œå®ç°ã€‚
        *   `config.rs`: (å¯é€‰) ç”¨äºåŠ è½½é…ç½®ã€‚
    3.  åœ¨ `Cargo.toml` ä¸­æ·»åŠ  `thiserror = "1.0"` å’Œ `serde = { version = "1.0", features = ["derive"] }`, `serde_json = "1.0"`ã€‚åç»­æ ¹æ®é€‰æ‹©çš„ORM (å¦‚ `sea-orm`, `diesel`) æ·»åŠ ç›¸åº”ä¾èµ–ã€‚
    4.  åœ¨ `errors.rs` ä¸­å®ç° `AppError` æšä¸¾ï¼Œä½¿ç”¨ `#[derive(Error, Debug, Clone, Serialize)]`ã€‚åŒ…å«å¦‚ `IoError`, `PersistenceError` (æ›´åä¸º `DatabaseOrmError` æˆ–ç±»ä¼¼ä»¥æ˜ç¡®æ¥æº), `PersistenceFileError` (ç”¨äºæ–‡ä»¶æ“ä½œå¦‚JSONé…ç½®), `PlcCommunicationError` ç­‰å˜ä½“ã€‚
        ```rust
        // Example AppError structure in errors.rs
        use serde::Serialize;
        use thiserror::Error;

        #[derive(Error, Debug, Clone, Serialize)]
        pub enum AppError {
            #[error("IO Error: {0}")]
            IoError(String),

            #[error("Database/ORM Error: {0}")]
            DatabaseOrmError(String),

            #[error("File Persistence Error: {0}")]
            FilePersistenceError(String), // For JSON config files etc.

            #[error("PLC Communication Error: {0}")]
            PlcCommunicationError(String),

            #[error("Configuration Error: {0}")]
            ConfigurationError(String),

            #[error("Invalid Input: {0}")]
            InvalidInputError(String),

            #[error("Not Found: {0} not found")]
            NotFoundError(String),

            #[error("Test Execution Error: {0}")]
            TestExecutionError(String),

            #[error("State Transition Error: {0}")]
            StateTransitionError(String),

            #[error("Service Error: {0}")]
            InternalServiceError(String),
            
            #[error("Tauri API Error: {0}")]
            TauriError(String),
        }

        // Helper for converting other errors to AppError
        // #[cfg(feature = "sea-orm")] // Conditional compilation if SeaORM is optional
        // impl From<sea_orm::DbErr> for AppError {
        //     fn from(err: sea_orm::DbErr) -> Self {
        //         AppError::DatabaseOrmError(err.to_string())
        //     }
        // }

        // Example: Convert Diesel's result::Error to AppError
        // #[cfg(feature = "diesel")] // Conditional compilation
        // impl From<diesel::result::Error> for AppError {
        //     fn from(err: diesel::result::Error) -> Self {
        //         AppError::DatabaseOrmError(err.to_string())
        //     }
        // }

        impl From<std::io::Error> for AppError {
            fn from(err: std::io::Error) -> Self {
                AppError::IoError(err.to_string())
            }
        }
        impl From<serde_json::Error> for AppError {
            fn from(err: serde_json::Error) -> Self {
                AppError::InternalServiceError(format!("JSON serialization/deserialization error: {}", err))
            }
        }
        ```
    5.  å®ç°å…¶ä»–å¿…è¦çš„ `From` Trait ä»¥ä¾¿å°†å¤–éƒ¨åº“çš„é”™è¯¯ï¼ˆç‰¹åˆ«æ˜¯é€‰å®šçš„ ORM åº“çš„é”™è¯¯ç±»å‹ï¼‰æ–¹ä¾¿åœ°è½¬æ¢ä¸º `AppError`ã€‚
    6.  (å¯é€‰) åˆæ­¥è®¾å®šæ—¥å¿—åº“ï¼Œå¦‚ `log` å’Œ `env_logger`ã€‚
*   **å¦‚ä½•æµ‹è¯• (How to Test)**:
    *   **å•å…ƒæµ‹è¯•**:
        *   ä¸º `AppError` ç¼–å†™æµ‹è¯•ï¼ŒéªŒè¯é”™è¯¯ç±»å‹çš„åˆ›å»ºå’Œ `to_string()` è¾“å‡ºã€‚
        *   æµ‹è¯• `From` Trait å®ç°ï¼Œç¡®ä¿å¤–éƒ¨é”™è¯¯èƒ½æ­£ç¡®è½¬æ¢ä¸º `AppError`ã€‚
    *   **ç¼–è¯‘é€šè¿‡**: ç¡®ä¿é¡¹ç›®ç»“æ„æ¸…æ™°ï¼Œæ¨¡å—é—´å¼•ç”¨æ­£ç¡®ï¼Œèƒ½å¤ŸæˆåŠŸç¼–è¯‘ã€‚

### (å®Œæˆ)æ­¥éª¤ 1.3: å®ç° `IPlcCommunicationService` æ¥å£åŠ Mock/åŸºæœ¬å®ç° (åŸºç¡€è®¾æ–½å±‚)

*   **åŸå›  (Reason)**:
    *   PLC é€šä¿¡æ˜¯ç³»ç»Ÿæ ¸å¿ƒåŠŸèƒ½ä¹‹ä¸€ï¼Œå°½æ—©å®šä¹‰æ¥å£å’Œæä¾›Mockå®ç°å¯ä»¥è§£è€¦ä¸Šå±‚é€»è¾‘å¼€å‘ã€‚
    *   Mock å®ç°å…è®¸åœ¨æ²¡æœ‰çœŸå®PLCç¡¬ä»¶æˆ–å®Œæ•´é©±åŠ¨çš„æƒ…å†µä¸‹è¿›è¡Œæµ‹è¯•ã€‚
*   **æœŸæœ›æ•ˆæœ (Expected Outcome)**:
    *   åœ¨ `src/services/infrastructure/plc_communication.rs` (æˆ–ç±»ä¼¼è·¯å¾„) ä¸­å®šä¹‰ `IPlcCommunicationService` traitï¼ŒåŒ…å«æ¶æ„æ–‡æ¡£ä¸­æè¿°çš„æ–¹æ³• (connect, disconnect, read_bool, write_f32, etc.)ã€‚
    *   æä¾›ä¸€ä¸ª `MockPlcCommunicationService` å®ç°è¯¥ trait:
        *   `connect`/`disconnect`/`is_connected` æ–¹æ³•åªè®°å½•æ—¥å¿—å¹¶è¿”å›å›ºå®šå€¼ã€‚
        *   `read_X` æ–¹æ³•è¿”å›é¢„è®¾çš„é»˜è®¤å€¼æˆ–æ ¹æ®è¾“å…¥åœ°å€è¿”å›ç‰¹å®š mock æ•°æ®ã€‚
        *   `write_X` æ–¹æ³•è®°å½•å†™å…¥çš„å€¼å’Œåœ°å€ï¼Œä½†ä¸è¿›è¡Œå®é™…æ“ä½œã€‚
    *   æ­¤ Mock æœåŠ¡åº”èƒ½æ»¡è¶³åç»­ `SpecificTestStepExecutor` åˆæ­¥å¼€å‘å’Œæµ‹è¯•çš„éœ€æ±‚ã€‚
*   **å®æ–½æè¿° (Implementation Description)**:
    1.  åˆ›å»º `src/services/infrastructure/mod.rs` å’Œ `src/services/infrastructure/plc_communication.rs`ã€‚
    2.  åœ¨ `plc_communication.rs` ä¸­å®šä¹‰ `IPlcCommunicationService` traitï¼Œä½¿ç”¨ `#[async_trait::async_trait]`ã€‚å®šä¹‰ `PlcTag` ç»“æ„ã€‚
    3.  å®ç° `MockPlcCommunicationService` structã€‚
        *   å¯ä»¥åœ¨ `MockPlcCommunicationService` ä¸­ä½¿ç”¨ `std::collections::HashMap` æ¥å­˜å‚¨é¢„è®¾çš„è¯»å–å€¼æˆ–è®°å½•å†™å…¥çš„å€¼ï¼Œä»¥ä¾¿æµ‹è¯•æ—¶éªŒè¯ã€‚
        *   ä¾‹å¦‚: `mock_reads: HashMap<String, serde_json::Value>`, `logged_writes: Vec<(String, serde_json::Value)>`ã€‚
    4.  æ‰€æœ‰ trait æ–¹æ³•è¿”å› `Result<T, AppError>`ã€‚
*   **å¦‚ä½•æµ‹è¯• (How to Test)**:
    *   **å•å…ƒæµ‹è¯•**:
        *   é’ˆå¯¹ `MockPlcCommunicationService` ç¼–å†™å•å…ƒæµ‹è¯•ã€‚
        *   æµ‹è¯•è¿æ¥/æ–­å¼€çŠ¶æ€æ¨¡æ‹Ÿã€‚
        *   æµ‹è¯•è¯»å–æ“ä½œï¼šéªŒè¯èƒ½å¦è¿”å›é¢„è®¾çš„ mock æ•°æ®ã€‚
        *   æµ‹è¯•å†™å…¥æ“ä½œï¼šéªŒè¯å†™å…¥çš„åœ°å€å’Œå€¼æ˜¯å¦è¢«æ­£ç¡®è®°å½•åœ¨ `MockPlcCommunicationService` å†…éƒ¨çŠ¶æ€ä¸­ã€‚
        *   æµ‹è¯•æ‰¹é‡è¯»å†™æ“ä½œã€‚

### (å®Œæˆ)æ­¥éª¤ 1.4: å®ç° `IPersistenceService` æ¥å£ (åŸºç¡€è®¾æ–½å±‚)

*   **åŸå›  (Reason)**:
    *   ä¸ºä¸Šå±‚æœåŠ¡æä¾›ç»Ÿä¸€çš„æ•°æ®æŒä¹…åŒ–æŠ½è±¡ï¼Œè§£è€¦ä¸šåŠ¡é€»è¾‘ä¸å…·ä½“çš„å­˜å‚¨æŠ€æœ¯ã€‚
    *   æ”¯æŒåç»­åœ¨ SQLite (é€šè¿‡ORM) å’Œ JSONæ–‡ä»¶ (åº”ç”¨é…ç½®) ä¹‹é—´åˆ‡æ¢æˆ–å…±å­˜ã€‚
*   **æœŸæœ›æ•ˆæœ (Expected Outcome)**:
    *   åœ¨ `src/services/infrastructure/persistence/persistence_service.rs` ä¸­å®šä¹‰ `IPersistenceService` traitï¼ŒåŒ…å«æ¶æ„æ–‡æ¡£ä¸­å®šä¹‰çš„æ‰€æœ‰æ–¹æ³•ã€‚
    *   æä¾›ä¸€ä¸ªåˆæ­¥çš„ `MockPersistenceService` å®ç°ï¼Œç”¨äºæ—©æœŸæµ‹è¯•ï¼Œæ‰€æœ‰æ–¹æ³•å¯èƒ½åªè®°å½•æ—¥å¿—æˆ–è¿”å›å›ºå®šæ•°æ®ã€‚
    *   åˆæ­¥å®ç° `SqliteOrmPersistenceService` (éª¨æ¶ï¼Œå…·ä½“ORMé›†æˆåœ¨åç»­æ­¥éª¤)ã€‚å®ƒçš„æ•°æ®åº“æ“ä½œæ–¹æ³• (å¦‚ `save_document`, `load_document`) è®¾è®¡ä¸ºé€šç”¨æ¥å£ï¼Œ**ä¾›ä¸Šå±‚æœåŠ¡ï¼ˆå¦‚ `ITestRecordService`ï¼‰è°ƒç”¨ã€‚è¿™äº›è°ƒç”¨é€šå¸¸å‘ç”Ÿåœ¨ç‰¹å®šçš„ä¸šåŠ¡æµç¨‹èŠ‚ç‚¹ï¼ˆä¾‹å¦‚ï¼Œä¸€ä¸ªä¸»è¦æµ‹è¯•é˜¶æ®µå®Œæˆã€ç”¨æˆ·è¯·æ±‚ä¿å­˜ã€æµ‹è¯•æ‰¹æ¬¡ç»“æŸæ—¶ï¼‰ï¼Œè€Œä¸æ˜¯åœ¨å¾®å°çš„çŠ¶æ€å˜åŒ–åç«‹å³è¿›è¡Œã€‚`ChannelTestInstance` çš„æ›´æ–°ä¸»è¦åœ¨å†…å­˜ä¸­è¿›è¡Œï¼Œå…¶æŒä¹…åŒ–æ˜¯ç”±ä¸šåŠ¡æµç¨‹å†³å®šçš„æŒ‰éœ€æ“ä½œã€‚**
    *   åº”ç”¨é…ç½®ç®¡ç†å°†ç”±ä¸“é—¨çš„ `AppSettingsService` å¤„ç†ï¼Œä¸é€šç”¨çš„ä¸šåŠ¡æ•°æ®æŒä¹…åŒ–åˆ†ç¦»ã€‚
*   **å®æ–½æè¿° (Implementation Description)**:
    1.  åˆ›å»º `src/services/infrastructure/persistence/mod.rs` å’Œ `persistence_service.rs`ã€‚
    2.  å®šä¹‰ `IPersistenceService` trait (å‚è€ƒæ¶æ„æ–‡æ¡£ 4.3.2 èŠ‚)ã€‚
        ```rust
        // src/services/infrastructure/persistence/persistence_service.rs
        use serde::{Serialize, de::DeserializeOwned};
        use crate::models::AppError; // ç»Ÿä¸€é”™è¯¯ç±»å‹
        use std::path::PathBuf;
        use async_trait::async_trait;

        #[async_trait]
        pub trait IPersistenceService: Send + Sync {
            async fn save_document<T: Serialize + Send + Sync + 'static>(
                &self, collection_name: &str, document_id: &str, document: &T
            ) -> Result<(), AppError>;

            async fn load_document<T: DeserializeOwned + Send + Sync + 'static>(
                &self, collection_name: &str, document_id: &str
            ) -> Result<Option<T>, AppError>;
            
            async fn load_all_documents_in_collection<T: DeserializeOwned + Send + Sync + 'static>(
                &self, collection_name: &str
            ) -> Result<Vec<T>, AppError>;

            async fn delete_document(
                &self, collection_name: &str, document_id: &str
            ) -> Result<(), AppError>;

            async fn document_exists(
                &self, collection_name: &str, document_id: &str
            ) -> Result<bool, AppError>;
        }
        ```
    3.  åˆ›å»º `MockPersistenceService` ç»“æ„ä½“å¹¶å®ç° `IPersistenceService` traitã€‚
        ```rust
        // In a new file: src/services/infrastructure/persistence/mock_persistence_service.rs
        use super::persistence_service::IPersistenceService;
        use crate::models::AppError;
        use async_trait::async_trait;
        use serde::{Serialize, de::DeserializeOwned};
        use std::collections::HashMap;
        use std::sync::Arc;
        use tokio::sync::Mutex;

        pub struct MockPersistenceService {
            // Mock in-memory store for documents
            documents: Arc<Mutex<HashMap<String, HashMap<String, String>>>>,
        }

        impl MockPersistenceService {
            pub fn new() -> Self {
                Self {
                    documents: Arc::new(Mutex::new(HashMap::new())),
                }
            }
        }

        #[async_trait]
        impl IPersistenceService for MockPersistenceService {
            async fn save_document<T: Serialize + Send + Sync + 'static>(
                &self, collection_name: &str, document_id: &str, document: &T
            ) -> Result<(), AppError> {
                println!("[MockPersistence] Saving doc '{}' in collection '{}'", document_id, collection_name);
                let mut collections = self.documents.lock().await;
                let collection = collections.entry(collection_name.to_string()).or_insert_with(HashMap::new);
                collection.insert(document_id.to_string(), serde_json::to_string(document).unwrap_or_default());
                Ok(())
            }

            async fn load_document<T: DeserializeOwned + Send + Sync + 'static>(
                &self, collection_name: &str, document_id: &str
            ) -> Result<Option<T>, AppError> {
                println!("[MockPersistence] Loading doc '{}' from collection '{}'", document_id, collection_name);
                let collections = self.documents.lock().await;
                if let Some(collection) = collections.get(collection_name) {
                    if let Some(doc_str) = collection.get(document_id) {
                        return Ok(serde_json::from_str(doc_str).ok());
                    }
                }
                Ok(None)
            }
            
            async fn load_all_documents_in_collection<T: DeserializeOwned + Send + Sync + 'static>(
                &self, collection_name: &str
            ) -> Result<Vec<T>, AppError> {
                println!("[MockPersistence] Loading all docs from collection '{}'", collection_name);
                let collections = self.documents.lock().await;
                let mut result_vec = Vec::new();
                if let Some(collection) = collections.get(collection_name) {
                    for doc_str in collection.values() {
                        if let Ok(doc) = serde_json::from_str(doc_str) {
                            result_vec.push(doc);
                        }
                    }
                }
                Ok(result_vec)
            }

            async fn delete_document(
                &self, collection_name: &str, document_id: &str
            ) -> Result<(), AppError> {
                println!("[MockPersistence] Deleting doc '{}' from collection '{}'", document_id, collection_name);
                 let mut collections = self.documents.lock().await;
                if let Some(collection) = collections.get_mut(collection_name) {
                    collection.remove(document_id);
                }
                Ok(())
            }

            async fn document_exists(
                &self, collection_name: &str, document_id: &str
            ) -> Result<bool, AppError> {
                 let collections = self.documents.lock().await;
                Ok(collections.get(collection_name).map_or(false, |c| c.contains_key(document_id)))
            }
        }
        ```
    4.  åˆ›å»º `SqliteOrmPersistenceService` ç»“æ„ä½“éª¨æ¶ã€‚
        ```rust
        // In a new file: src/services/infrastructure/persistence/sqlite_orm_persistence_service.rs
        use super::persistence_service::IPersistenceService;
        use crate::models::AppError;
        use async_trait::async_trait;
        use serde::{Serialize, de::DeserializeOwned};
        // Placeholder for actual DB connection (e.g., from SeaORM or Diesel)
        // use sea_orm::DatabaseConnection; 

        pub struct SqliteOrmPersistenceService {
            // db_conn: DatabaseConnection, // Example: SeaORM connection pool
            db_path: String, // For now, just the path
        }

        impl SqliteOrmPersistenceService {
            pub async fn new(db_file_path: &str) -> Result<Self, AppError> {
                // TODO: Initialize DB connection here in a later step
                // For now, just store the path
                Ok(Self { db_path: db_file_path.to_string() })
            }
        }
        
        #[async_trait]
        impl IPersistenceService for SqliteOrmPersistenceService {
            async fn save_document<T: Serialize + Send + Sync + 'static>(
                &self, collection_name: &str, document_id: &str, document: &T
            ) -> Result<(), AppError> {
                // TODO: Implement using ORM
                println!("[SqliteOrmPersistence] (TODO) Saving doc '{}' in collection '{}' to DB '{}'", document_id, collection_name, self.db_path);
                Err(AppError::InternalServiceError("Not implemented".to_string()))
            }

            async fn load_document<T: DeserializeOwned + Send + Sync + 'static>(
                &self, collection_name: &str, document_id: &str
            ) -> Result<Option<T>, AppError> {
                // TODO: Implement using ORM
                println!("[SqliteOrmPersistence] (TODO) Loading doc '{}' from collection '{}' from DB '{}'", document_id, collection_name, self.db_path);
                Err(AppError::InternalServiceError("Not implemented".to_string()))
            }
            
            async fn load_all_documents_in_collection<T: DeserializeOwned + Send + Sync + 'static>(
                &self, collection_name: &str
            ) -> Result<Vec<T>, AppError> {
                // TODO: Implement using ORM
                println!("[SqliteOrmPersistence] (TODO) Loading all docs from collection '{}' from DB '{}'", collection_name, self.db_path);
                Err(AppError::InternalServiceError("Not implemented".to_string()))
            }

            async fn delete_document(
                &self, collection_name: &str, document_id: &str
            ) -> Result<(), AppError> {
                // TODO: Implement using ORM
                println!("[SqliteOrmPersistence] (TODO) Deleting doc '{}' from collection '{}' from DB '{}'", document_id, collection_name, self.db_path);
                Err(AppError::InternalServiceError("Not implemented".to_string()))
            }

            async fn document_exists(
                &self, collection_name: &str, document_id: &str
            ) -> Result<bool, AppError> {
                // TODO: Implement using ORM
                println!("[SqliteOrmPersistence] (TODO) Checking existence of doc '{}' in collection '{}' in DB '{}'", document_id, collection_name, self.db_path);
                Err(AppError::InternalServiceError("Not implemented".to_string()))
            }

            // App config methods will use file system, not ORM/DB directly for this service example
            async fn save_app_config<T: Serialize + Send + Sync>(
                &self, config_name: &str, config_data: &T
            ) -> Result<(), AppError> {
                // This specific implementation uses JSON files for app config
                // Real implementation would use tauri::api::path::app_config_dir()
                let path = format!("{}.json", config_name); 
                println!("[SqliteOrmPersistence/File] Saving config '{}' to file '{}'", config_name, path);
                let contents = serde_json::to_string_pretty(config_data)
                    .map_err(|e| AppError::PersistenceFileError(format!("Serialization error: {}", e)))?;
                tokio::fs::write(&path, contents).await
                    .map_err(|e| AppError::PersistenceFileError(format!("File write error: {}", e)))?;
                Ok(())
            }

            async fn load_app_config<T: DeserializeOwned + Send + Sync>(
                &self, config_name: &str
            ) -> Result<Option<T>, AppError> {
                let path = format!("{}.json", config_name);
                println!("[SqliteOrmPersistence/File] Loading config '{}' from file '{}'", config_name, path);
                match tokio::fs::read_to_string(&path).await {
                    Ok(contents) => {
                        let data: T = serde_json::from_str(&contents)
                            .map_err(|e| AppError::PersistenceFileError(format!("Deserialization error: {}", e)))?;
                        Ok(Some(data))
                    },
                    Err(e) if e.kind() == std::io::ErrorKind::NotFound => Ok(None),
                    Err(e) => Err(AppError::PersistenceFileError(format!("File read error: {}", e))),
                }
            }
        }
        ```
    5.  åœ¨ `src/services/infrastructure/persistence/mod.rs` ä¸­å¯¼å‡ºã€‚
*   **å¦‚ä½•æµ‹è¯• (How to Test)**:
    *   å•å…ƒæµ‹è¯• `MockPersistenceService` çš„åŸºæœ¬è¡Œä¸º (å­˜å–æ˜¯å¦ä¸€è‡´)ã€‚
    *   `SqliteOrmPersistenceService` çš„æ•°æ®åº“æ–¹æ³•æµ‹è¯•å°†åœ¨ORMé›†æˆåè¿›è¡Œã€‚
    *   ç¼–è¯‘é€šè¿‡ï¼Œ`clippy`æ— è­¦å‘Šã€‚

### (å®Œæˆ)æ­¥éª¤ 1.5: å®ç° `IChannelStateManager` æ¥å£åŠæ ¸å¿ƒé€»è¾‘ (é¢†åŸŸå±‚)

*   **åŸå›  (Reason)**:
    *   `ChannelStateManager` æ˜¯æ•´ä¸ªæµ‹è¯•çŠ¶æ€ç®¡ç†çš„æ ¸å¿ƒï¼Œå°è£…äº†æœ€å¤æ‚çš„ä¸šåŠ¡è§„åˆ™ã€‚
    *   å®ƒçš„æ­£ç¡®å®ç°æ˜¯ä¿è¯æµ‹è¯•ç»“æœå‡†ç¡®æ€§å’Œæµç¨‹æ­£ç¡®æ€§çš„å…³é”®ã€‚
*   **æœŸæœ›æ•ˆæœ (Expected Outcome)**:
    *   åœ¨ `src/services/domain/channel_state_manager.rs` ä¸­å®šä¹‰ `IChannelStateManager` traitã€‚
    *   å®ç° `ChannelStateManager` structï¼ŒåŒ…å«æ¶æ„æ–‡æ¡£ä¸­æè¿°çš„æ ¸å¿ƒæ–¹æ³•ï¼š
        *   `initialize_channel_test_instance`
        *   `apply_raw_outcome` (è¿™æ˜¯æœ€æ ¸å¿ƒçš„ï¼Œå†…éƒ¨åŒ…å«å¤æ‚çš„ `EvaluateOverallStatus` é€»è¾‘)
        *   `mark_as_skipped`
        *   `prepare_for_wiring_confirmation`
        *   `begin_hard_point_test`
        *   `begin_manual_sub_test`
        *   `reset_for_retest`
    *   æ­¤å®ç°åº”ä¸¥æ ¼éµå®ˆä¸è¿›è¡ŒI/Oæ“ä½œã€ä¸ç›´æ¥å‘å¸ƒäº‹ä»¶çš„åŸåˆ™ã€‚
    *   çŠ¶æ€è½¬æ¢é€»è¾‘æ¸…æ™°ï¼Œæ˜“äºç†è§£å’Œä¿®æ”¹ã€‚
*   **å®æ–½æè¿° (Implementation Description)**:
    1.  åˆ›å»º `src/services/domain/mod.rs` å’Œ `src/services/domain/channel_state_manager.rs`ã€‚
    2.  å®šä¹‰ `IChannelStateManager` traitã€‚
    3.  å®ç° `ChannelStateManager` structã€‚æ­¤æœåŠ¡é€šå¸¸æ˜¯æ— çŠ¶æ€çš„ï¼Œæˆ–è€…åªä¾èµ–é…ç½®ä¿¡æ¯ï¼Œä¸æŒæœ‰å¯å˜è¿è¡Œæ—¶æ•°æ®ã€‚
    4.  **`initialize_channel_test_instance`**:
        *   æ¥æ”¶ `ChannelPointDefinition` å’Œ `batch_id`ã€‚
        *   åˆ›å»ºä¸€ä¸ªæ–°çš„ `ChannelTestInstance`ã€‚
        *   æ ¹æ® `definition.module_type` å’Œå…¶ä»–é…ç½®ï¼ˆå¦‚æŠ¥è­¦ç‚¹ä½æ˜¯å¦é…ç½®ï¼‰ï¼Œåˆå§‹åŒ– `instance.sub_test_results` ä¸­å„é¡¹ `SubTestItem` çš„çŠ¶æ€ä¸º `NotTested` æˆ– `NotApplicable`ã€‚
        *   è®¾ç½® `instance.overall_status = OverallTestStatus::NotTested`ã€‚
    5.  **`apply_raw_outcome`**:
        *   æ¥æ”¶ `&mut ChannelTestInstance` å’Œ `RawTestOutcome`ã€‚
        *   æ ¹æ® `outcome.sub_test_item` æ›´æ–° `instance.sub_test_results` ä¸­å¯¹åº”æ¡ç›®çš„çŠ¶æ€ã€æ—¶é—´æˆ³ã€è¯¦ç»†ä¿¡æ¯ç­‰ã€‚
        *   **è°ƒç”¨å†…éƒ¨ç§æœ‰æ–¹æ³• `evaluate_overall_status(&mut instance)`**ã€‚
    6.  **`evaluate_overall_status` (ç§æœ‰æ–¹æ³•)**:
        *   è¿™æ˜¯çŠ¶æ€æœºæ ¸å¿ƒã€‚éå† `instance.sub_test_results`ã€‚
        *   æ ¹æ®å„é¡¹å­æµ‹è¯•çš„çŠ¶æ€ï¼Œä»¥åŠé¢„å®šä¹‰çš„è§„åˆ™ï¼ˆä¾‹å¦‚ï¼šæ‰€æœ‰å¿…éœ€é¡¹ `Passed` åˆ™æ•´ä½“ `TestCompletedPassed`ï¼›ä»»ä½•å…³é”®é¡¹ `Failed` åˆ™æ•´ä½“ `TestCompletedFailed`ï¼›ç¡¬ç‚¹æµ‹è¯•å®Œæˆä½†æœ‰æ‰‹åŠ¨é¡¹æœªæµ‹åˆ™å¯èƒ½æ˜¯ `HardPointTestCompleted` ç­‰ï¼‰ï¼Œæ›´æ–° `instance.overall_status`ã€‚
        *   æ›´æ–° `instance.final_test_time`, `instance.total_test_duration_ms` (å¦‚æœæµ‹è¯•å®Œæˆ)ã€‚
        *   æ„å»º `instance.error_message` (å¦‚æœå¤±è´¥)ã€‚
    7.  å®ç°å…¶ä»–æ–¹æ³• (`mark_as_skipped` ç­‰)ï¼Œå®ƒä»¬é€šå¸¸ä¼šè®¾ç½®ç‰¹å®šçš„å­æµ‹è¯•é¡¹çŠ¶æ€æˆ–æ•´ä½“çŠ¶æ€ï¼Œå¹¶è°ƒç”¨ `evaluate_overall_status`ã€‚
*   **å¦‚ä½•æµ‹è¯• (How to Test)**:
    *   **å•å…ƒæµ‹è¯• (éå¸¸é‡è¦ä¸”è¯¦ç»†)**:
        *   **åˆå§‹åŒ–æµ‹è¯•**:
            *   é’ˆå¯¹ä¸åŒ `ModuleType` (AI, DI, AO, DOç­‰) çš„ `ChannelPointDefinition`ï¼Œæµ‹è¯• `initialize_channel_test_instance` åï¼Œ`ChannelTestInstance` çš„ `overall_status` å’Œ `sub_test_results` æ˜¯å¦ç¬¦åˆé¢„æœŸï¼ˆå“ªäº›æ˜¯ `NotTested`ï¼Œå“ªäº›æ˜¯ `NotApplicable`ï¼‰ã€‚
        *   **çŠ¶æ€è½¬æ¢æµ‹è¯• (apply_raw_outcome)**:
            *   ä¸ºæ¯ä¸ª `SubTestItem` å’Œä¸åŒçš„ `RawTestOutcome` (æˆåŠŸ/å¤±è´¥) æ„é€ æµ‹è¯•åœºæ™¯ã€‚
            *   ä¾‹å¦‚ï¼š
                *   åˆå§‹åŒ–çš„AIç‚¹å®ä¾‹ -> åº”ç”¨æˆåŠŸçš„ `HardPoint` outcome -> éªŒè¯ `sub_test_results[HardPoint].status` ä¸º `Passed` åŠ `overall_status` çš„å˜åŒ–ã€‚
                *   AIç‚¹å®ä¾‹ï¼Œ`HardPoint` å·² `Passed` -> åº”ç”¨æˆåŠŸçš„ `LowAlarm` outcome -> éªŒè¯çŠ¶æ€ã€‚
                *   AIç‚¹å®ä¾‹ -> åº”ç”¨å¤±è´¥çš„ `HardPoint` outcome -> éªŒè¯ `sub_test_results[HardPoint].status` ä¸º `Failed` åŠ `overall_status` ä¸º `TestCompletedFailed`ã€‚
            *   è¦†ç›–æ‰€æœ‰å®šä¹‰çš„ `SubTestItem`ã€‚
            *   æµ‹è¯•ç»„åˆåœºæ™¯ï¼šå¤šä¸ªå­æµ‹è¯•æˆåŠŸåæ•´ä½“é€šè¿‡ï¼›ä¸€ä¸ªå…³é”®å­æµ‹è¯•å¤±è´¥å¯¼è‡´æ•´ä½“å¤±è´¥ã€‚
        *   **`mark_as_skipped` æµ‹è¯•**: éªŒè¯è°ƒç”¨å `overall_status` ä¸º `Skipped`ã€‚
        *   **`reset_for_retest` æµ‹è¯•**: éªŒè¯è°ƒç”¨åçŠ¶æ€æ˜¯å¦æ¢å¤åˆ°é€‚åˆé‡æµ‹çš„åˆå§‹çŠ¶æ€ã€‚
        *   **è¾¹ç•Œæ¡ä»¶å’Œé”™è¯¯æ¡ä»¶**: ä¾‹å¦‚ï¼Œä¼ å…¥æ— æ•ˆçš„ `RawTestOutcome` (ä¸åŒ¹é…çš„ `instance_id` -- è™½ç„¶è¿™é‡Œæ˜¯ä¼  `&mut instance`ï¼Œä½†é€»è¾‘ä¸Šè¦è€ƒè™‘)ã€‚

---

## Phase 2: åç«¯æ ¸å¿ƒä¸šåŠ¡æµç¨‹å®ç° - æµ‹è¯•æ‰§è¡Œä¸åˆæ­¥åº”ç”¨æœåŠ¡

**ç›®æ ‡ï¼š** å®ç°æ ¸å¿ƒçš„æµ‹è¯•æ‰§è¡Œé€»è¾‘ï¼ŒåŒ…æ‹¬ `SpecificTestStepExecutor` å’Œ `TestExecutionEngine`ï¼Œå¹¶å¼€å§‹æ­å»ºéƒ¨åˆ†åº”ç”¨å±‚æœåŠ¡ä»¥ä¸²è”æµç¨‹ï¼Œä¸ºåç»­ä¸å‰ç«¯é›†æˆåšå‡†å¤‡ã€‚

### (å®Œæˆ)æ­¥éª¤ 2.1: å®ç° `ISpecificTestStepExecutor` æ¥å£åŠè‹¥å¹²å…·ä½“æ‰§è¡Œå™¨ (é¢†åŸŸå±‚)

*   **åŸå›  (Reason)**:
    *   `SpecificTestStepExecutor` æ˜¯å®é™…æ‰§è¡Œä¸PLCäº¤äº’å¹¶è·å–åŸå§‹æµ‹è¯•ç»“æœçš„å•å…ƒã€‚
    *   å®ç°å…·ä½“çš„æ‰§è¡Œå™¨æ˜¯ `TestExecutionEngine` èƒ½å¤Ÿå·¥ä½œçš„å…ˆå†³æ¡ä»¶ã€‚
*   **æœŸæœ›æ•ˆæœ (Expected Outcome)**:
    *   åœ¨ `src/services/domain/test_executors/` ç›®å½•ä¸‹åˆ›å»ºæ¨¡å—ã€‚
    *   å®šä¹‰ `ISpecificTestStepExecutor` traitã€‚
    *   è‡³å°‘å®ç°ä»¥ä¸‹å‡ ä¸ªå…³é”®çš„æ‰§è¡Œå™¨ (ä»¥AIç‚¹ä¸ºä¾‹ï¼Œå…¶ä»–ç±»å‹ç±»ä¼¼)ï¼š
        *   `AIHardPointPercentExecutor`: æ‰§è¡ŒAIç‚¹ç¡¬æ¥çº¿æµ‹è¯•ä¸­æŸä¸ªç™¾åˆ†æ¯”çš„è®¾å®šä¸è¯»å–ï¼ˆå¦‚æ¨¡æ‹Ÿè¾“å‡º25%å€¼ï¼Œè¯»å–AIåé¦ˆï¼‰ã€‚
        *   `AIAlarmTestExecutor`: æ‰§è¡ŒAIç‚¹æŸä¸ªæŠ¥è­¦é¡¹çš„æµ‹è¯•ï¼ˆå¦‚è®¾ç½®é«˜æŠ¥è§¦å‘æ¡ä»¶ï¼ŒéªŒè¯æŠ¥è­¦æ˜¯å¦äº§ç”Ÿï¼‰ã€‚
        *   `DIStateReadExecutor`: è¯»å–DIç‚¹çš„çŠ¶æ€ã€‚
        *   `DOSetStateExecutor`: è®¾ç½®DOç‚¹çš„çŠ¶æ€å¹¶éªŒè¯å›è¯»ï¼ˆå¦‚æœç¡¬ä»¶æ”¯æŒï¼‰ã€‚
    *   æ¯ä¸ªæ‰§è¡Œå™¨åº”èƒ½æ¥æ”¶ `ChannelTestInstance` (åªè¯»), `ChannelPointDefinition` (åªè¯»), ä»¥åŠ `IPlcCommunicationService` çš„å®ä¾‹ (æµ‹è¯•å°æ¶å’Œè¢«æµ‹ç³»ç»Ÿ)ã€‚
    *   æ¯ä¸ªæ‰§è¡Œå™¨æ‰§è¡Œå®Œæ¯•åè¿”å›ä¸€ä¸ª `RawTestOutcome` å¯¹è±¡ï¼ŒåŒ…å«æ‰§è¡Œçš„ `SubTestItem`ã€æˆåŠŸä¸å¦ã€åŸå§‹è¯»å€¼ã€æ¶ˆæ¯ç­‰ã€‚
*   **å®æ–½æè¿° (Implementation Description)**:
    1.  åˆ›å»º `src/services/domain/test_executors/mod.rs` ä»¥åŠå„ä¸ªæ‰§è¡Œå™¨çš„ `ai_hardpoint_executor.rs`, `ai_alarm_executor.rs` ç­‰æ–‡ä»¶ã€‚
    2.  åœ¨ `mod.rs` æˆ–ä¸€ä¸ªå…±äº«æ–‡ä»¶ä¸­å®šä¹‰ `ISpecificTestStepExecutor` traitã€‚
    3.  **`AIHardPointPercentExecutor` å®ç°**: (ç¤ºä¾‹é€»è¾‘)
        *   æ„é€ å‡½æ•°å¯èƒ½æ¥æ”¶ç›®æ ‡ç™¾åˆ†æ¯” (e.g., 0.25, 0.50)ã€‚
        *   `item_type()` è¿”å› `SubTestItem::HardPoint` (å¯èƒ½éœ€è¦æ›´ç»†åˆ†çš„ `SubTestItem` æ¥åŒºåˆ†ç™¾åˆ†æ¯”ç‚¹ï¼Œæˆ–è€… `RawTestOutcome` ä¸­åŒ…å«é¢å¤–ä¿¡æ¯)ã€‚
        *   `execute()` æ–¹æ³•:
            *   ä» `ChannelPointDefinition` è·å–é‡ç¨‹ (`range_lower_limit`, `range_upper_limit`) å’Œæµ‹è¯•å°æ¶è¾“å‡ºåœ°å€ (`test_rig_plc_address`) ä»¥åŠè¢«æµ‹AIç‚¹è¯»å–åœ°å€ (`plc_communication_address`)ã€‚
            *   è®¡ç®—ç›®æ ‡ç™¾åˆ†æ¯”å¯¹åº”çš„å·¥ç¨‹å•ä½è®¾å®šå€¼å’Œï¼ˆå¯èƒ½çš„ï¼‰åŸå§‹è®¾å®šå€¼ã€‚
            *   è°ƒç”¨ `plc_service_test_rig.write_f32(test_rig_plc_address, calculated_set_value_raw)`ã€‚
            *   ç­‰å¾…ä¸€å°æ®µæ—¶é—´ (å¯é…ç½®) ä»¥ç¡®ä¿ä¿¡å·ç¨³å®šã€‚
            *   è°ƒç”¨ `plc_service_target.read_f32(plc_communication_address)` è·å–å®é™…è¯»å€¼ã€‚
            *   å°†å®é™…è¯»å€¼è½¬æ¢ä¸ºå·¥ç¨‹å•ä½ã€‚
            *   æ¯”è¾ƒå®é™…è¯»å€¼ä¸æœŸæœ›è¯»å€¼ (è€ƒè™‘å®¹å·®èŒƒå›´)ã€‚
            *   æ„é€ å¹¶è¿”å› `RawTestOutcome`ï¼ŒåŒ…å« `success` çŠ¶æ€ï¼Œè®¾å®šçš„ç™¾åˆ†æ¯”ï¼Œè®¾å®šå€¼ï¼Œå®é™…è¯»å€¼ï¼ŒåŸå§‹è¯»å€¼ç­‰ä¿¡æ¯ (åˆ©ç”¨ `RawTestOutcome::analog_reading_point` å­—æ®µ)ã€‚
    4.  **`AIAlarmTestExecutor` å®ç°**: (ç¤ºä¾‹é€»è¾‘)
        *   æ„é€ å‡½æ•°æ¥æ”¶è¦æµ‹è¯•çš„æŠ¥è­¦ç±»å‹ (e.g., `SubTestItem::HighAlarm`)ã€‚
        *   `item_type()` è¿”å›å¯¹åº”çš„ `SubTestItem`ã€‚
        *   `execute()` æ–¹æ³•:
            *   ä» `ChannelPointDefinition` è·å–æŠ¥è­¦è®¾å®šå€¼å†™å…¥åœ°å€ (e.g., `sh_set_point_address`)ã€æŠ¥è­¦çŠ¶æ€åé¦ˆåœ°å€ (e.g., `sh_feedback_address`) å’ŒæŠ¥è­¦è®¾å®šå€¼ (e.g., `sh_set_value`)ã€‚
            *   è°ƒç”¨ `plc_service_target.write_f32(sh_set_point_address, alarm_trigger_value)` (å†™å…¥ä¸€ä¸ªèƒ½è§¦å‘æŠ¥è­¦çš„å€¼)ã€‚
            *   ç­‰å¾…ã€‚
            *   è°ƒç”¨ `plc_service_target.read_bool(sh_feedback_address)` éªŒè¯æŠ¥è­¦æ˜¯å¦æœ‰æ•ˆã€‚
            *   (é‡è¦) æµ‹è¯•å®Œæ¯•åï¼Œå¯èƒ½éœ€è¦å°†è®¾å®šå€¼æ¢å¤åŸçŠ¶æˆ–è®¾å®šä¸€ä¸ªå®‰å…¨å€¼ã€‚
            *   æ„é€ å¹¶è¿”å› `RawTestOutcome`ã€‚
    5.  å¯¹DI/DOç­‰å…¶ä»–ç±»å‹çš„æ‰§è¡Œå™¨è¿›è¡Œç±»ä¼¼å®ç°ã€‚
    6.  æ‰€æœ‰ä¸PLCçš„äº¤äº’éƒ½åº”é€šè¿‡ä¼ å…¥çš„ `IPlcCommunicationService` å®ä¾‹è¿›è¡Œã€‚
*   **å¦‚ä½•æµ‹è¯• (How to Test)**:
    *   **å•å…ƒæµ‹è¯• (å¯¹æ¯ä¸ªå…·ä½“æ‰§è¡Œå™¨)**:
        *   **Mocking `IPlcCommunicationService`**: è¿™æ˜¯æµ‹è¯•çš„å…³é”®ã€‚ä¸º `MockPlcCommunicationService` è®¾ç½®é¢„æœŸçš„è¯»å–è¿”å›å€¼ï¼Œå¹¶éªŒè¯å†™å…¥æ“ä½œæ˜¯å¦ç¬¦åˆé¢„æœŸ (åœ°å€ã€å€¼)ã€‚
        *   **æˆåŠŸåœºæ™¯**: æ¨¡æ‹ŸPLCè¿”å›é¢„æœŸå€¼ï¼ŒéªŒè¯æ‰§è¡Œå™¨æ˜¯å¦è¿”å› `success: true` çš„ `RawTestOutcome`ï¼Œä¸”outcomeä¸­çš„æ•°æ®æ­£ç¡®ã€‚
        *   **å¤±è´¥åœºæ™¯**:
            *   æ¨¡æ‹ŸPLCè¿”å›æ„å¤–å€¼ (è¶…å‡ºå®¹å·®èŒƒå›´)ï¼ŒéªŒè¯ `success: false` åŠé”™è¯¯ä¿¡æ¯ã€‚
            *   æ¨¡æ‹ŸPLCé€šä¿¡é”™è¯¯ (e.g., `read_f32` è¿”å› `Err(AppError::PlcCommunicationError)`)ï¼ŒéªŒè¯æ‰§è¡Œå™¨æ˜¯å¦èƒ½æ­£ç¡®å¤„ç†å¹¶å‘ä¸Šä¼ æ’­é”™è¯¯ (æˆ–åŒ…è£…ä¸ºç‰¹å®šçš„ `RawTestOutcome` å¤±è´¥)ã€‚
        *   **è¾¹ç•Œæ¡ä»¶**: æµ‹è¯•é‡ç¨‹çš„0%, 100%ç‚¹ï¼ŒæŠ¥è­¦çš„è§¦å‘ä¸è§£é™¤ç­‰ã€‚

### (å®Œæˆ)æ­¥éª¤ 2.2: å®ç° `ITestExecutionEngine` æ¥å£åŠå¹¶å‘æ§åˆ¶é€»è¾‘ (é¢†åŸŸå±‚)

*   **åŸå›  (Reason)**:
    *   `TestExecutionEngine` è´Ÿè´£ç®¡ç†å’Œå¹¶å‘æ‰§è¡Œç”±å¤šä¸ª `SpecificTestStepExecutor` æ„æˆçš„å®Œæ•´æµ‹è¯•åºåˆ—ã€‚
    *   å…¶æ­£ç¡®å®ç°æ˜¯ä¿è¯æµ‹è¯•é«˜æ•ˆã€æœ‰åºè¿›è¡Œçš„å…³é”®ã€‚
*   **æœŸæœ›æ•ˆæœ (Expected Outcome)**:
    *   åœ¨ `src/services/domain/test_execution_engine.rs` ä¸­å®šä¹‰ `ITestExecutionEngine` traitã€‚
    *   å®ç° `TestExecutionEngine` structã€‚
    *   `submit_test_instance` æ–¹æ³•åº”èƒ½æ¥æ”¶ `ChannelTestInstance` å’Œ `ChannelPointDefinition`ï¼Œå¹¶æ ¹æ®å…¶ç±»å‹å†³å®šéœ€è¦æ‰§è¡Œçš„ `SpecificTestStepExecutor` åºåˆ—ã€‚
    *   ä½¿ç”¨ `tokio::spawn` æ¥å¼‚æ­¥æ‰§è¡Œæ¯ä¸ªæµ‹è¯•å®ä¾‹çš„æµ‹è¯•åºåˆ—ã€‚
    *   ä½¿ç”¨ `tokio::sync::Semaphore` æ¥æ§åˆ¶æœ€å¤§å¹¶å‘æµ‹è¯•å®ä¾‹æ•°ã€‚
    *   æ¯ä¸ªæ‰§è¡Œçš„ `SpecificTestStepExecutor` è¿”å›çš„ `RawTestOutcome` é€šè¿‡ `outcome_sender` (MPSC channel) å‘é€å‡ºå»ã€‚
    *   åˆæ­¥å®ç° `pause`, `resume`, `stop` åŠŸèƒ½ (å¯èƒ½é€šè¿‡ `CancellationToken` æˆ– `Arc<Mutex<bool>>` æ ‡å¿—ä½ï¼Œéœ€è¦ä»”ç»†è®¾è®¡)ã€‚
*   **å®æ–½æè¿° (Implementation Description)**:
    1.  åˆ›å»º `src/services/domain/test_execution_engine.rs`ã€‚
    2.  å®šä¹‰ `ITestExecutionEngine` traitã€‚
    3.  å®ç° `TestExecutionEngine` struct:
        *   åŒ…å«å­—æ®µ: `max_concurrent_tests: Arc<Semaphore>`, `plc_service_test_rig: Arc<dyn IPlcCommunicationService>`, `plc_service_target: Arc<dyn IPlcCommunicationService>` (è¿™äº›åº”åœ¨åˆ›å»ºå¼•æ“æ—¶æ³¨å…¥)ã€‚
        *   (å¯é€‰) `active_tasks: Arc<Mutex<HashMap<String, CancellationToken>>>` ç”¨äºç®¡ç†å¯å–æ¶ˆçš„ä»»åŠ¡ã€‚
    4.  **`submit_test_instance` å®ç°**: (æ ¸å¿ƒé€»è¾‘)
        *   è·å–ä¸€ä¸ªä¿¡å·é‡è®¸å¯: `let permit = self.max_concurrent_tests.clone().acquire_owned().await.unwrap();`
        *   `tokio::spawn` ä¸€ä¸ªæ–°çš„å¼‚æ­¥ä»»åŠ¡ï¼Œæ­¤ä»»åŠ¡è´Ÿè´£æ‰§è¡Œè¯¥ `instance` çš„å®Œæ•´æµ‹è¯•åºåˆ—ã€‚åœ¨ä»»åŠ¡ç»“æŸæ—¶ï¼Œ`permit` ä¼šè¢«è‡ªåŠ¨é‡Šæ”¾ã€‚
        *   åœ¨spawnçš„å¼‚æ­¥å—å†…ï¼š
            *   æ ¹æ® `definition.module_type` å’Œé¢„å®šä¹‰çš„æµ‹è¯•ç­–ç•¥ï¼Œæ„å»ºä¸€ä¸ª `Vec<Arc<dyn ISpecificTestStepExecutor>>` åºåˆ—ã€‚
                *   ä¾‹å¦‚ï¼ŒAIç‚¹å¯èƒ½åŒ…å«ï¼šHardPoint 0%, 25%, 50%, 75%, 100%, LL Alarm, L Alarm, H Alarm, HH Alarm, Maintenance, Trend, Reportã€‚
                *   è¿™ä¸ªæ„å»ºé€»è¾‘å¯ä»¥å°è£…åœ¨ä¸€ä¸ªç§æœ‰è¾…åŠ©å‡½æ•° `fn determine_test_steps(definition: &ChannelPointDefinition) -> Vec<Arc<dyn ISpecificTestStepExecutor>>` ä¸­ï¼Œè¯¥å‡½æ•°ä¼šå®ä¾‹åŒ–å…·ä½“çš„æ‰§è¡Œå™¨ã€‚
            *   æŒ‰é¡ºåºï¼ˆæˆ–ç‰¹å®šé€»è¾‘ï¼‰è¿­ä»£æ‰§è¡Œ `steps` ä¸­çš„æ¯ä¸ª `executor`:
                *   `let outcome = executor.execute(&instance_clone, &definition_clone, self.plc_test_rig.clone(), self.plc_target.clone()).await;`
                *   é€šè¿‡ `outcome_sender.send(outcome).await` å‘é€ç»“æœã€‚
                *   å¦‚æœæŸä¸ªæ­¥éª¤å¤±è´¥ä¸”éœ€è¦ä¸­æ­¢åç»­æ­¥éª¤ (e.g., ç¡¬ç‚¹æµ‹è¯•åŸºç¡€éƒ¨åˆ†å¤±è´¥)ï¼Œåˆ™æå‰ `break`ã€‚
                *   å¤„ç†æš‚åœ/åœæ­¢ä¿¡å· (æ£€æŸ¥ `CancellationToken` æˆ–å…±äº«æ ‡å¿—ä½)ã€‚
    5.  **å¹¶å‘æ§åˆ¶**: `Semaphore` åœ¨ `submit_test_instance` ä¸­è·å–è®¸å¯ï¼Œåœ¨ `tokio::spawn` çš„ä»»åŠ¡ç»“æŸæ—¶è‡ªåŠ¨é‡Šæ”¾ã€‚
    6.  **ä»»åŠ¡æ§åˆ¶ (`pause`/`resume`/`stop`)**: è¿™éƒ¨åˆ†æ¯”è¾ƒå¤æ‚ã€‚
        *   **Stop**: å¯ä»¥ä½¿ç”¨ `tokio-util::sync::CancellationToken`ã€‚æ¯ä¸ªspawnçš„ä»»åŠ¡æŒæœ‰ä¸€ä¸ª `child_token`ï¼Œå¼•æ“æŒæœ‰ `parent_token`ã€‚åœæ­¢æ—¶å–æ¶ˆ `parent_token`ã€‚
        *   **Pause/Resume**: å¯èƒ½éœ€è¦æ›´å¤æ‚çš„æœºåˆ¶ï¼Œå¦‚æ¯ä¸ªæ‰§è¡Œå™¨åœ¨å…³é”®ç‚¹æ£€æŸ¥ä¸€ä¸ªå…±äº«çš„ `Arc<Mutex<PauseState>>`ã€‚æˆ–è€…ä½¿ç”¨ `tokio::sync::watch` channel æ¥å¹¿æ’­æš‚åœ/ç»§ç»­ä¿¡å·ã€‚
        *   åˆæ­¥å®ç°å¯ä»¥å…ˆä¾§é‡ `stop`ã€‚
*   **å¦‚ä½•æµ‹è¯• (How to Test)**:
    *   **å•å…ƒæµ‹è¯•/é›†æˆæµ‹è¯•**: (è¿™éƒ¨åˆ†æ›´åå‘é›†æˆæµ‹è¯•ï¼Œå› ä¸ºå®ƒåè°ƒå¤šä¸ªç»„ä»¶)
        *   **Mock `ISpecificTestStepExecutor`**: åˆ›å»ºå‡ ä¸ªMockæ‰§è¡Œå™¨ï¼Œå®ƒä»¬å¯ä»¥æ¨¡æ‹ŸæˆåŠŸã€å¤±è´¥ã€æˆ–é•¿æ—¶é—´è¿è¡Œï¼Œå¹¶è¿”å›é¢„è®¾çš„ `RawTestOutcome`ã€‚
        *   **Mock `IPlcCommunicationService`**: ä»ç„¶éœ€è¦ï¼Œå› ä¸ºæ‰§è¡Œå¼•æ“ä¼šå°†PLCæœåŠ¡ä¼ é€’ç»™æ‰§è¡Œå™¨ã€‚
        *   **æµ‹è¯•å¹¶å‘æ§åˆ¶**: æäº¤Nä¸ªä»»åŠ¡ï¼ˆN > max_concurrentï¼‰ï¼ŒéªŒè¯åŒæ—¶æ´»åŠ¨çš„ä»»åŠ¡æ•°ä¸è¶…è¿‡ `max_concurrent`ã€‚
        *   **æµ‹è¯•ç»“æœä¼ é€’**: éªŒè¯æ‰€æœ‰ `RawTestOutcome` éƒ½é€šè¿‡ `outcome_sender` æ­£ç¡®å‘é€å‡ºæ¥ï¼Œå¹¶ä¸”é¡ºåºåŸºæœ¬ç¬¦åˆé¢„æœŸ (å¯¹äºåŒä¸€å®ä¾‹å†…çš„æ­¥éª¤)ã€‚
        *   **æµ‹è¯•é”™è¯¯å¤„ç†**: å¦‚æœä¸€ä¸ª `executor.execute` è¿”å› `Err`, æˆ–è€… `outcome_sender.send` å¤±è´¥ï¼Œå¼•æ“åº”å¦‚ä½•å¤„ç†ï¼ˆè®°å½•æ—¥å¿—ï¼Œå¯èƒ½ä¸­æ­¢è¯¥å®ä¾‹çš„åç»­æ­¥éª¤ï¼‰ã€‚
        *   **æµ‹è¯• Stop åŠŸèƒ½**: æäº¤å¤šä¸ªä»»åŠ¡ï¼Œä¸­é€”è°ƒç”¨ `stop_instance_execution` (æˆ–å…¨å±€åœæ­¢)ï¼ŒéªŒè¯æ­£åœ¨è¿è¡Œå’Œç­‰å¾…çš„ä»»åŠ¡æ˜¯å¦èƒ½è¢«å–æ¶ˆï¼Œå¹¶ä¸” `outcome_sender` ä¸å†æ”¶åˆ°å®ƒä»¬çš„ç»“æœã€‚

### (å®Œæˆ)æ­¥éª¤ 2.3: å®ç° `ITestRecordService` æ¥å£åŠåŸºæœ¬å®ç° (é¢†åŸŸå±‚)

*   **åŸå›  (Reason)**:
    *   æµ‹è¯•è®°å½•çš„ä¿å­˜å’ŒæŸ¥è¯¢æ˜¯ç³»ç»Ÿçš„åŸºæœ¬éœ€æ±‚ã€‚
    *   `TestOrchestrationService` ç­‰ä¸Šå±‚æœåŠ¡ä¼šä¾èµ–æ­¤æœåŠ¡æ¥ç®¡ç†æµ‹è¯•æ•°æ®ã€‚
*   **æœŸæœ›æ•ˆæœ (Expected Outcome)**:
    *   åœ¨ `src/services/domain/test_record_service.rs` ä¸­å®šä¹‰ `ITestRecordService` trait (å‚è€ƒæ¶æ„æ–‡æ¡£ 4.2.5 èŠ‚)ã€‚
    *   å®ç° `TestRecordService` structï¼Œè¯¥ struct ä¾èµ– `Arc<dyn IPersistenceService>`ã€‚
    *   `save_test_batch_info`, `get_test_batch_info`, `save_channel_test_instance`, `get_channel_test_instances_for_batch` ç­‰æ ¸å¿ƒæ–¹æ³•èƒ½å¤Ÿé€šè¿‡è°ƒç”¨ `IPersistenceService` çš„æ–¹æ³•ï¼Œå°†æ•°æ®ï¼ˆé€»è¾‘ä¸Šï¼‰ä¿å­˜åˆ°/åŠ è½½è‡ªæŒä¹…åŒ–å­˜å‚¨ (å½“å‰æ˜¯Mockï¼Œåç»­æ˜¯DB)ã€‚
    *   **æ­¤æœåŠ¡ (`TestRecordService`) è‡ªèº«ä¸å†³å®šä½•æ—¶æŒä¹…åŒ– `ChannelTestInstance` çš„è¿è¡Œæ—¶çŠ¶æ€ã€‚å®ƒæä¾›æŒä¹…åŒ–èƒ½åŠ›ï¼Œä½†å®é™…çš„è°ƒç”¨æ—¶æœºç”±æ›´ä¸Šå±‚çš„æœåŠ¡ (ä¸»è¦æ˜¯ `TestOrchestrationService`) æ ¹æ®ä¸šåŠ¡æµç¨‹ä¸­çš„ç‰¹å®šèŠ‚ç‚¹ï¼ˆä¾‹å¦‚æµ‹è¯•é˜¶æ®µå®Œæˆã€ç”¨æˆ·è¯·æ±‚ä¿å­˜ã€æ‰¹æ¬¡ç»“æŸç­‰å…³é”®æ—¶é—´ç‚¹ï¼‰æ¥å†³å®šã€‚`ChannelTestInstance` çš„çŠ¶æ€ä¸»è¦åœ¨å†…å­˜ä¸­å®æ—¶æ›´æ–°å’Œç®¡ç†ï¼Œæ­¤æœåŠ¡è´Ÿè´£æŒ‰éœ€å°†è¿™äº›å†…å­˜ä¸­çš„çŠ¶æ€å¿«ç…§è¿›è¡ŒæŒä¹…åŒ–æˆ–åŠ è½½ã€‚**
*   **å®æ–½æè¿° (Implementation Description)**:
    1.  åˆ›å»º `src/services/domain/mod.rs` (å¦‚æœå°šä¸å­˜åœ¨) å’Œ `test_record_service.rs`ã€‚
    2.  å®šä¹‰ `ITestRecordService` trait:
        ```rust
        // src/services/domain/test_record_service.rs
        use crate::models::{TestBatchInfo, ChannelTestInstance, AppError};
        use async_trait::async_trait;

        #[async_trait]
        pub trait ITestRecordService: Send + Sync {
            async fn save_test_batch_info(&self, batch_info: &TestBatchInfo) -> Result<(), AppError>;
            async fn get_test_batch_info(&self, batch_id: &str) -> Result<Option<TestBatchInfo>, AppError>;
            async fn get_all_test_batch_infos(&self) -> Result<Vec<TestBatchInfo>, AppError>;
            async fn delete_test_batch_info(&self, batch_id: &str) -> Result<(), AppError>;

            async fn save_channel_test_instance(&self, instance: &ChannelTestInstance) -> Result<(), AppError>;
            async fn save_channel_test_instances(&self, instances: &[ChannelTestInstance]) -> Result<(), AppError>;
            async fn get_channel_test_instances_for_batch(&self, batch_id: &str) -> Result<Vec<ChannelTestInstance>, AppError>;
            async fn get_channel_test_instance(&self, instance_id: &str) -> Result<Option<ChannelTestInstance>, AppError>;
        }
        ```
    3.  å®ç° `TestRecordService` struct:
        ```rust
        use crate::services::infrastructure::persistence::IPersistenceService;
        use std::sync::Arc;

        const BATCH_INFO_COLLECTION: &str = "test_batch_infos";
        const INSTANCE_COLLECTION_PREFIX: &str = "channel_instances_batch_"; // e.g., channel_instances_batch_XYZ

        pub struct TestRecordService {
            persistence: Arc<dyn IPersistenceService>,
        }

        impl TestRecordService {
            pub fn new(persistence: Arc<dyn IPersistenceService>) -> Self {
                Self { persistence }
            }

            fn get_instance_collection_name(batch_id: &str) -> String {
                format!("{}{}", INSTANCE_COLLECTION_PREFIX, batch_id)
            }
        }

        #[async_trait]
        impl ITestRecordService for TestRecordService {
            async fn save_test_batch_info(&self, batch_info: &TestBatchInfo) -> Result<(), AppError> {
                self.persistence.save_document(BATCH_INFO_COLLECTION, &batch_info.batch_id, batch_info).await
            }

            async fn get_test_batch_info(&self, batch_id: &str) -> Result<Option<TestBatchInfo>, AppError> {
                self.persistence.load_document(BATCH_INFO_COLLECTION, batch_id).await
            }

            async fn get_all_test_batch_infos(&self) -> Result<Vec<TestBatchInfo>, AppError> {
                self.persistence.load_all_documents_in_collection(BATCH_INFO_COLLECTION).await
            }
            
            async fn delete_test_batch_info(&self, batch_id: &str) -> Result<(), AppError> {
                // Also consider deleting associated instances or handling orphaned data
                self.persistence.delete_document(BATCH_INFO_COLLECTION, batch_id).await?;
                // Potentially loop and delete all from get_instance_collection_name(batch_id) if DB doesn't cascade
                Ok(())
            }

            async fn save_channel_test_instance(&self, instance: &ChannelTestInstance) -> Result<(), AppError> {
                let collection_name = Self::get_instance_collection_name(&instance.test_batch_id);
                self.persistence.save_document(&collection_name, &instance.instance_id, instance).await
            }
            
            async fn save_channel_test_instances(&self, instances: &[ChannelTestInstance]) -> Result<(), AppError> {
                if instances.is_empty() {
                    return Ok(());
                }
                // Assuming all instances belong to the same batch for this bulk save
                let batch_id = &instances[0].test_batch_id; 
                let collection_name = Self::get_instance_collection_name(batch_id);
                for instance in instances {
                    // Could be parallelized if persistence service supports it and order doesn't matter for individual saves
                    self.persistence.save_document(&collection_name, &instance.instance_id, instance).await?;
                }
                Ok(())
            }

            async fn get_channel_test_instances_for_batch(&self, batch_id: &str) -> Result<Vec<ChannelTestInstance>, AppError> {
                let collection_name = Self::get_instance_collection_name(batch_id);
                self.persistence.load_all_documents_in_collection(&collection_name).await
            }

            async fn get_channel_test_instance(&self, instance_id: &str) -> Result<Option<ChannelTestInstance>, AppError> {
                // This is tricky without knowing the batch_id. 
                // For a simple key-value store mock, this is hard.
                // A real DB could query across collections or have a global instance_id index.
                // For now, this might require iterating all batch instance collections if not found, which is inefficient.
                // Or, TestOrchestrationService should hold batch_id when calling this.
                // Let's assume for now this method might be less used or TestOrchestrationService provides batch_id context.
                println!("[TestRecordService] get_channel_test_instance by instance_id only is potentially inefficient with current mock.");
                // A simplified (and possibly incorrect for mock) approach: try to find it in *any* batch
                // This is illustrative and would need a proper DB query in a real system.
                let all_batches = self.get_all_test_batch_infos().await?;
                for batch in all_batches {
                    let collection_name = Self::get_instance_collection_name(&batch.batch_id);
                    if let Ok(Some(instance)) = self.persistence.load_document::<ChannelTestInstance>(&collection_name, instance_id).await {
                        return Ok(Some(instance));
                    }
                }
                Ok(None)
            }
        }

        ```
    4.  ç¼–å†™å•å…ƒæµ‹è¯•ï¼Œæ³¨å…¥ `MockPersistenceService`ï¼ŒéªŒè¯ `TestRecordService` æ˜¯å¦æ­£ç¡®è°ƒç”¨äº† `IPersistenceService` çš„æ–¹æ³•ï¼Œå¹¶èƒ½å¤„ç†åŸºæœ¬çš„å­˜å–é€»è¾‘ã€‚
        *   æµ‹è¯• `save_test_batch_info` åèƒ½å¦é€šè¿‡ `get_test_batch_info` è·å–ã€‚
        *   æµ‹è¯• `save_channel_test_instance` åèƒ½å¦é€šè¿‡ `get_channel_test_instances_for_batch` å’Œ `get_channel_test_instance` (è€ƒè™‘å…¶å±€é™æ€§) è·å–ã€‚
*   **å¦‚ä½•æµ‹è¯• (How to Test)**:
    *   å•å…ƒæµ‹è¯•ï¼š
        *   `TestRecordService` æ–¹æ³•ä½¿ç”¨ `MockPersistenceService` è¿›è¡Œæµ‹è¯•ã€‚
        *   éªŒè¯ `save_X` åï¼Œ`get_X` èƒ½è¿”å›æ­£ç¡®æ•°æ®ã€‚
        *   éªŒè¯é›†åˆåç§° (`collection_name`) æ˜¯å¦æŒ‰é¢„æœŸç”Ÿæˆå’Œä½¿ç”¨ã€‚
    *   ç¼–è¯‘é€šè¿‡ï¼Œ`clippy` æ— è­¦å‘Šã€‚

### (å®Œæˆ)æ­¥éª¤ 2.4: å®ç° `IDataManagementService` æ¥å£åŠåˆæ­¥Excelå¯¼å…¥ä¸é…ç½®ç®¡ç†é€»è¾‘ (åº”ç”¨å±‚)

*   **åŸå›  (Reason)**:
    *   æ•°æ®å¯¼å…¥æ˜¯å¯åŠ¨æµ‹è¯•æµç¨‹çš„ç¬¬ä¸€æ­¥ã€‚é€šé“é…ç½®çš„ä¿å­˜å’ŒåŠ è½½ä¹Ÿæ˜¯æ ¸å¿ƒåŠŸèƒ½ã€‚
    *   å®ç°æ­¤æœåŠ¡å¯ä»¥åˆæ­¥æ‰“é€š"å¤–éƒ¨æ•°æ® -> å†…éƒ¨æ¨¡å‹ -> æ•°æ®åº“"ä»¥åŠ"æ•°æ®åº“/é…ç½®æ–‡ä»¶ -> å†…éƒ¨æ¨¡å‹"çš„è·¯å¾„ã€‚
*   **æœŸæœ›æ•ˆæœ (Expected Outcome)**:
    *   åœ¨ `src/services/application/data_management_service.rs` ä¸­å®šä¹‰ `IDataManagementService` traitã€‚
    *   å®ç° `DataManagementService` structã€‚
    *   `import_channel_definitions_from_excel` æ–¹æ³•èƒ½è¯»å–æŒ‡å®šExcelæ–‡ä»¶ (ä½¿ç”¨å¦‚ `calamine` crate)ï¼Œå°†è¡Œæ•°æ®è½¬æ¢ä¸º `ChannelPointDefinition` åˆ—è¡¨ã€‚è¿™äº›å®šä¹‰åç»­å°†ç”± `ChannelConfigurationService` æˆ– `TestOrchestrationService` è´Ÿè´£é€šè¿‡ `IPersistenceService` å­˜å…¥æ•°æ®åº“ã€‚
    *   å®ç° `save_channel_definitions` å’Œ `load_channel_definitions` (é’ˆå¯¹ `ChannelPointDefinition` é›†åˆçš„é…ç½®ç®¡ç†)ï¼š
        *   `save_channel_definitions`: å°† `Vec<ChannelPointDefinition>` é€šè¿‡ `IPersistenceService` (ORMå±‚) ä¿å­˜åˆ°æ•°æ®åº“ä¸­ï¼Œå¯èƒ½ä½œä¸ºä¸€ä¸ªå‘½åçš„é…ç½®é›†ã€‚
        *   `load_channel_definitions`: ä»æ•°æ®åº“ä¸­åŠ è½½æŒ‡å®šåç§°çš„ `ChannelPointDefinition` é…ç½®é›†ã€‚
*   **å®æ–½æè¿° (Implementation Description)**:
    1.  åˆ›å»º `src/services/application/mod.rs` å’Œ `src/services/application/data_management_service.rs`ã€‚
    2.  å®šä¹‰ `IDataManagementService` traitã€‚
    3.  å®ç° `DataManagementService` structï¼Œå®ƒå¯èƒ½ä¾èµ– `Arc<dyn IPersistenceService>` å’Œ `Arc<dyn IChannelStateManager>` (å¦‚æœåˆå§‹åŒ–é€»è¾‘éƒ¨åˆ†æ”¾åœ¨è¿™é‡Œæˆ–éœ€è¦è°ƒç”¨)ã€‚é€šå¸¸ï¼Œåº”ç”¨æœåŠ¡ä¸ç›´æ¥è°ƒç”¨ `ChannelStateManager` è¿›è¡Œåˆå§‹åŒ–ï¼Œè€Œæ˜¯ `OrchestrationService` åœ¨å‡†å¤‡å®ä¾‹æ—¶è°ƒç”¨ã€‚
    4.  **`import_channel_definitions_from_excel` å®ç°**: (æ ¸å¿ƒ)
        *   æ·»åŠ  `calamine = "0.22.0"` (æˆ–æœ€æ–°ç‰ˆ) åˆ° `Cargo.toml`ã€‚
        *   æ–¹æ³•æ¥æ”¶ `file_path: PathBuf`ã€‚
        *   ä½¿ç”¨ `calamine::open_workbook_auto(file_path)` æ‰“å¼€Excelã€‚
        *   é€‰æ‹©åˆé€‚çš„sheetï¼Œéå†è¡Œå’Œå•å…ƒæ ¼ã€‚
        *   å°†æ¯è¡Œæ•°æ®æ˜ å°„åˆ° `ChannelPointDefinition` çš„å­—æ®µã€‚æ³¨æ„æ•°æ®ç±»å‹è½¬æ¢å’Œé”™è¯¯å¤„ç†ï¼ˆå¦‚å•å…ƒæ ¼ä¸ºç©ºã€æ ¼å¼ä¸æ­£ç¡®ï¼‰ã€‚
        *   ä¸ºæ¯ä¸ªæˆåŠŸè½¬æ¢çš„ `ChannelPointDefinition` ç”Ÿæˆä¸€ä¸ªå”¯ä¸€ `id` (e.g., `uuid::Uuid::new_v4().to_string()`)ã€‚
        *   è¿”å› `Result<(Vec<ChannelPointDefinition>, Option<TestBatchInfo>), AppError>`ã€‚è¿™äº› `ChannelPointDefinition` å¯¹è±¡æ˜¯ä¸´æ—¶çš„ï¼Œç­‰å¾…è¢«å…¶ä»–æœåŠ¡æŒä¹…åŒ–ã€‚
    5.  **`save_channel_definitions(config_name: &str, definitions: &[ChannelPointDefinition])`**: 
        *   æ­¤æ–¹æ³•å¯èƒ½éœ€è¦å…ˆæ¸…é™¤æ•°æ®åº“ä¸­åŒå `config_name` çš„æ—§å®šä¹‰ (å¦‚æœé€‚ç”¨)ã€‚
        *   éå† `definitions`ï¼Œä¸ºæ¯ä¸ª `definition` è°ƒç”¨ `persistence_service.save_document("channel_definitions_config", config_name_plus_def_id, definition)`ã€‚è¿™é‡Œçš„ `collection_name` å’Œ `document_id` è®¾è®¡éœ€è¦ä»”ç»†è€ƒè™‘å¦‚ä½•å°†ä¸€ç»„ `definitions` ä¸ `config_name` å…³è”å¹¶å­˜å‚¨ã€‚
        *   æˆ–è€…ï¼Œå¦‚æœ `definitions` æ•´ä½“ä½œä¸ºä¸€ä¸ªæ–‡æ¡£å­˜å‚¨ (ä¾‹å¦‚ï¼Œä¸€ä¸ªåŒ…å« `Vec<ChannelPointDefinition>` çš„ç»“æ„ä½“)ï¼Œåˆ™è°ƒç”¨ `persistence_service.save_document("channel_definition_sets", config_name, &wrapper_struct)`ã€‚
    6.  **`load_channel_definitions(config_name: &str)`**: 
        *   æ ¹æ® `save_channel_definitions` çš„å­˜å‚¨æ–¹å¼ï¼Œä»æ•°æ®åº“ä¸­æŸ¥è¯¢å¹¶é‡æ„ `Vec<ChannelPointDefinition>`ã€‚
*   **å¦‚ä½•æµ‹è¯• (How to Test)**:
    *   **å•å…ƒæµ‹è¯•**: (é’ˆå¯¹Excelè§£æé€»è¾‘)
        *   å‡†å¤‡å‡ ä¸ªå°å‹çš„æµ‹è¯•ç”¨Excelæ–‡ä»¶ï¼š
            *   åŒ…å«æœ‰æ•ˆæ•°æ®çš„æ ‡å‡†æ–‡ä»¶ã€‚
            *   åŒ…å«éƒ¨åˆ†ç©ºå•å…ƒæ ¼çš„æ–‡ä»¶ã€‚
            *   åŒ…å«é”™è¯¯æ•°æ®ç±»å‹çš„æ–‡ä»¶ï¼ˆå¦‚é‡ç¨‹åˆ—å¡«äº†æ–‡æœ¬ï¼‰ã€‚
            *   ä¸åŒæ¨¡å—ç±»å‹ (AI, DI, AO, DO) çš„è¡Œã€‚
        *   æµ‹è¯• `import_channel_definitions_from_excel`:
            *   éªŒè¯è¿”å›çš„ `Vec<ChannelPointDefinition>` æ•°é‡å’Œå†…å®¹æ˜¯å¦ä¸Excelæ–‡ä»¶åŒ¹é…ã€‚
            *   éªŒè¯å­—æ®µæ˜ å°„æ˜¯å¦æ­£ç¡® (e.g., Excelçš„"ä½å·"åˆ—æ˜¯å¦æ­£ç¡®èµ‹ç»™äº† `ChannelPointDefinition::tag`)ã€‚
            *   éªŒè¯æ•°æ®ç±»å‹è½¬æ¢æ˜¯å¦æ­£ç¡®ï¼ˆå­—ç¬¦ä¸²åˆ° `Option<f32>`ï¼Œå­—ç¬¦ä¸²åˆ° `ModuleType` enumï¼‰ã€‚
            *   éªŒè¯é”™è¯¯å¤„ç†ï¼šå¯¹äºåŒ…å«é”™è¯¯æ•°æ®çš„Excelï¼ŒæœåŠ¡åº”å¦‚ä½•ååº”ï¼ˆè·³è¿‡é”™è¯¯è¡Œå¹¶è®°å½•æ—¥å¿—ï¼Ÿè¿”å› `Err`ï¼Ÿï¼‰ã€‚
        *   æµ‹è¯•é…ç½®ä¿å­˜/åŠ è½½ (å¦‚æœå®ç°): ä½¿ç”¨ `MockPersistenceService` éªŒè¯äº¤äº’ã€‚

### (å®Œæˆ)æ­¥éª¤ 2.5: å®ç° `ITestOrchestrationService` æ¥å£éª¨æ¶åŠæ ¸å¿ƒæµç¨‹çš„åˆæ­¥ä¸²è” (åº”ç”¨å±‚)

*   **åŸå›  (Reason)**:
    *   `TestOrchestrationService` æ˜¯åç«¯çš„æ ¸å¿ƒåè°ƒè€…ï¼Œè´Ÿè´£å°†å„ä¸ªé¢†åŸŸæœåŠ¡ä¸²è”èµ·æ¥å®Œæˆä¸šåŠ¡æµç¨‹ã€‚
    *   æ—©æœŸæ­å»ºå…¶éª¨æ¶å¹¶å®ç°ä¸€ä¸¤ä¸ªæ ¸å¿ƒæµç¨‹ï¼Œæœ‰åŠ©äºéªŒè¯æ•´ä½“æ¶æ„çš„è¿é€šæ€§ã€‚
*   **æœŸæœ›æ•ˆæœ (Expected Outcome)**:
    *   åœ¨ `src/services/application/test_orchestration_service.rs` å®šä¹‰ `ITestOrchestrationService` traitã€‚
    *   å®ç° `TestOrchestrationService` structï¼Œæ³¨å…¥æ‰€æœ‰å¿…è¦çš„ä¾èµ– (å¦‚ `IDataManagementService`, `ITestExecutionEngine`, `IChannelStateManager`, `ITestRecordService`, `IChannelConfigurationService` (å¦‚æœä½¿ç”¨)ï¼Œä»¥åŠ `tauri::AppHandle` ç”¨äºäº‹ä»¶é€šçŸ¥ç­‰)ã€‚
    *   **æ ¸å¿ƒæ•°æ®ç®¡ç†**: `TestOrchestrationService` å°†è´Ÿè´£åœ¨å…¶å†…éƒ¨ç»´æŠ¤å½“å‰æ´»åŠ¨çš„ `TestBatchInfo` å’Œç›¸å…³çš„ `ChannelTestInstance` åˆ—è¡¨ã€‚è¿™äº› `ChannelTestInstance` **ä¸»è¦åœ¨å†…å­˜ä¸­ç®¡ç†** (ä¾‹å¦‚ä½¿ç”¨ `Arc<Mutex<HashMap<BatchId, BatchRuntimeState>>>`ï¼Œå…¶ä¸­ `BatchRuntimeState` åŒ…å« `TestBatchInfo` å’Œ `HashMap<InstanceId, ChannelTestInstance>`)ï¼Œä»¥æ”¯æŒå¿«é€Ÿçš„çŠ¶æ€æ›´æ–°å’Œè¯»å–ã€‚
    *   **`create_test_batch`**: åˆ›å»º `TestBatchInfo`ï¼Œåœ¨å†…å­˜ä¸­è®°å½•ï¼Œå¹¶è°ƒç”¨ `ITestRecordService.save_test_batch_info` æŒä¹…åŒ–æ‰¹æ¬¡æœ¬èº«çš„ä¿¡æ¯ï¼ˆä½†ä¸æŒä¹…åŒ–ç©ºçš„å®ä¾‹åˆ—è¡¨ï¼‰ã€‚
    *   **`prepare_test_instances_for_batch`**: æ ¹æ®æä¾›çš„ `ChannelPointDefinition` åˆ—è¡¨ï¼Œè°ƒç”¨ `IChannelStateManager.initialize_channel_test_instance` åˆ›å»º `ChannelTestInstance` å¯¹è±¡ã€‚è¿™äº›æ–°åˆ›å»ºçš„å®ä¾‹**ä»…åœ¨å†…å­˜ä¸­ç®¡ç†**ï¼Œä¸åœ¨æ­¤é˜¶æ®µç«‹å³æŒä¹…åŒ–åˆ°æ•°æ®åº“ã€‚
    *   **`start_tests_for_batch` (æ ¸å¿ƒæµç¨‹)**: 
        *   è·å–æŒ‡å®šæ‰¹æ¬¡çš„å†…å­˜ä¸­çš„ `ChannelTestInstance` åˆ—è¡¨ã€‚
        *   ä¸ºè¯¥æ‰¹æ¬¡çš„æµ‹è¯•æ‰§è¡Œåˆ›å»ºä¸€ä¸ª MPSC channel (`outcome_tx`, `outcome_rx`) ç”¨äºä» `TestExecutionEngine` æ¥æ”¶ `RawTestOutcome`ã€‚
        *   å¯åŠ¨ä¸€ä¸ªå¼‚æ­¥çš„ "Outcome Processing Task" æ¥æ¶ˆè´¹ `outcome_rx`:
            *   å¯¹äºæ¯ä¸ªä» `outcome_rx` æ”¶åˆ°çš„ `RawTestOutcome`:
                *   ä»å†…å­˜ä¸­è·å–å¯¹åº” `ChannelTestInstance` çš„å¯å˜å¼•ç”¨ã€‚
                *   è°ƒç”¨ `IChannelStateManager.apply_raw_outcome` æ¥æ›´æ–°è¯¥å®ä¾‹åœ¨å…¶å†…å­˜ä¸­çš„çŠ¶æ€ã€‚
                *   **æŒä¹…åŒ–å†³ç­–ç‚¹**: æ ¹æ® `TestOrchestrationService` çš„å†…éƒ¨é€»è¾‘ï¼ˆä¾‹å¦‚ï¼ŒæŸä¸ª `ChannelTestInstance` çš„ `overall_status` è¾¾åˆ°äº†ä¸€ä¸ªé‡è¦çš„é˜¶æ®µæ€§ç»ˆæ€å¦‚ `HardPointTestCompleted`, `TestCompletedPassed`, `TestCompletedFailed`ï¼Œæˆ–è€…ä¸€ä¸ªå…³é”®å­æµ‹è¯•å¦‚ `SubTestItem::HardPoint` å®Œæˆï¼‰ï¼Œåˆ¤æ–­å½“å‰æ˜¯å¦ä¸ºä¸€ä¸ªåˆé€‚çš„æŒä¹…åŒ–èŠ‚ç‚¹ã€‚å¦‚æœç¡®å®šæ˜¯ï¼Œåˆ™è°ƒç”¨ `ITestRecordService.save_channel_test_instance` å°†å½“å‰å†…å­˜ä¸­è¯¥å®ä¾‹çš„å¿«ç…§ä¿å­˜åˆ°æ•°æ®åº“ã€‚
                *   é€šè¿‡ `tauri::AppHandle` (æˆ–å°è£…çš„ `INotificationService`) å‘é€ `ChannelStateChanged` äº‹ä»¶ï¼Œæºå¸¦ä»å†…å­˜ä¸­è·å–çš„ã€å·²æ›´æ–°çš„å®ä¾‹æ•°æ®ã€‚
        *   å¯¹äºæ‰¹æ¬¡ä¸­çš„æ¯ä¸ªï¼ˆå‡†å¤‡å¥½çš„ï¼‰`ChannelTestInstance`ï¼Œè¿åŒå…¶å¯¹åº”çš„ `ChannelPointDefinition`ï¼Œè°ƒç”¨ `ITestExecutionEngine.submit_test_instance`ï¼Œå¹¶å°† `outcome_tx` å…‹éš†ä¸€ä»½ä¼ é€’ç»™å®ƒã€‚
    *   **å…¶ä»–æ“ä½œå¦‚ `pause_tests_for_batch`, `resume_tests_for_batch`, `stop_tests_for_batch`, `retest_channel_instance`, `skip_channel_instance`**: è¿™äº›æ–¹æ³•ä¸»è¦æ“ä½œå†…å­˜ä¸­ `ChannelTestInstance` çš„çŠ¶æ€ã€‚åœ¨æ‰§è¡Œè¿™äº›æ“ä½œåï¼Œç‰¹åˆ«æ˜¯åœ¨è¾¾åˆ°æ˜ç¡®çš„ä¸šåŠ¡æµç¨‹èŠ‚ç‚¹æ—¶ï¼ˆä¾‹å¦‚ï¼Œç”¨æˆ·è¯·æ±‚"åœæ­¢å¹¶ä¿å­˜è¿›åº¦"ï¼‰ï¼Œ`TestOrchestrationService` ä¼šè°ƒç”¨ `ITestRecordService` æ¥æŒä¹…åŒ–å—å½±å“å®ä¾‹çš„å½“å‰çŠ¶æ€ã€‚
    *   **`get_batch_status_and_instances`**: æ­¤æ–¹æ³•åº”ä¸»è¦ä»å†…å­˜ä¸­èšåˆå’Œè¿”å› `TestBatchInfo` å’Œ `Vec<ChannelTestInstance>`ï¼Œä»¥ç¡®ä¿å‰ç«¯æ€»æ˜¯è·å–åˆ°æœ€æ–°çš„å®æ—¶çŠ¶æ€ã€‚å¦‚æœéœ€è¦ä»æ•°æ®åº“åŠ è½½ï¼ˆä¾‹å¦‚ï¼Œåº”ç”¨é‡å¯åæ¢å¤æ‰¹æ¬¡ï¼‰ï¼Œåˆ™åº”æœ‰å•ç‹¬çš„é€»è¾‘å¤„ç†ã€‚
*   **å®æ–½æè¿° (Implementation Description)**:
    1.  åˆ›å»º `src/services/application/test_orchestration_service.rs`ã€‚
    2.  å®šä¹‰ `ITestOrchestrationService` traitã€‚
    3.  å®ç° `TestOrchestrationService` structã€‚å­—æ®µåŒ…æ‹¬ï¼š
        *   `data_management_service: Arc<dyn IDataManagementService>`
        *   `test_execution_engine: Arc<dyn ITestExecutionEngine>`
        *   `channel_state_manager: Arc<dyn IChannelStateManager>`
        *   `test_record_service: Arc<dyn ITestRecordService>`
        *   (å¯é€‰) `channel_config_service: Arc<dyn IChannelConfigurationService>`
        *   (å¯é€‰) `active_batches: Arc<Mutex<HashMap<String, BatchRuntimeState>>>`ï¼Œå…¶ä¸­ `BatchRuntimeState` åŒ…å« `TestBatchInfo` å’Œ `HashMap<String, ChannelTestInstance>` (å®ä¾‹ID -> å®ä¾‹æ•°æ®)ã€‚
        *   (å¯é€‰) `app_handle: tauri::AppHandle` (å¦‚æœéœ€è¦å‘é€Tauriäº‹ä»¶)ã€‚
    4.  **`create_test_batch` å®ç°**: åˆ›å»º `TestBatchInfo`ï¼Œï¼ˆå¯é€‰ï¼‰å­˜å…¥ `active_batches` å’Œ `ITestRecordService`ã€‚
    5.  **`prepare_test_instances_for_batch` å®ç°**:
        *   (å¦‚æœä½¿ç”¨ `IChannelConfigurationService`) æ ¹æ® `definition_ids` ä» `channel_config_service` åŠ è½½ `ChannelPointDefinition`ã€‚
        *   (å¦‚æœç›´æ¥ä»å¯¼å…¥è·å–) `definition_ids` å¯èƒ½æ˜¯ `ChannelPointDefinition` æœ¬èº«ã€‚
        *   éå† `definitions`ï¼Œä¸ºæ¯ä¸ªè°ƒç”¨ `channel_state_manager.initialize_channel_test_instance`ã€‚
        *   å°†åˆå§‹åŒ–çš„ `ChannelTestInstance` å­˜å…¥ `active_batches` (å¦‚æœä½¿ç”¨) å¹¶è¿”å›ã€‚
    6.  **`start_tests_for_batch` å®ç°**: (æ ¸å¿ƒ)
        *   ä» `active_batches` (æˆ–å‚æ•°) è·å–è¦æµ‹è¯•çš„ `ChannelTestInstance` åŠå…¶å¯¹åº”çš„ `ChannelPointDefinition`ã€‚
        *   åˆ›å»º `tokio::sync::mpsc::channel` (e.g., `(outcome_tx, mut outcome_rx)` )ã€‚
        *   `let batch_instances_clone = self.active_batches.clone();`
        *   `let state_manager_clone = self.channel_state_manager.clone();`
        *   `let record_service_clone = self.test_record_service.clone();`
        *   `tokio::spawn(async move { while let Some(outcome_result) = outcome_rx.recv().await { ... } });` // Outcome processing loop
            *   åœ¨å¾ªç¯å†…éƒ¨ï¼š
                *   `if let Ok(raw_outcome) = outcome_result { ... }`
                *   `let mut batches = batch_instances_clone.lock().await;`
                *   `if let Some(batch_state) = batches.get_mut(batch_id_from_outcome_or_context) { ... }`
                *   `if let Some(instance_to_update) = batch_state.instances.get_mut(&raw_outcome.channel_instance_id) { ... }`
                *   `state_manager_clone.apply_raw_outcome(instance_to_update, raw_outcome).await.unwrap_or_else(|e| error!("Failed to apply outcome: {}", e));`
                *   `record_service_clone.save_channel_test_instance(instance_to_update).await.unwrap_or_else(|e| error!("Failed to save instance: {}", e));`
                *   (TODO: å‘é€Tauriäº‹ä»¶ `ChannelStateChanged`)
        *   éå†è¦æµ‹è¯•çš„ `(instance, definition)`:
            *   `self.test_execution_engine.submit_test_instance(instance.clone(), definition.clone(), outcome_tx.clone()).await...`
*   **å¦‚ä½•æµ‹è¯• (How to Test)**:
    *   **é›†æˆæµ‹è¯•**: (è¿™æ˜¯æœ¬é˜¶æ®µæœ€é‡è¦çš„æµ‹è¯•)
        *   **Mockæ‰€æœ‰ä¾èµ–**: `MockDataManagementService`, `MockTestExecutionEngine`, `MockChannelStateManager`, `MockTestRecordService`ã€‚
        *   **`MockTestExecutionEngine` çš„è¡Œä¸º**: å½“è°ƒç”¨ `submit_test_instance` æ—¶ï¼Œå®ƒåº”èƒ½æ¨¡æ‹Ÿå‘é€ä¸€ä¸ªæˆ–å¤šä¸ªé¢„è®¾çš„ `RawTestOutcome` åˆ°ä¼ å…¥çš„ `outcome_sender`ã€‚
        *   **æµ‹è¯• `start_tests_for_batch` æµç¨‹**:
            1.  è°ƒç”¨ `create_test_batch`ã€‚
            2.  è°ƒç”¨ `prepare_test_instances_for_batch` (ä½¿ç”¨mockçš„ `ChannelPointDefinition`ï¼Œ`MockChannelStateManager` è¿”å›é¢„æœŸçš„åˆå§‹ `ChannelTestInstance`)ã€‚
            3.  è°ƒç”¨ `start_tests_for_batch`ã€‚
            4.  éªŒè¯ `MockTestExecutionEngine.submit_test_instance` æ˜¯å¦è¢«æ­£ç¡®è°ƒç”¨ã€‚
            5.  éªŒè¯ `TestOrchestrationService` ä¸­çš„ outcome processing loop æ˜¯å¦èƒ½æ¥æ”¶åˆ° `MockTestExecutionEngine` å‘é€çš„ `RawTestOutcome`ã€‚
            6.  éªŒè¯å¯¹äºæ¯ä¸ªæ”¶åˆ°çš„ `RawTestOutcome`ï¼Œ`MockChannelStateManager.apply_raw_outcome` æ˜¯å¦è¢«ä»¥æ­£ç¡®çš„å‚æ•°è°ƒç”¨ã€‚
            7.  éªŒè¯ `MockTestRecordService.save_channel_test_instance` æ˜¯å¦è¢«è°ƒç”¨ã€‚
        *   æµ‹è¯•é”™è¯¯åœºæ™¯ï¼šå¦‚ `submit_test_instance` å¤±è´¥ï¼Œ`apply_raw_outcome` å¤±è´¥ç­‰ã€‚

---

## Phase 3: åç«¯æœåŠ¡å®Œå–„ä¸ Tauri é›†æˆ

**ç›®æ ‡ï¼š** å®Œå–„æ‰€æœ‰åç«¯æœåŠ¡çš„æ¥å£å’Œä¸»è¦åŠŸèƒ½å®ç°ï¼Œæ­å»ºTauriåº”ç”¨ï¼Œå¹¶é€šè¿‡Tauri Commandå°†åç«¯æœåŠ¡æš´éœ²ç»™æœªæ¥çš„å‰ç«¯ï¼Œå®ç°åˆæ­¥çš„å‰åç«¯é€šä¿¡ã€‚

### (å®Œæˆ)æ­¥éª¤ 3.1: å®Œå–„æ‰€æœ‰åç«¯æœåŠ¡æ¥å£çš„å…¶ä½™æ–¹æ³•å®ç°

*   **åŸå›  (Reason)**:
    *   åœ¨ä¸å‰ç«¯é›†æˆä¹‹å‰ï¼Œåç«¯åº”å…·å¤‡ç›¸å¯¹å®Œæ•´çš„åŠŸèƒ½é›†ï¼Œä»¥æ”¯æŒæ ¸å¿ƒä¸šåŠ¡æµç¨‹çš„é—­ç¯ã€‚
*   **æœŸæœ›æ•ˆæœ (Expected Outcome)**:
    *   **`ITestOrchestrationService`**: å®ç° `confirm_wiring_for_batch`, `pause/resume/stop_tests_for_batch`, `retest_channel_instance`, `skip_channel_instance`, `get_batch_status_and_instances`, `get_channel_instance_details` ç­‰æ–¹æ³•ã€‚
        *   **å…³é”®çš„æŒä¹…åŒ–ç­–ç•¥**ï¼šåœ¨å®ç°è¿™äº›æ–¹æ³•æ—¶ï¼Œä¸¥æ ¼éµå¾ª"å†…å­˜ä¼˜å…ˆï¼Œç‰¹å®šèŠ‚ç‚¹æŒä¹…åŒ–"çš„åŸåˆ™ã€‚ä¾‹å¦‚ï¼Œ`pause_tests_for_batch` æˆ– `stop_tests_for_batch` å¯èƒ½ä¼šæˆä¸ºä¸€ä¸ª"ä¿å­˜ç‚¹"ï¼Œæ­¤æ—¶åº”è°ƒç”¨ `ITestRecordService` å°†å½“å‰å†…å­˜ä¸­æ‰€æœ‰ç›¸å…³ `ChannelTestInstance` çš„çŠ¶æ€æŒä¹…åŒ–ã€‚`retest_channel_instance` åœ¨é‡ç½®å†…å­˜çŠ¶æ€åï¼Œæ–°çš„æµ‹è¯•ç»“æœä¹Ÿåº”åœ¨åˆé€‚çš„èŠ‚ç‚¹ï¼ˆå¦‚æµ‹è¯•å®Œæˆæ—¶ï¼‰æŒä¹…åŒ–ã€‚
        *   **æ–°å¢/ç›¸å…³æ•°æ®æ¨¡å‹ (Rust, in `models.rs` or a new `payloads.rs`):**
            ```rust
            use crate::models::{TestBatchInfo, ChannelTestInstance, ChannelPointDefinition}; // Assuming models are in crate::models
            use serde::{Serialize, Deserialize};

            #[derive(Debug, Clone, Serialize, Deserialize)]
            pub struct BatchDetailsPayload {
                pub batch_info: TestBatchInfo,
                pub instances: Vec<ChannelTestInstance>,
            }

            #[derive(Debug, Clone, Serialize, Deserialize)]
            pub struct ChannelInstanceDetailsPayload {
                pub instance: ChannelTestInstance,
                pub definition: ChannelPointDefinition,
            }
            ```
    *   **`IDataManagementService`**: å®Œå–„ `export_test_results_to_excel` (å¯èƒ½ä½¿ç”¨ `rust_xlsxwriter` crate) å’Œå…¶ä»–æ•°æ®ç®¡ç†åŠŸèƒ½ã€‚
    *   **`IManualTestService`**: å®ç° `execute_manual_sub_test`, `read_current_value`, `write_value_manual`ã€‚
        *   **ç›¸å…³æ•°æ®æ¨¡å‹ (Rust):**
            *   `execute_manual_sub_test` å‚æ•°å¯èƒ½éœ€è¦: `instance_id: String`, `sub_test_item: SubTestItem`, `params: Option<HashMap<String, serde_json::Value>>` (ç”¨äºä¼ é€’å¦‚æ‰‹åŠ¨è®¾å®šçš„å€¼)ã€‚
    *   **`IChannelConfigurationService`**: (å¦‚æœéœ€è¦) å®ç°å®Œæ•´çš„CRUDæ“ä½œã€‚
    *   **`IStatisticsService`**: å®ç° `calculate_batch_statistics`ã€‚
    *   æ‰€æœ‰å®ç°éƒ½åº”åŒ…å«å®Œæ•´çš„é”™è¯¯å¤„ç†å’Œæ—¥å¿—è®°å½•ã€‚
*   **å®æ–½æè¿° (Implementation Description)**:
    1.  **`ITestOrchestrationService` æ–¹æ³•å®ç°**:
        *   `confirm_wiring_for_batch`: éå†å®ä¾‹ï¼Œè°ƒç”¨ `IChannelStateManager.prepare_for_wiring_confirmation`ã€‚
        *   `pause/resume/stop`: è°ƒç”¨ `ITestExecutionEngine` å¯¹åº”çš„æ–¹æ³•ï¼Œå¹¶ç®¡ç† `active_batches` ä¸­çš„çŠ¶æ€ã€‚
        *   `retest_channel_instance`: è°ƒç”¨ `IChannelStateManager.reset_for_retest`ï¼Œç„¶åé‡æ–°å°†å®ä¾‹æäº¤ç»™ `ITestExecutionEngine`ã€‚
        *   `skip_channel_instance`: è°ƒç”¨ `IChannelStateManager.mark_as_skipped`ã€‚
        *   Getteræ–¹æ³•: ä» `active_batches` (æˆ– `ITestRecordService`) è¯»å–æ•°æ®å¹¶è¿”å›ã€‚
    2.  **`IDataManagementService.export_test_results_to_excel`**: ä½¿ç”¨ `rust_xlsxwriter` crate åˆ›å»ºå’Œå†™å…¥Excelã€‚éå† `ChannelTestInstance` æ•°æ®ï¼Œå°†å…¶æ ¼å¼åŒ–åˆ°å·¥ä½œè¡¨ä¸­ã€‚
    3.  **`IManualTestService` æ–¹æ³•å®ç°**:
        *   `execute_manual_sub_test`: è·å– `ChannelTestInstance` å’Œ `ChannelPointDefinition`ã€‚åˆ›å»ºå¯¹åº”çš„ `ISpecificTestStepExecutor`ï¼Œè°ƒç”¨å…¶ `execute` æ–¹æ³•ã€‚è·å– `RawTestOutcome`ï¼Œç„¶åè°ƒç”¨ `IChannelStateManager.apply_raw_outcome`ã€‚è¿”å› `RawTestOutcome`ã€‚
        *   `read_current_value`/`write_value_manual`: å¯èƒ½éœ€è¦ç‰¹å®šçš„ `ISpecificTestStepExecutor` (å¦‚ `GenericReadExecutor`, `GenericWriteExecutor`) æˆ–ç›´æ¥è°ƒç”¨ `IPlcCommunicationService`ã€‚
    4.  **`IStatisticsService.calculate_batch_statistics`**: éå† `ChannelTestInstance` åˆ—è¡¨ï¼Œæ ¹æ®å…¶ `overall_status` ç»Ÿè®¡æ€»æ•°ã€é€šè¿‡æ•°ã€å¤±è´¥æ•°ç­‰ï¼Œå¹¶æ›´æ–°ä¼ å…¥çš„ `TestBatchInfo`ã€‚
    5.  ä¸ºæ‰€æœ‰æ–°å®ç°çš„æ–¹æ³•ç¼–å†™å•å…ƒæµ‹è¯•å’Œé›†æˆæµ‹è¯•ï¼Œé‡ç‚¹æµ‹è¯•æœåŠ¡é—´çš„äº¤äº’å’Œä¸šåŠ¡é€»è¾‘çš„æ­£ç¡®æ€§ã€‚
*   **å¦‚ä½•æµ‹è¯• (How to Test)**:
    *   **å•å…ƒæµ‹è¯•**: é’ˆå¯¹æ¯ä¸ªæœåŠ¡æ–°å¢çš„æ–¹æ³•ï¼Œmockå…¶ä¾èµ–é¡¹ï¼ŒéªŒè¯æ–¹æ³•é€»è¾‘ã€‚
        *   ä¾‹å¦‚ï¼Œæµ‹è¯• `ITestOrchestrationService.retest_channel_instance` æ—¶ï¼ŒéªŒè¯ `MockChannelStateManager.reset_for_retest` å’Œ `MockTestExecutionEngine.submit_test_instance` æ˜¯å¦è¢«æ­£ç¡®è°ƒç”¨ã€‚
        *   æµ‹è¯• `IDataManagementService.export_test_results_to_excel`ï¼Œå¯ä»¥ä¸å®é™…å†™æ–‡ä»¶ï¼Œè€Œæ˜¯éªŒè¯ä¼ é€’ç»™ `rust_xlsxwriter` mock åŒ…è£…å™¨çš„æ•°æ®æ˜¯å¦æ­£ç¡®ã€‚
    *   **é›†æˆæµ‹è¯•**: æ‰©å±• Phase 2 çš„é›†æˆæµ‹è¯•ï¼Œè¦†ç›–æ›´å®Œæ•´çš„ä¸šåŠ¡æµç¨‹ï¼Œå¦‚"å¯¼å…¥->æ¥çº¿->å¼€å§‹æµ‹è¯•->éƒ¨åˆ†å¤±è´¥->é‡æµ‹å¤±è´¥ç‚¹->è·³è¿‡æŸä¸ªç‚¹->å¯¼å‡ºç»“æœ"ã€‚

### (å®Œæˆ)æ­¥éª¤ 3.2: æ­å»º Tauri åº”ç”¨éª¨æ¶

*   **åŸå›  (Reason)**:
    *   Tauri æ˜¯è¿æ¥ Rust åç«¯å’Œ Angular å‰ç«¯çš„æ¡¥æ¢ã€‚
    *   å°½æ—©æ­å»ºTauriåº”ç”¨ï¼Œå¯ä»¥éªŒè¯åŸºæœ¬çš„é¡¹ç›®é…ç½®å’Œæ„å»ºæµç¨‹ã€‚
*   **æœŸæœ›æ•ˆæœ (Expected Outcome)**:
    *   ä½¿ç”¨ Tauri CLI åˆ›å»ºä¸€ä¸ªæ–°çš„ Tauri é¡¹ç›® (å…¶ä¸­åŒ…å«ä¸€ä¸ªç®€å•çš„ Rust åç«¯å’Œä¸€ä¸ªWebå‰ç«¯çš„å ä½ç¬¦)ã€‚
    *   èƒ½å¤ŸæˆåŠŸæ„å»ºå¹¶è¿è¡Œä¸€ä¸ªç©ºç™½çš„ Tauri åº”ç”¨çª—å£ã€‚
    *   Rust åç«¯æ ¸å¿ƒé€»è¾‘ (åœ¨ Phase 1 & 2 å¼€å‘çš„ services, models ç­‰) èƒ½å¤Ÿè¢«Tauriä¸»é¡¹ç›®çš„ `main.rs` (æˆ–å…¶æ¨¡å—) å¼•ç”¨å’Œè®¿é—®ã€‚
*   **å®æ–½æè¿° (Implementation Description)**:
    1.  ç¡®ä¿å·²å®‰è£… Tauri å¼€å‘ç¯å¢ƒ (`Node.js`, `Rust`, `WebView2` (Windows), `webkit2gtk` (Linux), `Xcode Command Line Tools` (macOS))ã€‚
    2.  åœ¨é¡¹ç›®æ ¹ç›®å½•ä¸‹ (ä¸ `fat_test_backend` å¹³çº§æˆ–å°†å…¶ä½œä¸º `src-tauri` çš„ä¸€éƒ¨åˆ†) æ‰§è¡Œ `npm create tauri-app@latest` (æˆ– `yarn create tauri-app`, `pnpm create tauri-app`)ã€‚
    3.  æŒ‰ç…§æç¤ºé€‰æ‹©é¡¹ç›®åç§° (e.g., `fat_test_desktop_app`)ï¼Œé€‰æ‹©å‰ç«¯æ¨¡æ¿ (å¯ä»¥é€‰æ‹© Vanilla JS æˆ–ä¸€ä¸ªç®€å•çš„ HTML é¡µé¢ä½œä¸ºåˆå§‹å ä½ï¼Œåç»­æ›¿æ¢ä¸º Angular)ã€‚
    4.  ç¡®ä¿ `src-tauri/Cargo.toml` åŒ…å«äº†å¿…è¦çš„ä¾èµ–ï¼Œå¦‚ `serde`, `serde_json`, `tokio`, `thiserror` ä»¥åŠåç»­ä¼šç”¨åˆ°çš„ ORM å’Œ PLC é€šä¿¡åº“ç­‰ã€‚å¦‚æœåç«¯æ ¸å¿ƒé€»è¾‘ï¼ˆå¦‚ `models`, `services`ï¼‰æ˜¯ä½œä¸º `src-tauri` crate çš„ä¸€éƒ¨åˆ†ç›´æ¥åœ¨ `src-tauri/src/` ç›®å½•ä¸‹ç»„ç»‡ï¼Œåˆ™ä¸éœ€è¦é¢å¤–çš„ path dependency æ¥å¼•ç”¨å®ƒä»¬ã€‚`src-tauri/src/main.rs` (æˆ– `lib.rs` å¦‚æœæœ‰) å°†ç›´æ¥å¼•ç”¨è¿™äº›å†…éƒ¨æ¨¡å—ã€‚
    5.  åœ¨ `src-tauri/src/main.rs` ä¸­ï¼Œå°è¯•å¼•å…¥å¹¶å®ä¾‹åŒ–åœ¨ `src-tauri/src/services` ç­‰æ¨¡å—ä¸­å®šä¹‰çš„åç«¯æœåŠ¡ (æ­¤æ—¶æœåŠ¡å®ä¾‹å¯èƒ½è¿˜æœªé€šè¿‡Tauri stateç®¡ç†)ã€‚
    6.  è¿è¡Œ `npm run tauri dev` (æˆ– `yarn tauri dev`)ï¼Œç¡®ä¿èƒ½çœ‹åˆ°ä¸€ä¸ªTauriçª—å£ã€‚
*   **å¦‚ä½•æµ‹è¯• (How to Test)**:
    *   **æˆåŠŸæ„å»ºå’Œè¿è¡Œ**: `npm run tauri dev` å‘½ä»¤æˆåŠŸæ‰§è¡Œï¼Œæ²¡æœ‰ç¼–è¯‘é”™è¯¯ï¼Œå¹¶å¼¹å‡ºä¸€ä¸ªæ¡Œé¢çª—å£ã€‚
    *   **æ—¥å¿—è¾“å‡º**: åœ¨ `src-tauri/src/main.rs` çš„ `setup` é’©å­ä¸­å°è¯•è°ƒç”¨åç«¯æœåŠ¡çš„ä¸€ä¸ªç®€å•æ–¹æ³•ï¼ˆä¾‹å¦‚ï¼Œä¸€ä¸ªè¿”å›ç‰ˆæœ¬å·çš„mockæ–¹æ³•ï¼‰ï¼Œå¹¶æ‰“å°æ—¥å¿—ï¼Œç¡®è®¤åç«¯ä»£ç è¢«æ‰§è¡Œã€‚

### (å®Œæˆ)æ­¥éª¤ 3.3: åœ¨ Tauri `main.rs` ä¸­è®¾ç½®åº”ç”¨çŠ¶æ€ï¼Œå®ä¾‹åŒ–å¹¶æ³¨å…¥æœåŠ¡ä¾èµ–

*   **åŸå›  (Reason)**:
    *   Tauri `commands` éœ€è¦è®¿é—®åç«¯æœåŠ¡å®ä¾‹æ¥æ‰§è¡Œä¸šåŠ¡é€»è¾‘ã€‚
    *   é€šè¿‡ Tauri çš„çŠ¶æ€ç®¡ç†æœºåˆ¶ï¼Œå¯ä»¥å°†æœåŠ¡å®ä¾‹å®‰å…¨åœ°å…±äº«ç»™æ‰€æœ‰ `command` å‡½æ•°ã€‚
*   **æœŸæœ›æ•ˆæœ (Expected Outcome)**:
    *   å®šä¹‰ `AppState` ç»“æ„ä½“ï¼ŒåŒ…å«æ‰€æœ‰åç«¯æœåŠ¡çš„å®ä¾‹ (é€šå¸¸æ˜¯ `Arc<dyn ITrait>` æˆ– `Arc<Mutex<ConcreteService>>`)ã€‚
    *   åœ¨ `main` å‡½æ•°ä¸­åˆå§‹åŒ–æ‰€æœ‰æœåŠ¡ï¼Œç‰¹åˆ«æ˜¯ `IPersistenceService` çš„å®ç°åº”ä¸º `SqliteOrmPersistenceService`ï¼ˆç¡®ä¿æ•°æ®åº“è¿æ¥å’Œè¿ç§»å·²å¤„ç†ï¼‰ï¼Œå¹¶å°†å®ƒä»¬å­˜å…¥ `AppState`ã€‚
    *   ä½¿ç”¨ `tauri::Builder::default().manage(app_state).invoke_handler(...)` å°†çŠ¶æ€åŒ–çš„æœåŠ¡æä¾›ç»™Tauriã€‚
*   **å®æ–½æè¿° (Implementation Description)**:
    1.  åœ¨ `src/state/app_state.rs` (æˆ–ç±»ä¼¼ä½ç½®) å®šä¹‰ `AppState`ã€‚
        ```rust
        // Example in src/state/app_state.rs
        use std::sync::Arc;
        use crate::services::application::{
            ITestOrchestrationService, TestOrchestrationService,
            IDataManagementService, DataManagementService,
            // ... other application services
        };
        use crate::services::domain::{
            ITestExecutionEngine, TestExecutionEngine,
            IChannelStateManager, ChannelStateManager,
            ITestRecordService, TestRecordService,
            // ... other domain services
        };
        use crate::services::infrastructure::persistence::{
            IPersistenceService, SqliteOrmPersistenceService, // ä¸»è¦çš„ORMå®ç°
            MockPersistenceService, // å¯èƒ½ç”¨äºç‰¹å®šæµ‹è¯•é…ç½®
        };
        use crate::services::infrastructure::plc::{
            IPlcCommunicationService, ModbusPlcService, // ç¤ºä¾‹PLCæœåŠ¡
            MockPlcCommunicationService,
        };

        pub struct AppState {
            pub persistence_service: Arc<dyn IPersistenceService>,
            pub test_record_service: Arc<dyn ITestRecordService>,
            pub data_management_service: Arc<dyn IDataManagementService>,
            // ... other service fields
        }

        impl AppState {
            pub async fn new() -> Self { // æ”¹ä¸ºå¼‚æ­¥ä»¥æ”¯æŒå¼‚æ­¥åˆå§‹åŒ–ï¼Œå¦‚æ•°æ®åº“è¿æ¥
                // 1. åˆå§‹åŒ–æŒä¹…åŒ–æœåŠ¡ (ORM + SQLite)
                // è·¯å¾„åº”ä»é…ç½®æˆ–Tauri APIè·å–
                let db_path = "fat_test_app.sqlite"; // ç¤ºä¾‹æ•°æ®åº“æ–‡ä»¶å
                let persistence_service = Arc::new(
                    SqliteOrmPersistenceService::new(db_path).await.expect("Failed to initialize DB")
                );

                // 2. åˆå§‹åŒ–ä¾èµ–æŒä¹…åŒ–æœåŠ¡çš„å…¶ä»–æœåŠ¡
                let test_record_service = Arc::new(TestRecordService::new(persistence_service.clone()));
                let data_management_service = Arc::new(DataManagementService::new(persistence_service.clone()));
                
                // ... åˆå§‹åŒ–å…¶ä»–æœåŠ¡ï¼ŒæŒ‰ä¾èµ–é¡ºåº

                Self {
                    persistence_service,
                    test_record_service,
                    data_management_service,
                    // ...
                }
            }
        }
        ```
    2.  åœ¨ `src/main.rs` ä¸­ï¼Œå¼‚æ­¥åˆ›å»º `AppState` å®ä¾‹å¹¶åœ¨ `tauri::Builder` ä¸­ `manage` å®ƒã€‚
        ```rust
        // Example in src/main.rs
        // #[cfg_attr(not(debug_assertions), windows_subsystem = "windows")] // Release build: hide console

        mod models;
        mod services;
        mod state;
        mod commands;
        mod utils; // for AppError

        use state::app_state::AppState;

        #[tokio::main] // å¦‚æœAppState::newæ˜¯å¼‚æ­¥çš„
        async fn main() {
            // åˆå§‹åŒ–æ—¥å¿—ç­‰

            let app_state = AppState::new().await; // å¼‚æ­¥åˆ›å»º

            tauri::Builder::default()
                .manage(app_state) // æ³¨å…¥ AppState
                .invoke_handler(tauri::generate_handler![
                    // åˆ—å‡ºæ‰€æœ‰Tauri commands
                    // commands::core_commands::example_command,
                    // commands::data_management_commands::import_definitions_cmd,
                    // ...
                ])
                .setup(|app| {
                    // å¯åœ¨æ­¤å¤„è·å– AppHandle ä»¥ä¾¿æœåŠ¡å†…éƒ¨å‘é€äº‹ä»¶
                    // let handle = app.handle();
                    // app_state.notification_service.set_app_handle(handle); // å‡è®¾æœ‰è¿™æ ·çš„æ–¹æ³•
                    Ok(())
                })
                .run(tauri::generate_context!())
                .expect("error while running tauri application");
        }
        ```
    3.  ç¡®ä¿æ‰€æœ‰éœ€è¦è®¿é—®æœåŠ¡çš„ `command` å‡½æ•°éƒ½é€šè¿‡ `tauri::State<AppState>` å‚æ•°è·å–æœåŠ¡å®ä¾‹ã€‚
*   **å¦‚ä½•æµ‹è¯• (How to Test)**:
    *   **ç¼–å†™ç®€å•çš„Tauri Command**: åˆ›å»ºä¸€ä¸ªæµ‹è¯•ç”¨çš„Tauri commandï¼Œå®ƒæ¥æ”¶ `tauri::State<AppState>`ï¼Œå¹¶å°è¯•è°ƒç”¨ `AppState` ä¸­æŸä¸ªæœåŠ¡çš„ä¸€ä¸ªç®€å•æ–¹æ³•ã€‚ä»å‰ç«¯ï¼ˆæˆ–ä½¿ç”¨ `curl` å¦‚æœTauri HTTP APIæš´éœ²ï¼‰è°ƒç”¨æ­¤commandï¼ŒéªŒè¯æ˜¯å¦æˆåŠŸæ‰§è¡Œå¹¶è¿”å›é¢„æœŸç»“æœã€‚
    *   **æ—¥å¿—ç¡®è®¤**: åœ¨commandå’ŒæœåŠ¡æ–¹æ³•ä¸­æ·»åŠ æ—¥å¿—ï¼Œç¡®è®¤æœåŠ¡å®ä¾‹è¢«æ­£ç¡®è®¿é—®ã€‚

### (å®Œæˆ)æ­¥éª¤ 3.4: å®ç°æ ¸å¿ƒä¸šåŠ¡æµç¨‹çš„ Tauri Commands

*   **åŸå›  (Reason)**:
    *   å°†åç«¯æ ¸å¿ƒä¸šåŠ¡æµç¨‹é€šè¿‡Tauri Commandæš´éœ²å‡ºæ¥ï¼Œæ˜¯å‰ç«¯èƒ½å¤Ÿè°ƒç”¨è¿™äº›åŠŸèƒ½çš„å‰æã€‚
*   **æœŸæœ›æ•ˆæœ (Expected Outcome)**:
    *   ä¸ºæ¶æ„æ–‡æ¡£å’Œæœ¬å®æ–½è®¡åˆ’ä¸­æ¶‰åŠçš„å…³é”®ä¸šåŠ¡æµç¨‹ï¼ˆå¯¼å…¥ã€å‡†å¤‡æ‰¹æ¬¡ã€å¼€å§‹æµ‹è¯•ã€è·å–çŠ¶æ€ã€æ‰‹åŠ¨æµ‹è¯•ç­‰ï¼‰åˆ›å»ºå¯¹åº”çš„Tauri commandå‡½æ•°ã€‚
    *   æ¯ä¸ªcommandå‡½æ•°åº”:
        *   æ¥æ”¶æ¥è‡ªå‰ç«¯çš„å‚æ•° (å¦‚æ–‡ä»¶è·¯å¾„ã€æ‰¹æ¬¡IDã€å®ä¾‹IDã€ç”¨æˆ·è¾“å…¥ç­‰)ã€‚
        *   é€šè¿‡ `tauri::State<AppState>` è·å–ç›¸åº”çš„åº”ç”¨æœåŠ¡å®ä¾‹ã€‚
        *   è°ƒç”¨æœåŠ¡å®ä¾‹çš„æ–¹æ³•æ¥æ‰§è¡Œä¸šåŠ¡é€»è¾‘ã€‚
        *   å°†æœåŠ¡æ–¹æ³•è¿”å›çš„ `Result<T, AppError>` è½¬æ¢ä¸ºå‰ç«¯æœŸæœ›çš„ `Result<T_Serializable, String>`ã€‚
    *   åœ¨ `tauri::Builder::invoke_handler` ä¸­æ³¨å†Œæ‰€æœ‰è¿™äº›commandsã€‚
    *   **ç›¸å…³æ•°æ®æ¨¡å‹ (Rust, for Command Payloads/Responses, in `commands.rs` or `payloads.rs`):**
        ```rust
        use crate::models::enums::SubTestItem;
        use crate::models::structs::{TestBatchInfo, ChannelTestInstance, RawTestOutcome};
        use crate::models::payloads::BatchDetailsPayload; // Assuming BatchDetailsPayload is defined elsewhere
        use serde::{Serialize, Deserialize};
        use std::collections::HashMap;

        #[derive(Debug, Clone, Serialize, Deserialize)]
        pub struct ImportExcelAndPrepareBatchCmdArgs {
            pub file_path_str: String, 
            pub product_model: Option<String>,
            pub serial_number: Option<String>,
        }
        // è¿”å›å€¼ä½¿ç”¨ BatchDetailsPayload or a specific response struct
        // Example of specific response struct:
        #[derive(Debug, Clone, Serialize, Deserialize)]
        pub struct ImportAndPrepareBatchResponse {
             pub batch_info: TestBatchInfo,
             pub instances: Vec<ChannelTestInstance>,
        }
        // Command: Result<ImportAndPrepareBatchResponse, String>

        #[derive(Debug, Clone, Serialize, Deserialize)]
        pub struct StartTestsForBatchCmdArgs {
            pub batch_id: String,
        }
        // Command: Result<(), String>

        #[derive(Debug, Clone, Serialize, Deserialize)]
        pub struct GetBatchStatusCmdArgs {
            pub batch_id: String,
        }
        // Command: Result<BatchDetailsPayload, String>

        #[derive(Debug, Clone, Serialize, Deserialize)]
        pub struct ExecuteManualSubTestCmdArgs {
            pub instance_id: String, 
            pub sub_test_item: SubTestItem,
            pub params: Option<HashMap<String, serde_json::Value>>
        }
        // Command: Result<RawTestOutcome, String>
        
        #[derive(Debug, Clone, Serialize, Deserialize)]
        pub struct ReadChannelValueCmdArgs { // For manual read
            pub instance_id: String,
            //pub definition_id: String, // Or pass enough context to find the address
            pub plc_address: String, // Specific address to read
            pub data_type: crate::models::enums::PointDataType, // Expected data type
        }
        // Command: Result<serde_json::Value, String>

        #[derive(Debug, Clone, Serialize, Deserialize)]
        pub struct WriteChannelValueCmdArgs { // For manual write
            pub instance_id: String, 
            //pub definition_id: String,
            pub plc_address: String, // Specific address to write
            pub data_type: crate::models::enums::PointDataType,
            pub value_to_write: serde_json::Value,
        }
        // Command: Result<(), String>
        ```
*   **å®æ–½æè¿° (Implementation Description)**:
    1.  åˆ›å»ºä¸€ä¸ª `src-tauri/src/commands.rs` (æˆ–å¤šä¸ª) æ–‡ä»¶æ¥ç»„ç»‡commandå‡½æ•°ã€‚
    2.  **ç¤ºä¾‹ Command (`import_excel_and_prepare_batch_cmd`)**:
        ```rust
        // src-tauri/src/commands.rs
        use crate::AppState;
        // Assuming command-specific arg/response structs are defined (e.g., in a sub-module or payloads.rs)
        use crate::models::payloads::{ImportExcelAndPrepareBatchCmdArgs, ImportAndPrepareBatchResponse, BatchDetailsPayload, /* other command args/responses */ }; 
        use crate::models::{TestBatchInfo, ChannelTestInstance, ChannelPointDefinition}; // Core models from within the crate
        use crate::utils::error::AppError; // Assuming AppError is in utils::error module
        use std::path::PathBuf;

        #[tauri::command]
        pub async fn import_excel_and_prepare_batch_cmd(
            args: ImportExcelAndPrepareBatchCmdArgs, 
            state: tauri::State<'_, AppState>
        ) -> Result<ImportAndPrepareBatchResponse, String> { // Using specific response struct
            let file_path = PathBuf::from(args.file_path_str);
            
            let (definitions, extracted_batch_info) = state.data_management_service
                .import_channel_definitions_from_excel(file_path).await
                .map_err(|e| e.to_string())?;

            let batch_to_create = extracted_batch_info.unwrap_or_else(|| TestBatchInfo {
                batch_id: uuid::Uuid::new_v4().to_string(),
                product_model: args.product_model,
                serial_number: args.serial_number,
                ..Default::default()
            });

            let test_batch_info = state.test_orchestration_service
                .create_test_batch(batch_to_create.product_model, batch_to_create.serial_number).await
                .map_err(|e| e.to_string())?;

            let definition_ids: Vec<String> = definitions.iter().map(|d| d.id.clone()).collect();
            // Assuming prepare_test_instances_for_batch is modified or a new method prepares based on full definitions
            let instances = state.test_orchestration_service
                .prepare_test_instances_for_batch_from_defs(&test_batch_info.batch_id, definitions).await // Hypothetical method
                .map_err(|e| e.to_string())?;
            
            Ok(ImportAndPrepareBatchResponse { batch_info: test_batch_info, instances })
        }
        
        // Implement other commands similarly using their respective Arg and Response structs
        #[tauri::command]
        pub async fn start_tests_for_batch_cmd(
            args: StartTestsForBatchCmdArgs,
            state: tauri::State<'_, AppState>
        ) -> Result<(), String> {
            state.test_orchestration_service.start_tests_for_batch(&args.batch_id).await.map_err(|e| e.to_string())
        }

        #[tauri::command]
        pub async fn get_batch_status_cmd(
            args: GetBatchStatusCmdArgs,
            state: tauri::State<'_, AppState>
        ) -> Result<BatchDetailsPayload, String> { // Using BatchDetailsPayload directly
            state.test_orchestration_service.get_batch_status_and_instances(&args.batch_id).await.map_err(|e| e.to_string())
        }

        // ... other commands: execute_manual_sub_test_cmd, etc.
        ```
    3.  å®ç°å…¶ä»–æ ¸å¿ƒæµç¨‹çš„Tauri Commandsï¼Œå¦‚ `execute_manual_sub_test_cmd` ç­‰ï¼Œå®ƒä»¬åˆ†åˆ«è°ƒç”¨ `ITestOrchestrationService` å’Œ `IManualTestService` çš„æ–¹æ³•ã€‚
    4.  åœ¨ `src-tauri/src/main.rs` ä¸­æ³¨å†Œè¿™äº›commands:
        ` .invoke_handler(tauri::generate_handler![import_excel_and_prepare_batch_cmd, start_tests_for_batch_cmd, get_batch_status_cmd, /* more commands */])`
*   **å¦‚ä½•æµ‹è¯• (How to Test)**:
    *   **Tauri DevTools + å‰ç«¯å ä½ç¬¦**: (å¦‚æœå‰ç«¯è¿˜æ˜¯ç®€å•é¡µé¢)
        *   åœ¨Tauriåº”ç”¨çš„Webviewä¸­æ‰“å¼€å¼€å‘è€…å·¥å…·ã€‚
        *   åœ¨æ§åˆ¶å°ä½¿ç”¨ `window.__TAURI__.invoke('command_name', { param1: value1 })` æ¥æ‰‹åŠ¨è°ƒç”¨Tauri commandsã€‚
        *   æ£€æŸ¥æ§åˆ¶å°è¾“å‡ºçš„ `Promise` è§£æç»“æœæ˜¯å¦ç¬¦åˆé¢„æœŸï¼ˆæˆåŠŸæ—¶çš„æ•°æ®ï¼Œå¤±è´¥æ—¶çš„é”™è¯¯å­—ç¬¦ä¸²ï¼‰ã€‚
        *   æ£€æŸ¥åç«¯Rustæ§åˆ¶å°çš„æ—¥å¿—è¾“å‡ºï¼Œç¡®è®¤æœåŠ¡æ–¹æ³•è¢«è°ƒç”¨ï¼Œé€»è¾‘æŒ‰é¢„æœŸæ‰§è¡Œã€‚
    *   **è‡ªåŠ¨åŒ–APIæµ‹è¯•å·¥å…· (å¦‚æœå¯èƒ½)**: å¦‚æœTauriçš„HTTP Serverè¢«å¯ç”¨ï¼ˆé»˜è®¤ä¸ç”¨äºIPCï¼‰ï¼Œå¯ä»¥ä½¿ç”¨Postmanæˆ–ç±»ä¼¼å·¥å…·æµ‹è¯•ã€‚ä½†é€šå¸¸IPCæµ‹è¯•æ›´ä¾èµ–å‰ç«¯äº¤äº’æˆ–ç‰¹å®šæµ‹è¯•è„šæœ¬ã€‚
    *   **ç«¯åˆ°ç«¯æµç¨‹æ¨¡æ‹Ÿ**: é€šè¿‡æ‰‹åŠ¨è°ƒç”¨ä¸€ç³»åˆ—Tauri commandsæ¥æ¨¡æ‹Ÿä¸€ä¸ªå®Œæ•´çš„ä¸šåŠ¡æµç¨‹ï¼Œä¾‹å¦‚ï¼š
        1.  `import_excel_and_prepare_batch_cmd` (ä½¿ç”¨ä¸€ä¸ªæµ‹è¯•Excelæ–‡ä»¶)ã€‚
        2.  `confirm_wiring_cmd` (ä½¿ç”¨ä¸Šä¸€æ­¥è¿”å›çš„ `batch_id`)ã€‚
        3.  `start_tests_for_batch_cmd`ã€‚
        4.  å¤šæ¬¡è°ƒç”¨ `get_batch_status_cmd` è§‚å¯ŸçŠ¶æ€å˜åŒ– (æ­¤æ—¶éœ€è¦ `MockTestExecutionEngine` æ¨¡æ‹Ÿå‘é€ `RawTestOutcome` ç»™ `TestOrchestrationService` çš„å†…éƒ¨å¾ªç¯ï¼Œè¿™ä¸ªå¾ªç¯å†é€šè¿‡ `MockChannelStateManager` æ›´æ–°çŠ¶æ€)ã€‚
        *   è¿™ä¸€æ­¥çš„æµ‹è¯•ä¼šæ¯”è¾ƒå¤æ‚ï¼Œå› ä¸ºå®ƒä¾èµ–äºPhase 2ä¸­ `TestOrchestrationService` å†…éƒ¨äº‹ä»¶å¾ªç¯å’ŒçŠ¶æ€æ›´æ–°çš„æ­£ç¡®æ€§ï¼Œä»¥åŠæ‰€æœ‰MockæœåŠ¡çš„ååŒå·¥ä½œã€‚

### (å®Œæˆ)æ­¥éª¤ 3.5: å®ç°åç«¯åˆ°å‰ç«¯çš„äº‹ä»¶é€šçŸ¥æœºåˆ¶ (Tauri Events)

*   **åŸå›  (Reason)**:
    *   è®¸å¤šæ“ä½œï¼ˆå¦‚æµ‹è¯•è¿›åº¦ã€å•ç‚¹çŠ¶æ€æ›´æ–°ï¼‰éœ€è¦ä»åç«¯å®æ—¶é€šçŸ¥å‰ç«¯ï¼Œè€Œä¸æ˜¯å‰ç«¯è½®è¯¢ã€‚
*   **æœŸæœ›æ•ˆæœ (Expected Outcome)**:
    *   åœ¨ `TestOrchestrationService` (æˆ–å…¶ä»–éœ€è¦å‘äº‹ä»¶çš„æœåŠ¡) ä¸­ï¼Œå½“å…³é”®çŠ¶æ€å˜åŒ–æ—¶ï¼ˆå¦‚ `ChannelTestInstance` çŠ¶æ€æ›´æ–°ï¼Œæ‰¹æ¬¡è¿›åº¦æ›´æ–°ï¼‰ï¼Œèƒ½å¤Ÿé€šè¿‡ `tauri::AppHandle.emit_all` å‘é€äº‹ä»¶ç»™å‰ç«¯ã€‚
    *   å®šä¹‰æ¸…æ™°çš„äº‹ä»¶åç§° (e.g., `"channel_state_changed"`, `"batch_progress_update"`, `"log_message_event"`) å’Œå¯¹åº”çš„Payloadç»“æ„ä½“ (éœ€ `Serialize`)ã€‚
    *   **äº‹ä»¶Payloadå®šä¹‰ (Rust, in `models/payloads.rs` or a dedicated `events.rs`):**
        ```rust
        use crate::models::structs::{ChannelTestInstance, TestBatchInfo}; // Or specific fields from them
        use crate::models::enums::OverallTestStatus;
        use serde::{Serialize, Deserialize};
        use chrono::{DateTime, Utc};

        #[derive(Debug, Clone, Serialize, Deserialize)]
        pub struct ChannelStateChangedEventPayload {
            pub batch_id: String,
            pub instance_id: String,
            // å¯ä»¥åªå‘é€æ›´æ–°åçš„å®ä¾‹ï¼Œæˆ–è€…æ›´ç»†ç²’åº¦çš„å˜æ›´ä¿¡æ¯
            pub updated_instance: ChannelTestInstance, 
        }

        #[derive(Debug, Clone, Serialize, Deserialize)]
        pub struct BatchProgressEventPayload {
            pub batch_id: String,
            pub tested_points: u32,
            pub total_points: u32,
            pub passed_points: u32,
            pub failed_points: u32,
            pub skipped_points: u32,
            pub overall_batch_status: OverallTestStatus,
            pub status_summary: Option<String>, // Optional: A human-readable summary string
        }

        #[derive(Debug, Clone, Serialize, Deserialize)]
        pub enum LogLevelEvent {
            Info,
            Warn,
            Error,
            Debug,
        }

        #[derive(Debug, Clone, Serialize, Deserialize)]
        pub struct LogMessageEventPayload {
            pub timestamp: DateTime<Utc>,
            pub level: LogLevelEvent,
            pub message: String,
            pub module_path: Option<String>, // e.g., "crate::services::application::test_orchestration_service"
        }
        ```
    *   å‰ç«¯ (å³ä½¿æ˜¯å ä½ç¬¦é¡µé¢) èƒ½å¤Ÿé€šè¿‡ `tauri-apps/api/event.listen` æ¥æ”¶åˆ°è¿™äº›äº‹ä»¶å¹¶æ‰“å°å…¶Payloadã€‚
*   **å®æ–½æè¿° (Implementation Description)**:
    1.  ç¡®ä¿ `TestOrchestrationService` (æˆ–å…¶ä»–å‘äº‹ä»¶çš„æœåŠ¡) èƒ½å¤Ÿè®¿é—® `tauri::AppHandle`ã€‚
        *   å¯ä»¥åœ¨ `main` å‡½æ•°ä¸­ `tauri::Builder::default().setup(|app| { ... })` é’©å­ä¸­è·å– `app.handle()`ï¼Œå¹¶å°†å…¶ä¼ é€’/è®¾ç½®åˆ°æœåŠ¡å®ä¾‹ä¸­ï¼ˆéœ€è¦æœåŠ¡è®¾è®¡ä¸ºå¯æ¥æ”¶ `AppHandle`ï¼Œå¯èƒ½é€šè¿‡ `Option<AppHandle>` å­—æ®µå’Œåˆå§‹åŒ–æ–¹æ³•ï¼‰ã€‚
    2.  åœ¨ `TestOrchestrationService` ä¸­å¤„ç† `RawTestOutcome` çš„å¾ªç¯å†…éƒ¨ï¼Œå½“ `ChannelTestInstance` çŠ¶æ€è¢« `ChannelStateManager` æ›´æ–°åï¼Œæˆ–æ‰¹æ¬¡ç»Ÿè®¡æ›´æ–°å:
        ```rust
        // In TestOrchestrationService, after instance state is updated
        // Assuming payloads are defined in e.g. crate::models::events::* 
        use crate::models::events::{ChannelStateChangedEventPayload, BatchProgressEventPayload};

        if let Some(handle) = &self.app_handle { // Assuming self.app_handle: Option<tauri::AppHandle>
            let event_payload = ChannelStateChangedEventPayload {
                batch_id: updated_instance.batch_id.clone(),
                instance_id: updated_instance.instance_id.clone(),
                updated_instance: updated_instance.clone(),
            };
            if let Err(e) = handle.emit_all("fat://channel_state_changed", event_payload) { // Using custom event name
                error!("Failed to emit channel_state_changed event: {}", e);
            }

            // After batch statistics are updated (e.g., in TestBatchInfo)
            let batch_progress_payload = BatchProgressEventPayload {
                batch_id: current_batch_info.batch_id.clone(),
                tested_points: current_batch_info.tested_points,
                total_points: current_batch_info.total_points,
                passed_points: current_batch_info.passed_points,
                failed_points: current_batch_info.failed_points,
                skipped_points: current_batch_info.skipped_points,
                overall_batch_status: current_batch_info.overall_status, // Assuming TestBatchInfo now has this
                status_summary: current_batch_info.status_summary.clone(),
            };
            if let Err(e) = handle.emit_all("fat://batch_progress_update", batch_progress_payload) {
                error!("Failed to emit batch_progress_update event: {}", e);
            }
        }
        ```
    3.  (å¦‚æœå®ç°å…¨å±€æ—¥å¿—æ¨é€) åœ¨æ—¥å¿—ç³»ç»Ÿçš„å®ç°ä¸­ï¼Œå½“æ•è·åˆ°æ—¥å¿—æ¡ç›®æ—¶ï¼Œæ„å»º `LogMessageEventPayload` å¹¶é€šè¿‡ `AppHandle` å‘é€ `"fat://log_message"` äº‹ä»¶ã€‚
    4.  åœ¨å‰ç«¯çš„ç®€å•JSä¸­ (Tauriæ¨¡æ¿è‡ªå¸¦çš„ `main.js` æˆ–ä¸€ä¸ªç®€å•HTMLçš„ `<script>` æ ‡ç­¾å†…):
        ```javascript
        // Using global tauri functions if in simple HTML/JS page
        const { listen } = window.__TAURI__.event;

        async function setupEventListeners() {
            await listen('fat://channel_state_changed', (event) => {
                console.log('Event: channel_state_changed', event.payload);
            });
            await listen('fat://batch_progress_update', (event) => {
                console.log('Event: batch_progress_update', event.payload);
            });
            await listen('fat://log_message', (event) => {
                console.log('Log [' + event.payload.level + ']: ' + event.payload.message, event.payload);
            });
            console.log('Tauri event listeners set up.');
        }
        setupEventListeners();
        ```
*   **å¦‚ä½•æµ‹è¯• (How to Test)**:
    *   **å‰ç«¯æ§åˆ¶å°æ—¥å¿—**: è¿è¡ŒTauriåº”ç”¨ã€‚é€šè¿‡è°ƒç”¨Tauri Commandè§¦å‘åç«¯é€»è¾‘ï¼ˆå¦‚ `start_tests_for_batch_cmd`ï¼Œå®ƒå†…éƒ¨ä¼šæ›´æ–°çŠ¶æ€å¹¶åº”å‘é€äº‹ä»¶ï¼‰ã€‚
    *   è§‚å¯Ÿå‰ç«¯Webviewå¼€å‘è€…å·¥å…·çš„æ§åˆ¶å°ï¼Œç¡®è®¤æ˜¯å¦æ”¶åˆ°äº† `channel_state_changed` ç­‰äº‹ä»¶ï¼Œå¹¶ä¸”Payloadå†…å®¹æ­£ç¡®ã€‚
    *   **åç«¯æ—¥å¿—**: ç¡®è®¤åç«¯æœåŠ¡ä¸­ `emit_all` è°ƒç”¨æˆåŠŸï¼Œæ²¡æœ‰é”™è¯¯æ—¥å¿—ã€‚
    *   æµ‹è¯•ä¸åŒç±»å‹çš„äº‹ä»¶å’ŒPayloadã€‚

---

## Phase 4: å‰ç«¯ (Angular) åŸºç¡€æ­å»ºä¸åˆæ­¥é›†æˆ

**ç›®æ ‡ï¼š** æ­å»º Angular å‰ç«¯é¡¹ç›®ï¼Œå®ç°ä¸ Tauri åç«¯çš„åŸºæœ¬é€šä¿¡ï¼ˆè°ƒç”¨Commandsï¼Œç›‘å¬Eventsï¼‰ï¼Œå¹¶æ„å»ºæ ¸å¿ƒé¡µé¢å’Œç»„ä»¶çš„éª¨æ¶ï¼Œä¸ºå®ç°å®Œæ•´åŠŸèƒ½åšå‡†å¤‡ã€‚

### (å®Œæˆ)æ­¥éª¤ 4.1: åˆå§‹åŒ– Angular é¡¹ç›®å¹¶é›†æˆåˆ° Tauri

*   **åŸå›  (Reason)**:
    *   Angular å°†ä½œä¸ºå‰ç«¯ UI æ¡†æ¶ã€‚
    *   éœ€è¦å°† Angular é¡¹ç›®æ­£ç¡®é…ç½®ä¸º Tauri åº”ç”¨çš„å‰ç«¯éƒ¨åˆ†ã€‚
*   **æœŸæœ›æ•ˆæœ (Expected Outcome)**:
    *   åœ¨ Tauri é¡¹ç›®çš„æ ¹ç›®å½•ä¸‹ (ä¸ `src-tauri` åŒçº§) åˆ›å»ºä¸€ä¸ªæ–°çš„ Angular é¡¹ç›® (e.g., `fat_test_frontend`)ã€‚
    *   é…ç½® `tauri.conf.json` ä¸­çš„ `build.devPath` å’Œ `build.distDir` ä»¥æŒ‡å‘ Angular å¼€å‘æœåŠ¡å™¨å’Œæ„å»ºè¾“å‡ºç›®å½•ã€‚
    *   èƒ½å¤Ÿé€šè¿‡ `npm run tauri dev` åŒæ—¶å¯åŠ¨ Rust åç«¯å’Œ Angular å¼€å‘æœåŠ¡å™¨ï¼Œå¹¶åœ¨ Tauri çª—å£ä¸­çœ‹åˆ° Angular åº”ç”¨çš„é»˜è®¤é¡µé¢ã€‚
    *   Angular é¡¹ç›®ä¸­å®‰è£… `@tauri-apps/api`ã€‚
*   **å®æ–½æè¿° (Implementation Description)**:
    1.  åœ¨ Tauri é¡¹ç›®çš„æ ¹ç›®å½•ä¸‹ï¼Œä½¿ç”¨ Angular CLI åˆ›å»ºæ–°é¡¹ç›®: `ng new fat_test_frontend --routing --style=scss` (æˆ–æ ¹æ®å–œå¥½é€‰æ‹©)ã€‚
    2.  è¿›å…¥ `fat_test_frontend` ç›®å½•ï¼Œå®‰è£… Tauri API: `npm install @tauri-apps/api`ã€‚
    3.  **é…ç½® `tauri.conf.json`** (ä½äº `src-tauri/tauri.conf.json`):
        *   `build.devPath`: é€šå¸¸æ˜¯ Angular å¼€å‘æœåŠ¡å™¨çš„åœ°å€ï¼Œé»˜è®¤ä¸º `http://localhost:4200`ã€‚æ£€æŸ¥ `fat_test_frontend/angular.json` ä¸­ `serve.options.port` çš„è®¾ç½®ã€‚
        *   `build.distDir`: Angular æ„å»ºè¾“å‡ºçš„ç›®å½•ï¼Œç›¸å¯¹äº `tauri.conf.json` çš„è·¯å¾„ã€‚é€šå¸¸æ˜¯ `../fat_test_frontend/dist/fat_test_frontend` (å…·ä½“è·¯å¾„å–å†³äº Angular é¡¹ç›®åå’Œ `angular.json` ä¸­çš„ `outputPath` é…ç½®)ã€‚
        *   `build.beforeDevCommand`: è®¾ç½®ä¸º `"npm run --prefix ../fat_test_frontend start"` (æˆ– `yarn --cwd ../fat_test_frontend start`)ï¼Œä»¥ä¾¿ `tauri dev` è‡ªåŠ¨å¯åŠ¨ Angular å¼€å‘æœåŠ¡å™¨ã€‚
        *   `build.beforeBuildCommand`: è®¾ç½®ä¸º `"npm run --prefix ../fat_test_frontend build"` (æˆ– `yarn --cwd ../fat_test_frontend build`)ï¼Œä»¥ä¾¿ `tauri build` è‡ªåŠ¨æ„å»º Angular åº”ç”¨ã€‚
    4.  **ä¿®æ”¹ Angular `package.json`** (`fat_test_frontend/package.json`):
        *   ä¿®æ”¹ `scripts.start` ä¸º `ng serve` (å¦‚æœåŸæ¥æ˜¯ `ng serve --open`ï¼Œå»æ‰ `--open`)ã€‚
        *   ä¿®æ”¹ `scripts.build` ä¸º `ng build` (ç¡®ä¿ç”Ÿæˆåˆ°æ­£ç¡®çš„ `distDir`)ã€‚
    5.  è¿è¡Œ `npm run tauri dev` ä»é¡¹ç›®æ ¹ç›®å½•å¯åŠ¨ï¼ŒéªŒè¯ Tauri çª—å£åŠ è½½äº† Angular åº”ç”¨ã€‚
*   **å¦‚ä½•æµ‹è¯• (How to Test)**:
    *   **æˆåŠŸè¿è¡Œ**: `npm run tauri dev` å¯åŠ¨åï¼ŒTauri çª—å£æ˜¾ç¤º Angular çš„æ¬¢è¿é¡µé¢ã€‚
    *   **çƒ­é‡è½½**: ä¿®æ”¹ Angular ç»„ä»¶çš„ HTML æˆ– TS æ–‡ä»¶ï¼ŒTauri çª—å£ä¸­çš„å†…å®¹åº”è‡ªåŠ¨æ›´æ–°ã€‚
    *   **æ§åˆ¶å°æ— é”™è¯¯**: Rust æ§åˆ¶å°å’Œæµè§ˆå™¨æ§åˆ¶å°éƒ½æ²¡æœ‰ä¸Tauriæˆ–Angularé›†æˆç›¸å…³çš„æ˜æ˜¾é”™è¯¯ã€‚

### (å®Œæˆ)æ­¥éª¤ 4.2: åˆ›å»º Angular æ ¸å¿ƒæœåŠ¡ä»¥å°è£… Tauri é€šä¿¡

*   **åŸå›  (Reason)**:
    *   å°†ä¸ Tauri åç«¯çš„ç›´æ¥äº¤äº’ (invoke commands, listen to events) å°è£…åœ¨ Angular æœåŠ¡ä¸­ï¼Œå¯ä»¥ä½¿ç»„ä»¶ä»£ç æ›´ç®€æ´ã€æ›´æ˜“äºæµ‹è¯•ï¼Œå¹¶æä¾›ä¸€ä¸ªç»Ÿä¸€çš„ API ä¾›å…¶ä»–ç»„ä»¶ä½¿ç”¨ã€‚
*   **æœŸæœ›æ•ˆæœ (Expected Outcome)**:
    *   åˆ›å»º Angular æœåŠ¡ï¼Œå¦‚ `BackendCommsService` (æˆ–æ›´å…·ä½“çš„å¦‚ `TestOrchestrationApiService`, `DataManagementApiService`)ã€‚
    *   è¿™äº›æœåŠ¡å°†ä½¿ç”¨ `@tauri-apps/api/tauri` çš„ `invoke` å‡½æ•°æ¥è°ƒç”¨åç«¯ Tauri Commandsã€‚
    *   è¿™äº›æœåŠ¡å°†ä½¿ç”¨ `@tauri-apps/api/event` çš„ `listen` å’Œ `emit` å‡½æ•°æ¥å¤„ç†åç«¯äº‹ä»¶ã€‚
    *   æœåŠ¡æ–¹æ³•åº”è¿”å› `Promise<T>` æˆ– `Observable<T>`ï¼Œå¹¶å¤„ç†æ¥è‡ªåç«¯çš„é”™è¯¯ã€‚
    *   **å‰ç«¯æ•°æ®æ¨¡å‹ (TypeScript Interfaces, in `src/app/models/` or similar):**
        *   éœ€è¦ä¸ºæ‰€æœ‰é€šè¿‡Tauri Commandså‚æ•°ä¼ é€’ã€æˆ–ä½œä¸ºè¿”å›å€¼æ¥æ”¶ã€æˆ–é€šè¿‡Tauri Eventsçš„Payloadæ¥æ”¶çš„Rustæ•°æ®ç»“æ„ï¼Œåœ¨Angularå‰ç«¯åˆ›å»ºå¯¹åº”çš„TypeScriptæ¥å£ã€‚
        *   è¿™äº›TSæ¥å£çš„ç»“æ„ï¼ˆå­—æ®µåã€ç±»å‹ï¼‰å¿…é¡»ä¸Rustç»“æ„ä½“ç»è¿‡`serde`åºåˆ—åŒ–åçš„JSONæ ¼å¼å®Œå…¨å¯¹åº”ã€‚
        *   **ä¸»è¦åŒ…æ‹¬ (ä½†ä¸é™äº):**
            *   Enums: `OverallTestStatus`, `SubTestStatus`, `ModuleType`, `PointDataType`, `SubTestItem`, `LogLevelEvent` (TSä¸­é€šå¸¸ç”¨å­—ç¬¦ä¸²å­—é¢é‡è”åˆç±»å‹æˆ–æ•°å­—æšä¸¾å®ç°)ã€‚
            *   Structs: `ChannelPointDefinition`, `ChannelTestInstance`, `SubTestExecutionResult`, `AnalogReadingPoint`, `TestBatchInfo`, `RawTestOutcome`.
            *   Command Args/Response Payloads: `ImportExcelAndPrepareBatchCmdArgs`, `ImportAndPrepareBatchResponse`, `StartTestsForBatchCmdArgs`, `GetBatchStatusCmdArgs`, `BatchDetailsPayload`, `ExecuteManualSubTestCmdArgs`, `ReadChannelValueCmdArgs`, `WriteChannelValueCmdArgs`.
            *   Event Payloads: `ChannelStateChangedEventPayload`, `BatchProgressEventPayload`, `LogMessageEventPayload`.
        *   **å»ºè®®**: å¯ä»¥è€ƒè™‘ä½¿ç”¨å·¥å…·å¦‚ `ts-rs` (Rust crate) è‡ªåŠ¨ä»Rustæ•°æ®ç»“æ„ç”ŸæˆTypeScriptå®šä¹‰ï¼Œä»¥ç¡®ä¿ä¸€è‡´æ€§å¹¶å‡å°‘æ‰‹åŠ¨ç¼–å†™é”™è¯¯ã€‚å¦‚æœæ‰‹åŠ¨ç¼–å†™ï¼ŒåŠ¡å¿…ä»”ç»†æ ¸å¯¹ã€‚
*   **å®æ–½æè¿° (Implementation Description)**:
    1.  ä½¿ç”¨ Angular CLI ç”ŸæˆæœåŠ¡ï¼š
        `ng generate service services/backend-comms` (æˆ–æŒ‰åŠŸèƒ½åˆ’åˆ†ï¼Œå¦‚ `services/test-orchestration-api`)
    2.  **åˆ›å»ºTypeScriptæ¥å£æ–‡ä»¶ (e.g., `src/app/models/backend-models.ts`)**:
        ```typescript
        // src/app/models/backend-models.ts

        // --- Enums (example using string literal union types) ---
        export type OverallTestStatus = 
            | 'NotTested' | 'Testing' | 'Paused' | 'TestCompletedPassed' 
            | 'TestCompletedFailed' | 'Skipped' | 'WiringConfirmationPending' 
            | 'HardPointTestCompleted' | 'Aborted';

        export type SubTestStatus =
            | 'NotTested' | 'Testing' | 'Passed' | 'Failed' 
            | 'Skipped' | 'NotApplicable' | 'Aborted';

        export type ModuleType = 'AI' | 'AO' | 'DI' | 'DO' | 'Custom';
        
        export type PointDataType = 'Bool' | 'Real' | 'Int' | 'DInt' | 'Word' | 'DWord';

        // SubTestItem can be extensive, map carefully or use string
        export type SubTestItem = 
            | 'Communication' | 'WiringConfirmation' | 'HardPoint' // ... and so on
            | string; // Or list all explicitly
        
        export type LogLevelEvent = 'Info' | 'Warn' | 'Error' | 'Debug';

        // --- Structs & Payloads ---
        export interface AnalogReadingPoint {
            timestamp: string; // ISO DateTime string
            set_value_eng?: number | null;
            read_value_eng?: number | null;
            set_value_raw?: any | null;
            read_value_raw?: any | null;
            success: boolean;
            message?: string | null;
        }

        export interface SubTestExecutionResult {
            item: SubTestItem;
            status: SubTestStatus;
            start_time?: string | null; // ISO DateTime string
            end_time?: string | null;   // ISO DateTime string
            duration_ms?: number | null;
            message?: string | null;
            readings: AnalogReadingPoint[];
            details?: { [key: string]: any };
        }

        export interface ChannelPointDefinition {
            id: string;
            tag_name: string;
            description: string;
            module_type: ModuleType;
            plc_node_name_primary?: string | null;
            primary_address_read?: string | null;
            primary_address_write?: string | null;
            primary_data_type?: PointDataType | null;
            // ... other fields from Rust struct, ensure casing (snake_case from Rust -> camelCase in TS by serde default, or match as is)
            // For example, if serde doesn't rename, then: range_low, range_high etc.
            // If serde renames to camelCase: rangeLow, rangeHigh.
            // It's CRUCIAL to match the JSON structure produced by Rust's serde.
            // Assuming no field renaming for simplicity here, matching Rust fields directly.
            eng_unit?: string | null;
            range_low?: number | null;
            range_high?: number | null;
            // ... all other fields
            applicable_sub_tests: SubTestItem[];
            custom_fields: { [key: string]: string };
        }

        export interface ChannelTestInstance {
            instance_id: string;
            channel_definition_id: string;
            batch_id: string;
            overall_status: OverallTestStatus;
            error_message?: string | null;
            creation_time: string; // ISO DateTime string
            last_updated_time: string; // ISO DateTime string
            start_test_time?: string | null;
            final_test_time?: string | null;
            total_test_duration_ms?: number | null;
            sub_test_results: { [key: string /* SubTestItem as string */]: SubTestExecutionResult };
            current_operator?: string | null;
            retries_count: number;
            transient_data?: { [key: string]: any };
        }

        export interface TestBatchInfo {
            batch_id: string;
            product_model?: string | null;
            serial_number?: string | null;
            creation_time: string; // ISO DateTime string
            // ... all other fields, carefully matching Rust TestBatchInfo
            total_points: number;
            tested_points: number;
            passed_points: number;
            failed_points: number;
            skipped_points: number;
            status_summary?: string | null;
            custom_data: { [key: string]: string };
        }

        export interface RawTestOutcome {
            channel_instance_id: string;
            sub_test_item: SubTestItem;
            success: boolean;
            message?: string | null;
            start_time: string; // ISO DateTime string
            end_time: string;   // ISO DateTime string
            readings: AnalogReadingPoint[];
            details?: { [key: string]: any };
        }

        // Command Specific Payloads (Args & Responses)
        export interface ImportExcelAndPrepareBatchCmdArgs {
            file_path_str: string;
            product_model?: string | null;
            serial_number?: string | null;
        }
        export interface ImportAndPrepareBatchResponse {
            batch_info: TestBatchInfo;
            instances: ChannelTestInstance[];
        }

        export interface StartTestsForBatchCmdArgs { batch_id: string; }
        export interface GetBatchStatusCmdArgs { batch_id: string; }
        // Assuming BatchDetailsPayload is defined based on Rust: 
        export interface BatchDetailsPayload {
            batch_info: TestBatchInfo;
            instances: ChannelTestInstance[];
        }

        export interface ExecuteManualSubTestCmdArgs {
            instance_id: string;
            sub_test_item: SubTestItem;
            params?: { [key: string]: any } | null;
        }
        // ReadChannelValueCmdArgs, WriteChannelValueCmdArgs similarly...

        // Event Payloads
        export interface ChannelStateChangedEventPayload {
            batch_id: string;
            instance_id: string;
            updated_instance: ChannelTestInstance;
        }

        export interface BatchProgressEventPayload {
            batch_id: string;
            tested_points: number;
            total_points: number;
            passed_points: number;
            failed_points: number;
            skipped_points: number;
            overall_batch_status: OverallTestStatus;
            status_summary?: string | null;
        }

        export interface LogMessageEventPayload {
            timestamp: string; // ISO DateTime string
            level: LogLevelEvent;
            message: string;
            module_path?: string | null;
        }
        ```
    3.  **`BackendCommsService` (ç¤ºä¾‹ - updated with more specific types)**:
        ```typescript
        // src/app/services/backend-comms.service.ts
        import { Injectable, OnDestroy } from '@angular/core';
        import { invoke } from '@tauri-apps/api/tauri';
        import { listen, Event as TauriEvent, UnlistenFn } from '@tauri-apps/api/event';
        import { Observable, Subject } from 'rxjs';
        import { 
            TestBatchInfo, ChannelTestInstance, ChannelStateChangedEventPayload, 
            ImportExcelAndPrepareBatchCmdArgs, ImportAndPrepareBatchResponse,
            StartTestsForBatchCmdArgs, GetBatchStatusCmdArgs, BatchDetailsPayload,
            ExecuteManualSubTestCmdArgs, RawTestOutcome 
            // ... import other TS models as needed
        } from '../models/backend-models'; // Adjust path as needed

        @Injectable({
            providedIn: 'root'
        })
        export class BackendCommsService implements OnDestroy {
            private channelStateChangedSubject = new Subject<ChannelStateChangedEventPayload>();
            public channelStateChanged$: Observable<ChannelStateChangedEventPayload> = this.channelStateChangedSubject.asObservable();
            // Other event subjects and observables...

            private unlistenFns: UnlistenFn[] = [];

            constructor() {
                this.listenToAllEvents();
            }

            async importExcelAndPrepareBatch(args: ImportExcelAndPrepareBatchCmdArgs):
                Promise<ImportAndPrepareBatchResponse> {
                try {
                    // Note: Rust command might return a tuple [TestBatchInfo, ChannelTestInstance[]]
                    // which needs to be mapped to ImportAndPrepareBatchResponse if not directly returned as such.
                    // The example Rust command for import_excel_and_prepare_batch_cmd was updated to return ImportAndPrepareBatchResponse.
                    return await invoke<ImportAndPrepareBatchResponse>('import_excel_and_prepare_batch_cmd', args);
                } catch (error) {
                    console.error('Error invoking import_excel_and_prepare_batch_cmd:', error);
                    throw error; // Or handle more gracefully
                }
            }

            async startTestsForBatch(args: StartTestsForBatchCmdArgs): Promise<void> {
                try {
                    await invoke<void>('start_tests_for_batch_cmd', args);
                } catch (error) {
                    console.error('Error invoking start_tests_for_batch_cmd:', error);
                    throw error;
                }
            }
            
            async getBatchDetails(args: GetBatchStatusCmdArgs): Promise<BatchDetailsPayload> {
                try {
                    return await invoke<BatchDetailsPayload>('get_batch_status_cmd', args);
                } catch (error) {
                    console.error('Error invoking get_batch_status_cmd:', error);
                    throw error;
                }
            }

            async executeManualSubTest(args: ExecuteManualSubTestCmdArgs): Promise<RawTestOutcome> {
                try {
                    return await invoke<RawTestOutcome>('execute_manual_sub_test_cmd', args);
                } catch (error) {
                    console.error('Error invoking execute_manual_sub_test_cmd:', error);
                    throw error;
                }
            }

            // ... Other Command-calling methods

            private async listenToAllEvents(): Promise<void> {
                const unlistenChannelState = await listen<ChannelStateChangedEventPayload>('fat://channel_state_changed', (event) => {
                    console.log('FE: Received channel_state_changed', event.payload);
                    this.channelStateChangedSubject.next(event.payload);
                });
                this.unlistenFns.push(unlistenChannelState);
                
                // Add listeners for BatchProgressEventPayload, LogMessageEventPayload etc.
            }

            ngOnDestroy() {
                this.unlistenFns.forEach(fn => fn());
            }
        }
        ```
*   **å¦‚ä½•æµ‹è¯• (How to Test)**:
    *   **Angular å•å…ƒæµ‹è¯• (Jasmine/Karma)**:
        *   Mock `@tauri-apps/api/tauri` çš„ `invoke` å‡½æ•°å’Œ `@tauri-apps/api/event` çš„ `listen` å‡½æ•°ã€‚
        *   æµ‹è¯•æœåŠ¡æ–¹æ³•è°ƒç”¨ `invoke` æ—¶æ˜¯å¦ä½¿ç”¨äº†æ­£ç¡®çš„ command åç§°å’Œå‚æ•° (matching the TS Args interfaces)ã€‚
        *   æµ‹è¯•æœåŠ¡æ–¹æ³•æ˜¯å¦èƒ½æ­£ç¡®å¤„ç† `invoke` æˆåŠŸ (matching TS Response interfaces) å’Œå¤±è´¥çš„ `Promise`ã€‚
        *   æµ‹è¯•äº‹ä»¶ç›‘å¬æ˜¯å¦è¢«è®¾ç½®ï¼Œå¹¶åœ¨ `ngOnDestroy` ä¸­è¢«æ¸…ç†ã€‚
        *   æµ‹è¯•äº‹ä»¶è§¦å‘æ—¶ï¼ŒæœåŠ¡å†…éƒ¨çš„ `Subject` æ˜¯å¦æ­£ç¡®å‘å‡ºå€¼ (matching TS Event Payload interfaces)ã€‚
    *   **ç»„ä»¶é›†æˆæµ‹è¯•**: åˆ›å»ºä¸€ä¸ªç®€å•çš„æµ‹è¯•ç»„ä»¶ï¼Œæ³¨å…¥è¿™äº›æœåŠ¡ï¼Œè°ƒç”¨æœåŠ¡æ–¹æ³•å¹¶è®¢é˜…äº‹ä»¶ï¼ŒéªŒè¯ç»„ä»¶æ˜¯å¦èƒ½æ­£ç¡®æ¥æ”¶æ•°æ®å’Œæ›´æ–°ã€‚

### (å®Œæˆ)æ­¥éª¤ 4.3: åˆ›å»ºæ ¸å¿ƒé¡µé¢ç»„ä»¶éª¨æ¶

*   **åŸå›  (Reason)**:
    *   æ ¸å¿ƒé¡µé¢æ˜¯ç”¨æˆ·ä¸ç³»ç»Ÿäº¤äº’çš„ä¸»è¦ç•Œé¢ã€‚
    *   å°½æ—©åˆ›å»ºé¡µé¢éª¨æ¶æœ‰åŠ©äºç†è§£å‰ç«¯æ¶æ„å’Œæ•°æ®æµã€‚
*   **æœŸæœ›æ•ˆæœ (Expected Outcome)**:
    *   ä½¿ç”¨ Angular CLI ç”Ÿæˆæ ¸å¿ƒé¡µé¢ç»„ä»¶ï¼š
        *   `BatchManagementComponent`: æ‰¹æ¬¡ç®¡ç†é¡µé¢ï¼Œç”¨äºåˆ›å»ºæ–°æ‰¹æ¬¡ã€å¯¼å…¥Excelã€æŸ¥çœ‹å†å²æ‰¹æ¬¡ç­‰ã€‚
        *   `TestExecutionComponent`: æµ‹è¯•æ‰§è¡Œé¡µé¢ï¼Œæ˜¾ç¤ºå½“å‰æ‰¹æ¬¡çš„é€šé“åˆ—è¡¨ã€æµ‹è¯•è¿›åº¦ã€å®æ—¶çŠ¶æ€æ›´æ–°ç­‰ã€‚
        *   `ManualTestComponent`: æ‰‹åŠ¨æµ‹è¯•é¡µé¢ï¼Œç”¨äºå•ç‚¹æµ‹è¯•ã€æ‰‹åŠ¨è¯»å†™ç­‰ã€‚
    *   é…ç½® Angular è·¯ç”±ï¼Œä½¿è¿™äº›é¡µé¢å¯ä»¥é€šè¿‡å¯¼èˆªè®¿é—®ã€‚
    *   æ¯ä¸ªç»„ä»¶éƒ½æœ‰åŸºæœ¬çš„ HTML æ¨¡æ¿å’Œ TypeScript é€»è¾‘ï¼Œèƒ½å¤Ÿæ³¨å…¥å¹¶ä½¿ç”¨ `BackendCommsService`ã€‚

### (å®Œæˆ)æ­¥éª¤ 4.4: åˆæ­¥å®ç°æ ¸å¿ƒé¡µé¢çš„æ•°æ®ç»‘å®šå’Œäº¤äº’

*   **åŸå›  (Reason)**:
    *   ä½¿å‰ç«¯é¡µé¢èƒ½å¤Ÿé€šè¿‡è°ƒç”¨ `BackendCommsService` æ¥è·å–æ•°æ®ã€å‘é€å‘½ä»¤ï¼Œå¹¶é€šè¿‡è®¢é˜…å…¶ `Observable` æ¥å“åº”åç«¯äº‹ä»¶ï¼Œä»è€Œå®ç°åŸºæœ¬çš„åŠŸèƒ½äº¤äº’ã€‚
*   **æœŸæœ›æ•ˆæœ (Expected Outcome)**:
    *   `BatchManagementComponent`: å®ç°æ–‡ä»¶é€‰æ‹© (`<input type="file">`)ï¼Œè°ƒç”¨ `BackendCommsService.importExcelAndPrepareBatch`ï¼Œæ˜¾ç¤ºè¿”å›çš„æ‰¹æ¬¡ä¿¡æ¯å’Œå®ä¾‹åˆ—è¡¨çš„æ‘˜è¦ï¼Œå¹¶å¯¼èˆªåˆ°æµ‹è¯•æ‰§è¡Œé¡µé¢ã€‚
    *   `TestExecutionComponent`: æ¥æ”¶ `batchId` è·¯ç”±å‚æ•°ï¼Œè°ƒç”¨æœåŠ¡è·å–æ‰¹æ¬¡è¯¦æƒ…å’Œå®ä¾‹åˆ—è¡¨ï¼Œå±•ç¤ºé€šé“åˆ—è¡¨ã€‚å½“ç”¨æˆ·ç‚¹å‡»"å¼€å§‹æµ‹è¯•"æŒ‰é’®æ—¶ï¼Œè°ƒç”¨ `BackendCommsService.startTestsForBatch`ã€‚è®¢é˜… `BackendCommsService.channelStateChanged$` ä»¥å®æ—¶æ›´æ–°é€šé“çŠ¶æ€ã€‚
    *   ç»„ä»¶èƒ½å¤Ÿå¤„ç†åŠ è½½çŠ¶æ€ (loading indicators) å’Œé”™è¯¯æ˜¾ç¤ºã€‚

---

## Phase 5: UI/UX ç»†åŒ–ä¸åŠŸèƒ½å®Œå–„

**ç›®æ ‡ï¼š** åŸºäºéª¨æ¶ï¼Œç»†åŒ– Angular ç»„ä»¶çš„ UI è®¾è®¡å’Œç”¨æˆ·ä½“éªŒï¼Œå®ç°æ›´å®Œæ•´çš„å‰ç«¯åŠŸèƒ½ï¼ŒåŒ…æ‹¬æ•°æ®æ˜¾ç¤ºã€ç”¨æˆ·äº¤äº’ã€è¡¨å•éªŒè¯ã€é”™è¯¯æç¤ºã€å›½é™…åŒ–ç­‰ï¼Œå¹¶å¯¹ç°æœ‰åŠŸèƒ½è¿›è¡Œè¿­ä»£å’Œä¼˜åŒ–ã€‚

### (å®Œæˆ)æ­¥éª¤ 5.1: UI ç»„ä»¶åº“é›†æˆä¸å…¨å±€æ ·å¼å®šä¹‰

*   **åŸå›  (Reason)**:
    *   ä½¿ç”¨æˆç†Ÿçš„ UI ç»„ä»¶åº“å¯ä»¥å¿«é€Ÿæ„å»ºç¾è§‚ä¸”ä¸€è‡´çš„ç”¨æˆ·ç•Œé¢ï¼Œæé«˜å¼€å‘æ•ˆç‡ã€‚
    *   å®šä¹‰å…¨å±€æ ·å¼å’Œä¸»é¢˜æœ‰åŠ©äºä¿æŒåº”ç”¨çš„è§†è§‰ç»Ÿä¸€æ€§ã€‚
*   **æœŸæœ›æ•ˆæœ (Expected Outcome)**:
    *   é€‰æ‹©å¹¶é›†æˆä¸€ä¸ª Angular UI ç»„ä»¶åº“ (å¦‚ Angular Material, NG-ZORRO, PrimeNG ç­‰)ã€‚
    *   å®šä¹‰åº”ç”¨çš„å…¨å±€ CSS å˜é‡ã€ä¸»é¢˜è‰²ã€åŸºæœ¬å¸ƒå±€æ ·å¼ç­‰ã€‚
    *   æ ¸å¿ƒé¡µé¢ (`BatchManagement`, `TestExecution`, `ManualTest`) å¼€å§‹ä½¿ç”¨æ‰€é€‰ UI ç»„ä»¶åº“çš„ç»„ä»¶æ›¿æ¢åŸç”Ÿ HTML å…ƒç´ ï¼Œä»¥æ”¹å–„å¤–è§‚å’Œäº¤äº’ã€‚
*   **å®æ–½æè¿° (Implementation Description)**:
    1.  **é€‰æ‹© UI ç»„ä»¶åº“**: è¯„ä¼°å„ç»„ä»¶åº“çš„ç‰¹æ€§ã€æ–‡æ¡£ã€ç¤¾åŒºæ”¯æŒå’Œè®¾è®¡é£æ ¼ï¼Œé€‰æ‹©ä¸€ä¸ªé€‚åˆé¡¹ç›®çš„ã€‚
        *   ä¾‹å¦‚ï¼Œè‹¥é€‰æ‹© Angular Material: `ng add @angular/material`ã€‚
        *   è‹¥é€‰æ‹© NG-ZORRO: `ng add ng-zorro-antd`ã€‚
    2.  **å¯¼å…¥æ‰€éœ€æ¨¡å—**: åœ¨ `app.module.ts` (æˆ–å…±äº«æ¨¡å—) ä¸­å¯¼å…¥æ‰€é€‰ UI ç»„ä»¶åº“æä¾›çš„æ¨¡å—ã€‚
        ```typescript
        // Example for Angular Material
        import { MatButtonModule } from '@angular/material/button';
        import { MatInputModule } from '@angular/material/input';
        import { MatTableModule } from '@angular/material/table';
        // ... other modules

        @NgModule({
          imports: [
            // ..., MatButtonModule, MatInputModule, MatTableModule
          ]
        })
        export class AppModule { }
        ```
    3.  **å…¨å±€æ ·å¼**: åœ¨ `src/styles.scss` (æˆ–ç›¸åº”çš„ä¸»é¢˜æ–‡ä»¶) ä¸­å®šä¹‰å…¨å±€æ ·å¼ã€CSS å˜é‡ï¼Œæˆ–é…ç½®ç»„ä»¶åº“çš„ä¸»é¢˜ã€‚
        ```scss
        // src/styles.scss
        // @use '@angular/material' as mat;
        // @include mat.core();
        // $my-primary: mat.define-palette(mat.$indigo-palette, 500);
        // $my-accent: mat.define-palette(mat.$pink-palette, A200, A100, A400);
        // $my-theme: mat.define-light-theme((
        //   color: (
        //     primary: $my-primary,
        //     accent: $my-accent,
        //   )
        // ));
        // @include mat.all-component-themes($my-theme);

        body { margin: 0; font-family: Roboto, "Helvetica Neue", sans-serif; }
        .container { padding: 20px; }
        // ... other global styles
        ```
    4.  **æ›¿æ¢ç»„ä»¶**: é€æ­¥ä¿®æ”¹ç°æœ‰ç»„ä»¶çš„ HTML æ¨¡æ¿ï¼Œä½¿ç”¨ UI ç»„ä»¶åº“æä¾›çš„ç»„ä»¶ã€‚ä¾‹å¦‚ï¼Œç”¨ `<button mat-raised-button color="primary">Import</button>` æ›¿æ¢ `<button>`ã€‚
*   **å¦‚ä½•æµ‹è¯• (How to Test)**:
    *   **è§†è§‰æ£€æŸ¥**: è¿è¡Œ `npm run tauri dev`ï¼Œæ£€æŸ¥å„é¡µé¢ç»„ä»¶æ˜¯å¦æ­£ç¡®æ¸²æŸ“äº†æ–° UI åº“çš„æ ·å¼ã€‚
    *   **äº¤äº’æµ‹è¯•**: æµ‹è¯•æ–°ç»„ä»¶çš„äº¤äº’è¡Œä¸º (å¦‚æŒ‰é’®ç‚¹å‡»ã€è¡¨å•è¾“å…¥ã€è¡¨æ ¼æ’åºç­‰) æ˜¯å¦ç¬¦åˆé¢„æœŸã€‚
    *   **å“åº”å¼æ£€æŸ¥**: å¦‚æœ UI åº“æ”¯æŒå“åº”å¼è®¾è®¡ï¼Œæ£€æŸ¥åœ¨ä¸åŒçª—å£å¤§å°ä¸‹çš„å¸ƒå±€è¡¨ç°ã€‚

### (å®Œæˆ)æ­¥éª¤ 5.2: å®Œå–„ `BatchManagementComponent` åŠŸèƒ½ä¸UI

*   **åŸå›  (Reason)**:
    *   æ‰¹æ¬¡ç®¡ç†æ˜¯åº”ç”¨çš„å…¥å£ï¼Œéœ€è¦æ¸…æ™°çš„ç”¨æˆ·å¼•å¯¼å’Œå®Œæ•´çš„æ“ä½œæµç¨‹ã€‚
*   **æœŸæœ›æ•ˆæœ (Expected Outcome)**:
    *   ä½¿ç”¨ UI ç»„ä»¶åº“ç¾åŒ–æ–‡ä»¶é€‰æ‹©æŒ‰é’®å’Œæ˜¾ç¤ºåŒºåŸŸã€‚
    *   æ˜¾ç¤ºå¯¼å…¥çš„ `ChannelPointDefinition` åˆ—è¡¨çš„æ‘˜è¦ (ä¾‹å¦‚ï¼Œæ€»æ•°ï¼Œå„ç±»å‹æ¨¡å—æ•°é‡)ã€‚
    *   å…è®¸ç”¨æˆ·è¾“å…¥æˆ–ç¡®è®¤æ‰¹æ¬¡ä¿¡æ¯ (äº§å“å‹å·ã€åºåˆ—å·) - å¯ä»¥ä»Excelæå–æˆ–ç”¨æˆ·æ‰‹åŠ¨è¾“å…¥ã€‚
    *   æä¾›æ¸…æ™°çš„åŠ è½½çŠ¶æ€å’Œé”™è¯¯åé¦ˆ (ä¾‹å¦‚ï¼Œä½¿ç”¨è¿›åº¦æ¡ã€æ¶ˆæ¯æ¡†/Toast)ã€‚
    *   æˆåŠŸå¯¼å…¥å¹¶å‡†å¤‡å¥½æ‰¹æ¬¡åï¼Œç•Œé¢å¼•å¯¼ç”¨æˆ·è¿›å…¥æ¥çº¿ç¡®è®¤æˆ–ç›´æ¥å¼€å§‹æµ‹è¯•çš„æ­¥éª¤ã€‚
*   **å®æ–½æè¿° (Implementation Description)**:
    1.  **UI æ”¹è¿›**: ä½¿ç”¨å¦‚ `<mat-form-field>`, `<mat-progress-bar>`, `NzUpload`, `NzInput`, `NzModal` ç­‰ç»„ä»¶ã€‚
    2.  **æ‰¹æ¬¡ä¿¡æ¯è¡¨å•**: æ·»åŠ è¡¨å•è®©ç”¨æˆ·å¯ä»¥ç¼–è¾‘ä»Excelæå–æˆ–æ–°è¾“å…¥çš„æ‰¹æ¬¡ä¿¡æ¯ã€‚
    3.  **ç‚¹ä½å®šä¹‰é¢„è§ˆ**: (å¯é€‰) æ˜¾ç¤ºä¸€ä¸ªå¯æ»šåŠ¨çš„è¡¨æ ¼ï¼Œç®€è¦åˆ—å‡ºå¯¼å…¥çš„ç‚¹ä½å®šä¹‰ã€‚
    4.  **é”™è¯¯å¤„ç†**: å½“ `BackendCommsService.importExcelAndPrepareBatch` æŠ›å‡ºé”™è¯¯æ—¶ï¼Œä½¿ç”¨å¯¹è¯æ¡†æˆ–Toastç»„ä»¶æ˜¾ç¤ºå‹å¥½çš„é”™è¯¯æ¶ˆæ¯ã€‚
    5.  **æµç¨‹å¼•å¯¼**: æˆåŠŸåï¼ŒæŒ‰é’®çŠ¶æ€æ”¹å˜ï¼Œä¾‹å¦‚"ä¸‹ä¸€æ­¥ï¼šæ¥çº¿ç¡®è®¤"æˆ–"å¼€å§‹æµ‹è¯•"ã€‚
*   **å¦‚ä½•æµ‹è¯• (How to Test)**:
    *   **æ‰‹åŠ¨æµ‹è¯•æ‰€æœ‰äº¤äº’**: æ–‡ä»¶é€‰æ‹©ã€æ‰¹æ¬¡ä¿¡æ¯è¾“å…¥ã€ä¸åŒå¯¼å…¥ç»“æœï¼ˆæˆåŠŸã€å¤±è´¥ã€éƒ¨åˆ†æˆåŠŸï¼‰çš„UIåé¦ˆã€‚
    *   **è¡¨å•éªŒè¯æµ‹è¯•**: å¦‚æœæœ‰è¡¨å•ï¼Œæµ‹è¯•å…¶éªŒè¯é€»è¾‘ã€‚

### (å®Œæˆ)æ­¥éª¤ 5.3: å®Œå–„ `TestExecutionComponent` åŠŸèƒ½ä¸UI

*   **åŸå›  (Reason)**:
    *   æµ‹è¯•æ‰§è¡Œæ˜¯åº”ç”¨çš„æ ¸å¿ƒç›‘æ§ç•Œé¢ï¼Œéœ€è¦æ¸…æ™°åœ°å±•ç¤ºå¤§é‡åŠ¨æ€ä¿¡æ¯ã€‚
*   **æœŸæœ›æ•ˆæœ (Expected Outcome)**:
    *   ä½¿ç”¨è¡¨æ ¼ç»„ä»¶ (å¦‚ `MatTable`, `NzTable`) æ˜¾ç¤º `ChannelTestInstance` åˆ—è¡¨ï¼ŒåŒ…å«å…³é”®åˆ—ï¼šä½å·ã€æè¿°ã€æ¨¡å—ç±»å‹ã€å½“å‰çŠ¶æ€ã€æµ‹è¯•ç»“æœã€è¿›åº¦ç­‰ã€‚
    *   è¡¨æ ¼åº”æ”¯æŒæ’åºã€ç­›é€‰ï¼ˆæŒ‰çŠ¶æ€ã€æ¨¡å—ç±»å‹ç­‰ï¼‰ã€‚
    *   å®æ—¶æ›´æ–°è¡¨æ ¼ä¸­é€šé“çš„çŠ¶æ€å’Œæµ‹è¯•ç»“æœ (åŸºäºä» `BackendCommsService` è®¢é˜…çš„äº‹ä»¶)ã€‚
    *   å®ç°æµ‹è¯•æ§åˆ¶æŒ‰é’® (å¼€å§‹æ‰¹æ¬¡æµ‹è¯•ã€æš‚åœã€ç»§ç»­ã€åœæ­¢) å¹¶è°ƒç”¨ç›¸åº”çš„åç«¯æœåŠ¡æ–¹æ³•ã€‚
    *   æä¾›æ‰¹æ¬¡æ•´ä½“è¿›åº¦çš„å¯è§†åŒ– (å¦‚è¿›åº¦æ¡ã€ç»Ÿè®¡æ•°æ®ï¼šæ€»æ•°/å·²æµ‹/é€šè¿‡/å¤±è´¥)ã€‚
    *   ç‚¹å‡»åˆ—è¡¨ä¸­çš„æŸä¸ªé€šé“ï¼Œå¯ä»¥å¯¼èˆªåˆ°/æ˜¾ç¤ºä¸€ä¸ª `ChannelDetailComponent`ï¼Œå±•ç¤ºè¯¥é€šé“æ›´è¯¦ç»†çš„æµ‹è¯•ä¿¡æ¯å’Œå­æµ‹è¯•é¡¹çŠ¶æ€ã€‚
*   **å®æ–½æè¿° (Implementation Description)**:
    1.  **è¡¨æ ¼å®ç°**: ä½¿ç”¨ UI åº“çš„è¡¨æ ¼ç»„ä»¶é…ç½®åˆ—å®šä¹‰ã€æ•°æ®æº (`this.instances`)ã€‚
    2.  **å®æ—¶æ›´æ–°**: åœ¨ `updateInstanceInList` æ–¹æ³•ä¸­ï¼Œç¡®ä¿ Angular çš„å˜æ›´æ£€æµ‹èƒ½å¤Ÿæ•è·åˆ°æ•°æ®çš„å˜åŒ–å¹¶åˆ·æ–°è¡¨æ ¼ã€‚å¯¹äºå¤§å‹åˆ—è¡¨ï¼Œè€ƒè™‘ä½¿ç”¨ `trackBy` å‡½æ•°ä¼˜åŒ–æ€§èƒ½ã€‚
    3.  **æ§åˆ¶æŒ‰é’®**: æ·»åŠ æŒ‰é’®å¹¶ç»‘å®šåˆ° `TestExecutionComponent` çš„æ–¹æ³•ï¼Œè¿™äº›æ–¹æ³•å†è°ƒç”¨ `BackendCommsService` ä¸­å¯¹åº”çš„æ–¹æ³• (å¦‚ `pauseTestsForBatch`, `stopTestsForBatch`)ã€‚
    4.  **è¿›åº¦æ˜¾ç¤º**: æ ¹æ® `this.instances` æ•°ç»„è®¡ç®—ç»Ÿè®¡æ•°æ®ï¼Œå¹¶ç»‘å®šåˆ°æ¨¡æ¿ã€‚
    5.  **é€šé“è¯¦æƒ…**: å®ç° `ChannelDetailComponent` å¹¶è®¾ç½®è·¯ç”±ï¼Œæˆ–è€…ä½¿ç”¨æ¨¡æ€æ¡†/ä¾§è¾¹æ æ˜¾ç¤ºé€šé“è¯¦æƒ…ã€‚
*   **å¦‚ä½•æµ‹è¯• (How to Test)**:
    *   **åŠ¨æ€æ•°æ®æ˜¾ç¤º**: æ¨¡æ‹Ÿåç«¯å‘é€å¤§é‡é€šé“çŠ¶æ€æ›´æ–°äº‹ä»¶ï¼ŒéªŒè¯è¡¨æ ¼æ•°æ®æ˜¯å¦å®æ—¶ã€æ­£ç¡®åœ°åˆ·æ–°ï¼Œå¹¶ä¸”æ²¡æœ‰æ€§èƒ½é—®é¢˜ã€‚
    *   **äº¤äº’æ§åˆ¶**: æµ‹è¯•å¼€å§‹ã€æš‚åœã€åœæ­¢ç­‰æ§åˆ¶æŒ‰é’®çš„åŠŸèƒ½ï¼Œå¹¶è§‚å¯ŸUIçŠ¶æ€å’Œåç«¯æ—¥å¿—ã€‚
    *   **æ’åºä¸ç­›é€‰**: æµ‹è¯•è¡¨æ ¼çš„æ’åºå’Œç­›é€‰åŠŸèƒ½ã€‚
    *   **å¯¼èˆª/è¯¦æƒ…æ˜¾ç¤º**: æµ‹è¯•ç‚¹å‡»é€šé“åæ˜¯å¦èƒ½æ­£ç¡®æ˜¾ç¤ºè¯¦ç»†ä¿¡æ¯ã€‚

### (å®Œæˆ)æ­¥éª¤ 5.4: å®ç° `ChannelDetailComponent` å’Œ `ManualTestComponent`

*   **åŸå›  (Reason)**:
    *   æä¾›å¯¹å•ä¸ªé€šé“çš„è¯¦ç»†è§†å›¾å’Œæ‰‹åŠ¨å¹²é¢„èƒ½åŠ›ã€‚
*   **æœŸæœ›æ•ˆæœ (Expected Outcome)**:
    *   **`ChannelDetailComponent`**: æ˜¾ç¤ºé€‰å®š `ChannelTestInstance` çš„æ‰€æœ‰é…ç½®ä¿¡æ¯ (`ChannelPointDefinition`) å’Œæ‰€æœ‰å­æµ‹è¯•é¡¹ (`SubTestItem`) çš„å½“å‰çŠ¶æ€ã€ç»“æœã€æ—¶é—´æˆ³ã€è¯¦ç»†è¯»å€¼/æ¶ˆæ¯ã€‚
    *   **`ManualTestComponent`**: (å¯èƒ½ä¸ `ChannelDetailComponent` é›†æˆæˆ–ç‹¬ç«‹)
        *   å…è®¸ç”¨æˆ·é€‰æ‹©ä¸€ä¸ªé€šé“å’Œè¯¥é€šé“çš„ä¸€ä¸ªå…·ä½“å­æµ‹è¯•é¡¹ (å¦‚ AIé«˜æŠ¥ã€DOç½®ON)ã€‚
        *   è°ƒç”¨ `BackendCommsService` ä¸­çš„æ‰‹åŠ¨æµ‹è¯•æ–¹æ³• (`executeManualSubTestCmd`, `readCurrentValueCmd`, `writeValueManualCmd`)ã€‚
        *   æ˜¾ç¤ºæ‰‹åŠ¨æ“ä½œçš„ç»“æœå’Œåé¦ˆã€‚
    *   UIæ¸…æ™°ï¼Œæ“ä½œç›´è§‚ã€‚
*   **å®æ–½æè¿° (Implementation Description)**:
    1.  **`ChannelDetailComponent`**: æ¥æ”¶ `instanceId` (å¯èƒ½è¿˜æœ‰ `batchId`)ï¼Œä»æœåŠ¡è·å–å®Œæ•´çš„ `ChannelTestInstance` å’Œ `ChannelPointDefinition` æ•°æ®ã€‚ä½¿ç”¨æè¿°åˆ—è¡¨æˆ–å¡ç‰‡å¸ƒå±€æ¥å±•ç¤ºä¿¡æ¯ã€‚å­æµ‹è¯•é¡¹å¯ä»¥ç”¨ä¸€ä¸ªè¡¨æ ¼æˆ–åˆ—è¡¨æ˜¾ç¤ºã€‚
    2.  **`ManualTestComponent`**: 
        *   æä¾›ä¸‹æ‹‰æ¡†æˆ–æœç´¢æ¡†è®©ç”¨æˆ·é€‰æ‹©é€šé“å’Œå­æµ‹è¯•é¡¹ã€‚
        *   æ ¹æ®é€‰æ‹©çš„å­æµ‹è¯•é¡¹ï¼ŒåŠ¨æ€æ˜¾ç¤ºç›¸åº”çš„è¾“å…¥å­—æ®µ (å¦‚æ¨¡æ‹Ÿè¾“å‡ºå€¼ã€DOå¼€å…³çŠ¶æ€)ã€‚
        *   æŒ‰é’®è§¦å‘å¯¹ `BackendCommsService` ç›¸åº”æ–¹æ³•çš„è°ƒç”¨ã€‚
        *   ä½¿ç”¨UIç»„ä»¶æ˜¾ç¤ºæ“ä½œç»“æœ (æˆåŠŸ/å¤±è´¥æ¶ˆæ¯ï¼Œè¯»å–åˆ°çš„å€¼)ã€‚
*   **å¦‚ä½•æµ‹è¯• (How to Test)**:
    *   **æ•°æ®æ˜¾ç¤ºå‡†ç¡®æ€§**: éªŒè¯ `ChannelDetailComponent` æ˜¾ç¤ºçš„æ‰€æœ‰ä¿¡æ¯æ˜¯å¦ä¸åç«¯æ•°æ®ä¸€è‡´ã€‚
    *   **æ‰‹åŠ¨æµ‹è¯•æµç¨‹**: å¯¹ä¸åŒç±»å‹çš„ç‚¹ (AI, DI, AO, DO) å’Œä¸åŒçš„å­æµ‹è¯•é¡¹ï¼Œå®Œæ•´æµ‹è¯•æ‰‹åŠ¨æ‰§è¡Œã€è¯»å€¼ã€å†™å€¼æµç¨‹ï¼ŒéªŒè¯UIåé¦ˆå’Œåç«¯å®é™…æ‰§è¡Œæƒ…å†µï¼ˆé€šè¿‡mockçš„PLCæœåŠ¡æ—¥å¿—ï¼‰ã€‚

### (å®Œæˆ)æ­¥éª¤ 5.5: å®ç°åº”ç”¨é…ç½®çš„æŒä¹…åŒ–ä¸åŠ è½½ (`AppSettings`)

*   **åŸå›  (Reason)**:
    *   åº”ç”¨éœ€è¦ä¿å­˜ç”¨æˆ·åå¥½è®¾ç½®ã€é»˜è®¤PLCè¿æ¥å‚æ•°ã€ä¸Šæ¬¡ä½¿ç”¨çš„é…ç½®åç§°ç­‰ä¿¡æ¯ã€‚
    *   è¿™äº›é…ç½®éœ€è¦åœ¨åº”ç”¨å¯åŠ¨æ—¶åŠ è½½ï¼Œå¹¶åœ¨ç”¨æˆ·ä¿®æ”¹åæŒä¹…åŒ–ï¼Œä»¥ä¾¿ä¸‹æ¬¡å¯åŠ¨æ—¶æ¢å¤ã€‚
    *   ä½¿ç”¨ä¸“é—¨çš„ `AppSettingsService` å’Œ JSON æ–‡ä»¶å­˜å‚¨åº”ç”¨é…ç½®æ˜¯ä¸€ç§è½»é‡çº§ä¸”èŒè´£æ¸…æ™°çš„åšæ³•ï¼Œä¸ä¸šåŠ¡æ•°æ®çš„æŒä¹…åŒ–åˆ†ç¦»ã€‚
*   **æœŸæœ›æ•ˆæœ (Expected Outcome)**:
    *   å®šä¹‰ `AppSettings` ç»“æ„ä½“ (åœ¨ `src/models/settings.rs`)ï¼ŒåŒ…å«æ‰€æœ‰éœ€è¦æŒä¹…åŒ–çš„åº”ç”¨çº§é…ç½®é¡¹ã€‚
    *   å®ç°ä¸“é—¨çš„ `IAppSettingsService` trait å’Œ `JsonAppSettingsService` å®ç°ç±»ï¼Œè´Ÿè´£åº”ç”¨é…ç½®çš„åŠ è½½å’Œä¿å­˜ã€‚
        *   åŠ è½½é€»è¾‘ï¼šåº”ç”¨å¯åŠ¨æ—¶ï¼Œå°è¯•ä»ç”¨æˆ·åº”ç”¨é…ç½®ç›®å½•ä¸‹çš„ç‰¹å®š JSON æ–‡ä»¶ (e.g., `app_settings.json`) åŠ è½½ `AppSettings`ã€‚å¦‚æœæ–‡ä»¶ä¸å­˜åœ¨æˆ–è§£æå¤±è´¥ï¼Œåˆ™ä½¿ç”¨é»˜è®¤å€¼ã€‚
        *   ä¿å­˜é€»è¾‘ï¼šå½“ç”¨æˆ·ä¿®æ”¹è®¾ç½®åï¼Œå°† `AppSettings` å¯¹è±¡åºåˆ—åŒ–ä¸º JSON å¹¶ä¿å­˜åˆ°ä¸Šè¿°æ–‡ä»¶ä¸­ã€‚
    *   ä½¿ç”¨ä¸“é—¨çš„ `AppSettingsService` è€Œä¸æ˜¯é€šç”¨çš„ `IPersistenceService` æ¥å¤„ç†åº”ç”¨é…ç½®ï¼Œå®ç°èŒè´£åˆ†ç¦»ã€‚
    *   Tauri command (`save_app_settings_cmd`, `load_app_settings_cmd`) è°ƒç”¨è¿™äº›æœåŠ¡æ–¹æ³•ã€‚
    *   å‰ç«¯ UI æä¾›ç•Œé¢ä¾›ç”¨æˆ·ä¿®æ”¹è¿™äº›è®¾ç½®ï¼Œå¹¶èƒ½æ­£ç¡®åæ˜ å½“å‰åŠ è½½çš„é…ç½®ã€‚
*   **å®æ–½æè¿° (Implementation Description)**:
    1.  **å®šä¹‰ `AppSettings` struct** (åœ¨ `src/models/settings.rs` æˆ–ç±»ä¼¼ä½ç½®):
        *   æ´¾ç”Ÿ `Serialize`, `Deserialize`, `Debug`, `Clone`ã€‚
        *   åŒ…å«å­—æ®µå¦‚ï¼š`last_opened_batch_id: Option<String>`, `default_plc_ip: String`, `theme: String`, `auto_load_last_config: bool` ç­‰ã€‚
        *   æä¾›ä¸€ä¸ª `Default` å®ç° (`impl Default for AppSettings`) è¿”å›ä¸€å¥—å®‰å…¨å¯é çš„é»˜è®¤è®¾ç½®ã€‚
    2.  **å®ç° `IAppSettingsService` trait å’Œ `JsonAppSettingsService** (åœ¨ `src/services/infrastructure/app_settings_service.rs`):
        *   å®šä¹‰ `IAppSettingsService` traitï¼ŒåŒ…å« `load_settings()`, `save_settings()`, `reset_to_defaults()`, `validate_settings()` ç­‰æ–¹æ³•ã€‚
        *   å®ç° `JsonAppSettingsService` structï¼Œä½¿ç”¨ JSON æ–‡ä»¶è¿›è¡Œé…ç½®çš„è¯»å†™ã€‚
        *   **`load_settings()` æ–¹æ³•**:
            *   å°è¯•ä»æŒ‡å®šè·¯å¾„è¯»å– `app_settings.json` æ–‡ä»¶ã€‚
            *   å¦‚æœæ–‡ä»¶å­˜åœ¨ä¸”è§£ææˆåŠŸï¼Œè¿”å›è§£æçš„ `AppSettings`ã€‚
            *   å¦‚æœæ–‡ä»¶ä¸å­˜åœ¨æˆ–è§£æå¤±è´¥ï¼Œè¿”å› `AppSettings::default()`ï¼Œå¹¶å¯èƒ½è®°å½•ä¸€ä¸ªè­¦å‘Šã€‚
        *   **`save_settings(settings: &AppSettings)` æ–¹æ³•**:
            *   å°† `AppSettings` åºåˆ—åŒ–ä¸º JSON å¹¶å†™å…¥åˆ°æŒ‡å®šæ–‡ä»¶è·¯å¾„ã€‚
            *   å¤„ç†å¯èƒ½çš„æ–‡ä»¶å†™å…¥é”™è¯¯ã€‚
        *   æä¾› `AppSettingsServiceFactory` å·¥å‚ç±»ç”¨äºåˆ›å»ºæœåŠ¡å®ä¾‹ã€‚
    3.  **åˆ›å»º Tauri Commands** (`src/commands/system_settings.rs`):
        *   `#[tauri::command] async fn load_app_settings_cmd(state: tauri::State<'_, AppState>) -> Result<AppSettings, String>`:
            *   è°ƒç”¨ `state.app_settings_service.load_settings().await.map_err(|e| e.to_string())`ã€‚
        *   `#[tauri::command] async fn save_app_settings_cmd(settings: AppSettings, state: tauri::State<'_, AppState>) -> Result<(), String>`:
            *   è°ƒç”¨ `state.app_settings_service.save_settings(&settings).await.map_err(|e| e.to_string())`ã€‚
    4.  **å‰ç«¯ Angular å®ç°** (`SettingsService` å’Œç›¸å…³ç»„ä»¶):
        *   Angular `SettingsService` è°ƒç”¨ä¸Šè¿° Tauri commandsã€‚
        *   åˆ›å»ºè®¾ç½®é¡µé¢ç»„ä»¶ï¼Œå…è®¸ç”¨æˆ·æŸ¥çœ‹å’Œä¿®æ”¹ `AppSettings`ã€‚
        *   åº”ç”¨å¯åŠ¨æ—¶ï¼ŒAngular æœåŠ¡è°ƒç”¨ `load_app_settings_cmd` åŠ è½½é…ç½®å¹¶åº”ç”¨åˆ°UIæˆ–ç›¸å…³æœåŠ¡ã€‚
*   **å¦‚ä½•æµ‹è¯• (How to Test)**:
    *   **è®¾ç½®åŠŸèƒ½**: ä¿®æ”¹è®¾ç½®ï¼Œé‡å¯åº”ç”¨æˆ–è§¦å‘ç›¸å…³é€»è¾‘ï¼ŒéªŒè¯æ–°è®¾ç½®æ˜¯å¦ç”Ÿæ•ˆï¼Œå¹¶æ£€æŸ¥å¯¹åº”çš„ `app_settings.json` æ–‡ä»¶å†…å®¹æ˜¯å¦æŒ‰é¢„æœŸæ›´æ–°ã€‚
    *   **é»˜è®¤å€¼ä¸é”™è¯¯å¤„ç†**: æµ‹è¯•é¦–æ¬¡å¯åŠ¨ï¼ˆæ— é…ç½®æ–‡ä»¶æ—¶ï¼‰æ˜¯å¦æ­£ç¡®åŠ è½½é»˜è®¤è®¾ç½®ï¼Œä»¥åŠé…ç½®æ–‡ä»¶æŸåæˆ–æ— æ•ˆæ—¶ç³»ç»Ÿçš„è¡Œä¸ºã€‚

### (å®Œæˆ)æ­¥éª¤ 5.6: å®ç°ç³»ç»Ÿç›‘æ§ç»„ä»¶å’ŒæŠ¥å‘Šç”ŸæˆåŠŸèƒ½

*   **åŸå›  (Reason)**:
    *   ç³»ç»Ÿç›‘æ§æ˜¯å·¥å‚æµ‹è¯•ç³»ç»Ÿçš„é‡è¦ç»„æˆéƒ¨åˆ†ï¼Œéœ€è¦å®æ—¶ç›‘æ§ç³»ç»ŸçŠ¶æ€ã€æ€§èƒ½æŒ‡æ ‡å’Œæµ‹è¯•è¿›åº¦ã€‚
    *   æŠ¥å‘Šç”ŸæˆåŠŸèƒ½æ˜¯æµ‹è¯•æµç¨‹çš„æœ€ç»ˆç¯èŠ‚ï¼Œéœ€è¦æä¾›å¤šæ ¼å¼çš„æµ‹è¯•æŠ¥å‘Šå¯¼å‡ºåŠŸèƒ½ã€‚
*   **æœŸæœ›æ•ˆæœ (Expected Outcome)**:
    *   **ç³»ç»Ÿç›‘æ§ç»„ä»¶** (`SystemMonitorComponent`):
        *   å®æ—¶æ˜¾ç¤ºç³»ç»ŸçŠ¶æ€ï¼šå¥åº·çŠ¶æ€ã€æ´»åŠ¨ä»»åŠ¡æ•°é‡ã€ç‰ˆæœ¬ä¿¡æ¯ã€è¿è¡Œæ—¶é—´
        *   æ€§èƒ½æŒ‡æ ‡ç›‘æ§ï¼šCPUä½¿ç”¨ç‡ã€å†…å­˜ä½¿ç”¨ç‡ã€ç£ç›˜ä½¿ç”¨ç‡ã€ç½‘ç»œçŠ¶æ€
        *   å®æ—¶å›¾è¡¨å±•ç¤ºï¼šæ´»åŠ¨æµ‹è¯•æ•°é‡è¶‹åŠ¿ã€ç³»ç»Ÿå“åº”æ—¶é—´å›¾è¡¨
        *   ç³»ç»Ÿæ—¥å¿—ç®¡ç†ï¼šæ—¥å¿—ç­›é€‰ã€æ¸…é™¤åŠŸèƒ½ã€ä¸åŒçº§åˆ«æ—¥å¿—æ˜¾ç¤º
        *   è‡ªåŠ¨æ•°æ®åˆ·æ–°ï¼šæ¯5ç§’æ›´æ–°ç³»ç»ŸçŠ¶æ€ï¼Œæ¯2ç§’æ›´æ–°æ€§èƒ½æ•°æ®
    *   **æŠ¥å‘Šç”Ÿæˆç»„ä»¶** (`ReportGenerationComponent`):
        *   æŠ¥å‘Šç”Ÿæˆè¡¨å•ï¼šæ‰¹æ¬¡é€‰æ‹©ã€æ¨¡æ¿é€‰æ‹©ã€æ ¼å¼é€‰æ‹©ï¼ˆPDF/Excelï¼‰
        *   æŠ¥å‘Šå†å²ç®¡ç†ï¼šæŸ¥çœ‹ã€ä¸‹è½½ã€åˆ é™¤å†å²æŠ¥å‘Š
        *   å¤šæ ¼å¼æ”¯æŒï¼šPDFå’ŒExcelæ ¼å¼çš„æµ‹è¯•æŠ¥å‘Š
        *   è‡ªå®šä¹‰æŠ¥å‘Šæ¨¡æ¿å’Œé…ç½®é€‰é¡¹
    *   ç°ä»£åŒ–UIè®¾è®¡ï¼Œå“åº”å¼å¸ƒå±€ï¼Œå®Œå–„çš„é”™è¯¯å¤„ç†æœºåˆ¶
*   **å®æ–½æè¿° (Implementation Description)**:
    1.  **ç³»ç»Ÿç›‘æ§ç»„ä»¶å®ç°**:
        *   åˆ›å»º `SystemMonitorComponent` ç»„ä»¶ï¼ŒåŒ…å«å®Œæ•´çš„ç›‘æ§ç•Œé¢
        *   å®ç°å®æ—¶æ•°æ®è·å–å’Œæ›´æ–°æœºåˆ¶
        *   é›†æˆEChartså›¾è¡¨åº“è¿›è¡Œæ•°æ®å¯è§†åŒ–
        *   æ·»åŠ ç³»ç»Ÿæ—¥å¿—ç®¡ç†åŠŸèƒ½
        *   å®ç°å“åº”å¼è®¾è®¡å’Œç°ä»£åŒ–UI
    2.  **æŠ¥å‘Šç”Ÿæˆç»„ä»¶å®ç°**:
        *   åˆ›å»º `ReportGenerationComponent` ç»„ä»¶
        *   å®ç°æŠ¥å‘Šç”Ÿæˆè¡¨å•å’Œé…ç½®é€‰é¡¹
        *   æ·»åŠ æŠ¥å‘Šå†å²ç®¡ç†åŠŸèƒ½
        *   é›†æˆå¤šæ ¼å¼æŠ¥å‘Šå¯¼å‡ºåŠŸèƒ½
    3.  **è·¯ç”±å’Œå¯¼èˆªé›†æˆ**:
        *   åœ¨ `app.routes.ts` ä¸­æ·»åŠ ç›¸åº”è·¯ç”±é…ç½®
        *   åœ¨ä¸»å¯¼èˆªèœå•ä¸­æ·»åŠ é“¾æ¥
        *   ç¡®ä¿æ‡’åŠ è½½å’Œæ€§èƒ½ä¼˜åŒ–
    4.  **æœåŠ¡å±‚é›†æˆ**:
        *   é€šè¿‡ `TauriApiService` è°ƒç”¨åç«¯API
        *   å®ç°é”™è¯¯å¤„ç†å’ŒçŠ¶æ€ç®¡ç†
        *   æ·»åŠ å®æ—¶æ•°æ®è®¢é˜…å’Œæ›´æ–°æœºåˆ¶
*   **å¦‚ä½•æµ‹è¯• (How to Test)**:
    *   **ç³»ç»Ÿç›‘æ§åŠŸèƒ½**: éªŒè¯å®æ—¶æ•°æ®æ›´æ–°ã€å›¾è¡¨æ˜¾ç¤ºã€æ—¥å¿—ç®¡ç†ç­‰åŠŸèƒ½æ˜¯å¦æ­£å¸¸å·¥ä½œ
    *   **æŠ¥å‘Šç”ŸæˆåŠŸèƒ½**: æµ‹è¯•æŠ¥å‘Šç”Ÿæˆã€ä¸‹è½½ã€å†å²ç®¡ç†ç­‰åŠŸèƒ½
    *   **UIå“åº”æ€§**: æµ‹è¯•åœ¨ä¸åŒå±å¹•å°ºå¯¸ä¸‹çš„å¸ƒå±€è¡¨ç°
    *   **æ€§èƒ½æµ‹è¯•**: éªŒè¯é•¿æ—¶é—´è¿è¡Œæ—¶çš„æ€§èƒ½è¡¨ç°å’Œå†…å­˜ä½¿ç”¨æƒ…å†µ

---

## Phase 6: çœŸå®ç¡¬ä»¶è”è°ƒã€æ‰“åŒ…ä¸éƒ¨ç½²å‡†å¤‡

**ç›®æ ‡ï¼š** å°†ç³»ç»Ÿä¸çœŸå®çš„PLCç¡¬ä»¶è¿›è¡Œé›†æˆæµ‹è¯•ï¼Œç¡®ä¿æ‰€æœ‰åŠŸèƒ½åœ¨å®é™…ç¯å¢ƒä¸­æŒ‰é¢„æœŸå·¥ä½œã€‚å‡†å¤‡åº”ç”¨çš„æœ€ç»ˆæ‰“åŒ…å’Œéƒ¨ç½²ã€‚

### æ­¥éª¤ 6.1: `IPlcCommunicationService` çœŸå®å®ç°

*   **åŸå›  (Reason)**:
    *   Mock å®ç°æ— æ³•éªŒè¯ä¸çœŸå®PLCçš„é€šä¿¡ã€‚
    *   éœ€è¦é’ˆå¯¹ç›®æ ‡PLCå‹å·å’Œé€šä¿¡åè®®ï¼ˆå¦‚Modbus TCP, S7, OPC UAç­‰ï¼‰å®ç°å…·ä½“çš„é€šä¿¡é€»è¾‘ã€‚
*   **æœŸæœ›æ•ˆæœ (Expected Outcome)**:
    *   æ ¹æ®é¡¹ç›®é€‰ç”¨çš„PLCå‹å·å’Œåè®®ï¼Œé€‰æ‹©åˆé€‚çš„Rust crate (å¦‚ `tokio-modbus`, `s7-rs`, `opcua` ç­‰) æˆ–è‡ªè¡Œå®ç°é€šä¿¡åè®®çš„å¿…è¦éƒ¨åˆ†ã€‚
    *   å®ç° `RealPlcCommunicationService` structï¼Œå®Œæ•´å®ç° `IPlcCommunicationService` trait ä¸­å®šä¹‰çš„æ‰€æœ‰æ–¹æ³• (connect, disconnect, read/write various types)ã€‚
    *   åŒ…å«è¯¦ç»†çš„é”™è¯¯å¤„ç†å’Œé‡è¿æœºåˆ¶ã€‚
    *   èƒ½å¤Ÿåœ¨å¼€å‘ç¯å¢ƒä¸­è¿æ¥åˆ°æµ‹è¯•ç”¨PLCå¹¶æˆåŠŸè¯»å†™æ•°æ®ã€‚
*   **å®æ–½æè¿° (Implementation Description)**:
    1.  **é€‰æ‹©/å®ç°åè®®åº“**: 
        *   Modbus TCP: ä½¿ç”¨ `tokio-modbus`ã€‚
        *   Siemens S7: ä½¿ç”¨ `s7-rs` æˆ–å…¶ä»–ç±»ä¼¼åº“ã€‚
        *   OPC UA: ä½¿ç”¨ `opcua` crateã€‚
        *   å¦‚æœåè®®ç‰¹æ®Šæˆ–æ²¡æœ‰ç°æˆåº“ï¼Œå¯èƒ½éœ€è¦åŸºäºTCP/UDPå¥—æ¥å­—å’Œåè®®æ–‡æ¡£è‡ªè¡Œå®ç°ã€‚
    2.  **`RealPlcCommunicationService` å®ç°**: 
        *   `connect`: å»ºç«‹ä¸PLCçš„è¿æ¥ (e.g., `tokio_modbus::client::tcp::connect_slave`).
        *   `disconnect`: å…³é—­è¿æ¥ã€‚
        *   `read_bool/f32/u16`ç­‰: è°ƒç”¨ç›¸åº”åº“çš„è¯»çº¿åœˆ/ä¿æŒå¯„å­˜å™¨ç­‰åŠŸèƒ½ï¼Œå¹¶å¤„ç†æ•°æ®ç±»å‹è½¬æ¢ã€‚
            *   ä¾‹å¦‚, `tokio-modbus`: `ctx.read_coils(addr, count).await?`, `ctx.read_holding_registers(addr, count).await?`ã€‚
            *   éœ€è¦å¤„ç†å­—èŠ‚åº (endianness) å’Œæ•°æ®ç±»å‹è½¬æ¢ (e.g., ä¸¤ä¸ªu16å¯„å­˜å™¨ç»„åˆæˆf32)ã€‚
        *   `write_X`: è°ƒç”¨ç›¸åº”åº“çš„å†™åŠŸèƒ½ã€‚
        *   é”™è¯¯å¤„ç†: åŒ…è£…åº“è¿”å›çš„é”™è¯¯åˆ° `AppError::PlcCommunicationError`ï¼Œæä¾›æ¸…æ™°çš„é”™è¯¯ä¿¡æ¯ã€‚
        *   é‡è¿æœºåˆ¶: å®ç°ç®€å•çš„è‡ªåŠ¨é‡è¿é€»è¾‘ï¼Œä¾‹å¦‚åœ¨è¿æ¥æ–­å¼€æˆ–è¯»å†™å¤±è´¥åå°è¯•å‡ æ¬¡é‡è¿ã€‚
    3.  **é…ç½®**: PLCçš„IPåœ°å€ã€ç«¯å£ã€Slave IDç­‰åº”å¯é…ç½® (ä¾‹å¦‚é€šè¿‡ä¹‹å‰å®ç°çš„è®¾ç½®åŠŸèƒ½æˆ–é…ç½®æ–‡ä»¶)ã€‚
*   **å¦‚ä½•æµ‹è¯• (How to Test)**:
    *   **ç‹¬ç«‹å•å…ƒæµ‹è¯•/é›†æˆæµ‹è¯• (è¿æ¥çœŸå®PLC)**: 
        *   å‡†å¤‡ä¸€ä¸ªæµ‹è¯•PLCç¨‹åºï¼ŒåŒ…å«å„ç§ç±»å‹çš„æµ‹è¯•ç‚¹ä½ï¼ˆå¼€å…³é‡ã€æ¨¡æ‹Ÿé‡è¾“å…¥è¾“å‡ºï¼‰ã€‚
        *   ç¼–å†™æµ‹è¯•ç”¨ä¾‹ï¼Œç›´æ¥è°ƒç”¨ `RealPlcCommunicationService` çš„æ–¹æ³•ï¼š
            *   æµ‹è¯•è¿æ¥å’Œæ–­å¼€ã€‚
            *   å¯¹å·²çŸ¥åœ°å€å’Œå€¼çš„ç‚¹ä½è¿›è¡Œè¯»æ“ä½œï¼ŒéªŒè¯è¿”å›å€¼æ˜¯å¦ä¸PLCä¸­çš„å®é™…å€¼ä¸€è‡´ã€‚
            *   å¯¹å·²çŸ¥åœ°å€çš„ç‚¹ä½è¿›è¡Œå†™æ“ä½œï¼Œç„¶ååœ¨PLCç›‘æ§è½¯ä»¶ä¸­æˆ–é€šè¿‡åç»­è¯»æ“ä½œéªŒè¯å€¼æ˜¯å¦è¢«æˆåŠŸå†™å…¥ã€‚
            *   æµ‹è¯•ä¸åŒæ•°æ®ç±»å‹ï¼ˆbool, u16, f32, etc.ï¼‰ã€‚
            *   æµ‹è¯•å¹¶å‘è¯»å†™ (å¦‚æœ `RealPlcCommunicationService` è®¾è®¡ä¸ºæ”¯æŒï¼Œä¾‹å¦‚å†…éƒ¨ä½¿ç”¨ `Mutex` ä¿æŠ¤å®¢æˆ·ç«¯ä¸Šä¸‹æ–‡)ã€‚
            *   æµ‹è¯•PLCæ–­å¼€è¿æ¥æˆ–ç½‘ç»œæ•…éšœæ—¶çš„é”™è¯¯æŠ¥å‘Šå’Œé‡è¿è¡Œä¸ºã€‚

### æ­¥éª¤ 6.2: æ›¿æ¢ Mock æœåŠ¡ä¸ºçœŸå®å®ç°å¹¶è¿›è¡Œå®Œæ•´æµç¨‹è”è°ƒ

*   **åŸå›  (Reason)**:
    *   ç¡®ä¿æ•´ä¸ªåº”ç”¨åœ¨çœŸå®ç¡¬ä»¶ç¯å¢ƒä¸‹èƒ½æ­£å¸¸å·¥ä½œã€‚
*   **æœŸæœ›æ•ˆæœ (Expected Outcome)**:
    *   åœ¨ `src-tauri/src/main.rs` ä¸­ï¼Œå°† `MockPlcCommunicationService` å’Œ `MockPersistenceService` (å¦‚æœä¹‹å‰ç”¨çš„æ˜¯Mock) æ›¿æ¢ä¸º `RealPlcCommunicationService` å’Œ `JsonFilePersistenceService` (æˆ–æ•°æ®åº“å®ç°)ã€‚
    *   åœ¨è¿æ¥çœŸå®PLCå’Œç›®æ ‡æµ‹è¯•è®¾å¤‡çš„ç¯å¢ƒä¸­ï¼Œè¿è¡Œå®Œæ•´çš„ FAT æµ‹è¯•æµç¨‹ï¼š
        *   é€šè¿‡UIå¯¼å…¥Excelç‚¹ä½è¡¨ã€‚
        *   é…ç½®æ‰¹æ¬¡ä¿¡æ¯ã€‚
        *   æ‰§è¡Œï¼ˆæ¨¡æ‹Ÿçš„æˆ–çœŸå®çš„ï¼‰æ¥çº¿ç¡®è®¤ã€‚
        *   å¯åŠ¨è‡ªåŠ¨æµ‹è¯•ã€‚
        *   è§‚å¯ŸUIä¸Šæµ‹è¯•è¿›åº¦ã€å„é€šé“çŠ¶æ€çš„å®æ—¶æ›´æ–°ã€‚
        *   æ‰§è¡Œéƒ¨åˆ†æ‰‹åŠ¨æµ‹è¯•é¡¹ã€‚
        *   éªŒè¯æµ‹è¯•ç»“æœæ˜¯å¦ä¸é¢„æœŸä¸€è‡´ (éœ€è¦äººå·¥æ¯”å¯¹PLCçŠ¶æ€å’ŒUIæ˜¾ç¤º)ã€‚
        *   éªŒè¯æµ‹è¯•æŠ¥å‘Šæ˜¯å¦èƒ½æ­£ç¡®ç”Ÿæˆå’Œå¯¼å‡ºã€‚
    *   æ‰€æœ‰åŠŸèƒ½æŒ‰é¢„æœŸå·¥ä½œï¼Œæ•°æ®å‡†ç¡®ï¼Œç³»ç»Ÿç¨³å®šã€‚
*   **å®æ–½æè¿° (Implementation Description)**:
    1.  **ä¿®æ”¹ `main.rs`**: æ›´æ–°æœåŠ¡å®ä¾‹åŒ–éƒ¨åˆ†ï¼Œä½¿ç”¨çœŸå®çš„PLCæœåŠ¡å’Œä¸»è¦çš„æ•°æ®åº“æŒä¹…åŒ–æœåŠ¡ã€‚
        ```rust
        // src-tauri/src/main.rs
        // ...
        use crate::services::infrastructure::persistence::SqliteOrmPersistenceService; // ç¡®ä¿å¼•å…¥
        // ...
        let plc_service = Arc::new(RealPlcCommunicationService::new(/* plc config */)); // ä¼ å…¥PLCé…ç½®
        // ä¸»æŒä¹…åŒ–æœåŠ¡ï¼Œç”¨äºæ•°æ®åº“æ“ä½œ
        let db_path = "fat_test_app.sqlite"; // ä»é…ç½®æˆ–Tauri APIè·å–
        let persistence_service = Arc::new(
            SqliteOrmPersistenceService::new(db_path).await.expect("Failed to initialize DB for testing")
        );
        // AppSettings ç­‰é…ç½®ç°åœ¨ç”±ä¸“é—¨çš„ AppSettingsService å¤„ç†ï¼Œä½¿ç”¨JSONæ–‡ä»¶å­˜å‚¨ã€‚
        
        // ...ç„¶åç”¨è¿™äº›å®ä¾‹åˆ›å»ºå…¶ä»–æœåŠ¡ï¼Œå¦‚ TestRecordService, DataManagementService ç­‰ï¼Œ
        // å®ƒä»¬å°†é€šè¿‡æ³¨å…¥çš„ IPersistenceService ä¸ SQLite æ•°æ®åº“äº¤äº’ã€‚
        ```
    2.  **ç¯å¢ƒå‡†å¤‡**: 
        *   è¿æ¥å¥½PLCã€æµ‹è¯•å°æ¶ã€è¢«æµ‹è®¾å¤‡ã€‚
        *   ç¡®ä¿ç½‘ç»œé€šç•…ï¼ŒPLCç¨‹åºå·²ä¸‹è½½å¹¶è¿è¡Œã€‚
    3.  **æ‰§è¡Œæµ‹è¯•åœºæ™¯**: 
        *   **å®Œæ•´è‡ªåŠ¨æµ‹è¯•**: å¯¼å…¥ä¸€ä¸ªåŒ…å«å„ç§ç±»å‹ç‚¹ä½çš„Excelè¡¨ï¼Œè¿è¡Œå®Œæ•´æµ‹è¯•æµç¨‹ã€‚
        *   **æ‰‹åŠ¨å¹²é¢„æµ‹è¯•**: åœ¨è‡ªåŠ¨æµ‹è¯•è¿‡ç¨‹ä¸­æˆ–å®Œæˆåï¼Œè¿›è¡Œæ‰‹åŠ¨æµ‹è¯•æ“ä½œã€‚
        *   **å¼‚å¸¸å¤„ç†æµ‹è¯•**: æ¨¡æ‹ŸPLCé€šä¿¡ä¸­æ–­ã€è®¾å¤‡æ•…éšœç­‰æƒ…å†µï¼Œè§‚å¯Ÿç³»ç»Ÿååº”å’Œé”™è¯¯æç¤ºã€‚
        *   **æ•°æ®ä¸€è‡´æ€§æ£€æŸ¥**: å¯¹æ¯”UIæ˜¾ç¤ºçš„æµ‹è¯•ç»“æœã€å¯¼å‡ºçš„æŠ¥å‘Šä¸PLCçš„å®é™…çŠ¶æ€ã€‚
        *   **é•¿æ—¶é—´è¿è¡Œæµ‹è¯•**: (å¦‚æœæ¡ä»¶å…è®¸) è®©ç³»ç»Ÿé•¿æ—¶é—´è¿è¡Œï¼Œæ£€æŸ¥æ˜¯å¦æœ‰å†…å­˜æ³„æ¼æˆ–æ€§èƒ½ä¸‹é™ã€‚
*   **å¦‚ä½•æµ‹è¯• (How to Test)**:
    *   **ç«¯åˆ°ç«¯åœºæ™¯é€šè¿‡æ€§**: å¦‚"å®æ–½æè¿°"ä¸­æ‰€åˆ—çš„å„é¡¹æµ‹è¯•åœºæ™¯èƒ½å¤Ÿé¡ºåˆ©å®Œæˆï¼Œå¹¶ä¸”ç»“æœç¬¦åˆé¢„æœŸã€‚
    *   **æ—¥å¿—åˆ†æ**: ä»”ç»†æ£€æŸ¥Ruståç«¯æ—¥å¿—å’Œå‰ç«¯æ§åˆ¶å°æ—¥å¿—ï¼Œæ’æŸ¥ä»»ä½•é”™è¯¯æˆ–å¼‚å¸¸ã€‚
    *   **äººå·¥è§‚å¯Ÿä¸éªŒè¯**: æµ‹è¯•å·¥ç¨‹å¸ˆæ ¹æ®æµ‹è¯•ç”¨ä¾‹ï¼Œæ¯”å¯¹ç³»ç»Ÿè¡Œä¸ºå’Œé¢„æœŸç»“æœã€‚

### æ­¥éª¤ 6.3: åº”ç”¨å›¾æ ‡ã€å…ƒæ•°æ®å’Œæ‰“åŒ…é…ç½®

*   **åŸå›  (Reason)**:
    *   ä¸ºåº”ç”¨æä¾›ä¸“ä¸šçš„é—¨é¢å’Œæ­£ç¡®çš„æ‰“åŒ…ä¿¡æ¯ï¼Œä»¥ä¾¿ç”Ÿæˆå¯åˆ†å‘çš„å®‰è£…åŒ…ã€‚
*   **æœŸæœ›æ•ˆæœ (Expected Outcome)**:
    *   ä¸ºåº”ç”¨è®¾è®¡å¹¶å‡†å¤‡ä¸åŒå°ºå¯¸çš„å›¾æ ‡æ–‡ä»¶ (å¦‚ .ico, .png, .icns)ã€‚
    *   åœ¨ `tauri.conf.json` ä¸­é…ç½®åº”ç”¨å…ƒæ•°æ®ï¼š
        *   `package.productName`, `package.version`
        *   `tauri.bundle.identifier` (å”¯ä¸€åŒ…åï¼Œå¦‚ `com.mycompany.fattesst`)
        *   `tauri.bundle.icon` (æŒ‡å‘å›¾æ ‡æ–‡ä»¶åˆ—è¡¨)
        *   `tauri.bundle.publisher`, `tauri.bundle.copyright` ç­‰ã€‚
    *   é…ç½®ç‰¹å®šå¹³å°çš„æ‰“åŒ…é€‰é¡¹ (å¦‚Windowsçš„ `nsis` æˆ– `msi`ï¼ŒmacOSçš„ `.app` å’Œ `.dmg`)ã€‚
*   **å®æ–½æè¿° (Implementation Description)**:
    1.  **åˆ›å»ºå›¾æ ‡**: ä½¿ç”¨å›¾åƒç¼–è¾‘å·¥å…·åˆ›å»ºç¬¦åˆå„å¹³å°è¦æ±‚çš„å›¾æ ‡æ–‡ä»¶ï¼Œå¹¶æ”¾ç½®åœ¨ `src-tauri/icons` æˆ–çº¦å®šçš„ç›®å½•ä¸­ã€‚
        *   Windows: é€šå¸¸éœ€è¦ä¸€ä¸ª `.ico` æ–‡ä»¶ï¼ŒåŒ…å«å¤šç§å°ºå¯¸ (e.g., 16x16, 32x32, 48x48, 256x256)ã€‚
        *   macOS: éœ€è¦ä¸€ä¸ª `.icns` æ–‡ä»¶é›†ã€‚
        *   Linux: é€šå¸¸ä½¿ç”¨ `.png`ã€‚
    2.  **ä¿®æ”¹ `tauri.conf.json`**: 
        ```json
        {
          "package": {
            "productName": "FAT Test Suite",
            "version": "1.0.0"
          },
          "tauri": {
            "bundle": {
              "active": true,
              "identifier": "com.example.fattest",
              "icon": [
                "icons/32x32.png",
                "icons/128x128.png",
                "icons/128x128@2x.png",
                "icons/icon.icns",
                "icons/icon.ico"
              ],
              "publisher": "My Company",
              "copyright": "Copyright Â© My Company 2023",
              // ... Windows specific (NSIS or WiX/MSI)
              "windows": {
                "certificateThumbprint": null, // For code signing
                "digestAlgorithm": "sha256",
                "timestampUrl": "",
                "nsis": {
                    "installerIcon": "icons/installer.ico",
                    "sidebarImage": "icons/sidebar.bmp", // Optional
                    "headerImage": "icons/header.bmp" // Optional
                }
              },
              // ... macOS specific
              "macOS": {
                "frameworks": [],
                "minimumSystemVersion": "10.13",
                "exceptionDomain": "",
                "signingIdentity": null, // For code signing
                "providerShortName": null,
                "entitlements": null
              }
            }
            // ...
          }
        }
        ```
    3.  æŸ¥é˜… Tauri æ‰“åŒ…å’Œç­¾åçš„å®˜æ–¹æ–‡æ¡£ï¼Œäº†è§£å„å¹³å°ç‰¹å®šé…ç½®çš„è¯¦ç»†ä¿¡æ¯ã€‚
*   **å¦‚ä½•æµ‹è¯• (How to Test)**:
    *   **é…ç½®éªŒè¯**: ä»”ç»†æ£€æŸ¥ `tauri.conf.json` ä¸­çš„è·¯å¾„å’Œå€¼æ˜¯å¦æ­£ç¡®ã€‚
    *   åç»­é€šè¿‡å®é™…æ‰“åŒ…æ¥éªŒè¯å›¾æ ‡å’Œå…ƒæ•°æ®æ˜¯å¦æ­£ç¡®åº”ç”¨åˆ°å®‰è£…åŒ…å’Œå·²å®‰è£…çš„åº”ç”¨ä¸Šã€‚

### æ­¥éª¤ 6.4: æ„å»ºç”Ÿäº§ç‰ˆæœ¬å¹¶æµ‹è¯•å®‰è£…åŒ…

*   **åŸå›  (Reason)**:
    *   ç”Ÿæˆæœ€ç»ˆçš„å¯åˆ†å‘å®‰è£…åŒ…ï¼Œå¹¶åœ¨å¹²å‡€çš„ç¯å¢ƒä¸­æµ‹è¯•å…¶å®‰è£…å’Œè¿è¡Œæƒ…å†µã€‚
*   **æœŸæœ›æ•ˆæœ (Expected Outcome)**:
    *   è¿è¡Œ `npm run tauri build` æˆåŠŸç”Ÿæˆç›®æ ‡å¹³å°çš„å®‰è£…åŒ… (å¦‚ `.msi` æˆ– `.exe` for Windows, `.dmg` for macOS, `.deb` or `.AppImage` for Linux)ã€‚
    *   åœ¨å¹²å‡€çš„è™šæ‹Ÿæœºæˆ–ç‰©ç†æœºï¼ˆæœªå®‰è£…è¿‡å¼€å‘ç¯å¢ƒï¼‰ä¸ŠæˆåŠŸå®‰è£…åº”ç”¨ç¨‹åºã€‚
    *   å®‰è£…åçš„åº”ç”¨ç¨‹åºèƒ½å¤Ÿæ­£å¸¸å¯åŠ¨ï¼Œå›¾æ ‡ã€åç§°ç­‰å…ƒæ•°æ®æ­£ç¡®æ˜¾ç¤ºã€‚
    *   åº”ç”¨çš„æ ¸å¿ƒåŠŸèƒ½ï¼ˆå¦‚å¯¼å…¥ã€è¿æ¥PLCï¼ˆå¦‚æœæµ‹è¯•ç¯å¢ƒå…è®¸ï¼‰ã€æ˜¾ç¤ºæ•°æ®ï¼‰èƒ½å¤ŸåŸºæœ¬å·¥ä½œã€‚
*   **å®æ–½æè¿° (Implementation Description)**:
    1.  **æ‰§è¡Œæ„å»ºå‘½ä»¤**: åœ¨é¡¹ç›®æ ¹ç›®å½•è¿è¡Œ `npm run tauri build`ã€‚
    2.  **å®šä½å®‰è£…åŒ…**: æ„å»ºæˆåŠŸåï¼Œå®‰è£…åŒ…é€šå¸¸ä½äº `src-tauri/target/release/bundle/` ç›®å½•ä¸‹å¯¹åº”çš„å¹³å°æ–‡ä»¶å¤¹ä¸­ã€‚
    3.  **æµ‹è¯•ç¯å¢ƒå‡†å¤‡**: å‡†å¤‡ä¸€ä¸ªæˆ–å¤šä¸ªå¹²å‡€çš„æµ‹è¯•ç¯å¢ƒ (è™šæ‹Ÿæœºæ˜¯ç†æƒ³é€‰æ‹©)ï¼Œè¦†ç›–ç›®æ ‡æ“ä½œç³»ç»Ÿç‰ˆæœ¬ã€‚
    4.  **å®‰è£…æµ‹è¯•**: 
        *   å°†å®‰è£…åŒ…æ‹·è´åˆ°æµ‹è¯•ç¯å¢ƒã€‚
        *   æ‰§è¡Œå®‰è£…ç¨‹åºï¼Œæ³¨æ„å®‰è£…è¿‡ç¨‹ä¸­çš„æç¤ºã€é€‰é¡¹ã€è®¸å¯åè®®ï¼ˆå¦‚æœé…ç½®äº†ï¼‰ã€‚
        *   éªŒè¯å®‰è£…è·¯å¾„ã€å¼€å§‹èœå•/æ¡Œé¢å¿«æ·æ–¹å¼æ˜¯å¦æ­£ç¡®åˆ›å»ºã€‚
    5.  **è¿è¡Œæµ‹è¯•**: 
        *   ä»å¿«æ·æ–¹å¼æˆ–å®‰è£…ç›®å½•å¯åŠ¨åº”ç”¨ã€‚
        *   æ£€æŸ¥åº”ç”¨çª—å£æ ‡é¢˜ã€å›¾æ ‡æ˜¯å¦æ­£ç¡®ã€‚
        *   æ‰§è¡ŒåŸºæœ¬çš„æ ¸å¿ƒåŠŸèƒ½è¿›è¡Œå†’çƒŸæµ‹è¯•ã€‚
        *   æ£€æŸ¥åº”ç”¨æ˜¯å¦èƒ½æ­£ç¡®åˆ›å»ºå’Œè®¿é—®å…¶æ•°æ®æ–‡ä»¶ï¼ˆå¦‚JSONæŒä¹…åŒ–æ–‡ä»¶ï¼Œæ—¥å¿—æ–‡ä»¶ï¼‰ã€‚
    6.  **å¸è½½æµ‹è¯•**: æµ‹è¯•åº”ç”¨çš„å¸è½½è¿‡ç¨‹æ˜¯å¦å¹²å‡€ï¼Œæ˜¯å¦æ­£ç¡®ç§»é™¤äº†æ‰€æœ‰æ–‡ä»¶å’Œæ³¨å†Œè¡¨é¡¹ï¼ˆå¦‚æœé€‚ç”¨ï¼‰ã€‚
*   **å¦‚ä½•æµ‹è¯• (How to Test)**:
    *   **æ„å»ºæˆåŠŸ**: `tauri build` å‘½ä»¤æ— é”™è¯¯å®Œæˆã€‚
    *   **å®‰è£…/å¸è½½æˆåŠŸ**: åœ¨ç›®æ ‡å¹³å°ä¸Šï¼Œå®‰è£…å’Œå¸è½½è¿‡ç¨‹ç¬¦åˆé¢„æœŸã€‚
    *   **åº”ç”¨è¿è¡Œæ­£å¸¸**: å®‰è£…åçš„åº”ç”¨èƒ½å¤Ÿå¯åŠ¨å¹¶æ‰§è¡Œæ ¸å¿ƒåŠŸèƒ½ï¼Œæ— æ˜æ˜¾å´©æºƒæˆ–é”™è¯¯ã€‚
    *   **å…ƒæ•°æ®æ­£ç¡®**: åº”ç”¨çš„åç§°ã€å›¾æ ‡ã€ç‰ˆæœ¬å·ç­‰åœ¨æ“ä½œç³»ç»Ÿä¸­æ­£ç¡®æ˜¾ç¤ºã€‚

### æ­¥éª¤ 6.5: ç¼–å†™ç”¨æˆ·æ‰‹å†Œå’Œéƒ¨ç½²æ–‡æ¡£ (å¯é€‰)

*   **åŸå›  (Reason)**:
    *   ä¸ºæœ€ç»ˆç”¨æˆ·å’Œéƒ¨ç½²äººå‘˜æä¾›å¿…è¦çš„æŒ‡å¯¼ã€‚
*   **æœŸæœ›æ•ˆæœ (Expected Outcome)**:
    *   **ç”¨æˆ·æ‰‹å†Œ**: æè¿°å¦‚ä½•å®‰è£…ã€é…ç½®å’Œä½¿ç”¨åº”ç”¨çš„ä¸»è¦åŠŸèƒ½ï¼ŒåŒ…å«æˆªå›¾å’Œæ“ä½œæ­¥éª¤ã€‚
    *   **éƒ¨ç½²æ–‡æ¡£**: (å¦‚æœåº”ç”¨æœ‰ç‰¹æ®Šçš„æœåŠ¡å™¨ç«¯æˆ–ç¯å¢ƒä¾èµ–) æè¿°éƒ¨ç½²ç¯å¢ƒè¦æ±‚ã€é…ç½®æ­¥éª¤ã€æ•…éšœæ’é™¤æŒ‡å—ã€‚
*   **å®æ–½æè¿° (Implementation Description)**:
    1.  æ ¹æ®åº”ç”¨åŠŸèƒ½ï¼Œç¼–å†™ç”¨æˆ·æ“ä½œæµç¨‹ã€‚
    2.  æˆªå›¾å¹¶åŠ ä»¥è¯´æ˜ã€‚
    3.  æ•´ç†éƒ¨ç½²æ‰€éœ€çš„ç³»ç»Ÿè¦æ±‚ã€ä¾èµ–é¡¹ã€é…ç½®æ–‡ä»¶è¯´æ˜ç­‰ã€‚
*   **å¦‚ä½•æµ‹è¯• (How to Test)**:
    *   **æ–‡æ¡£å®¡é˜…**: ç”±ä¸ç†Ÿæ‚‰é¡¹ç›®çš„æµ‹è¯•äººå‘˜æˆ–åŒäº‹æŒ‰ç…§æ–‡æ¡£è¿›è¡Œæ“ä½œï¼Œæ£€æŸ¥æ–‡æ¡£çš„æ¸…æ™°åº¦ã€å‡†ç¡®æ€§å’Œå®Œæ•´æ€§ã€‚
    *   **å®é™…æ“ä½œéªŒè¯**: æŒ‰ç…§éƒ¨ç½²æ–‡æ¡£åœ¨æµ‹è¯•ç¯å¢ƒä¸­å°è¯•éƒ¨ç½²ï¼ŒéªŒè¯æ­¥éª¤å¯è¡Œæ€§ã€‚

---
**é¡¹ç›®å®Œæˆï¼åç»­å¯èƒ½è¿›å…¥ç»´æŠ¤å’Œè¿­ä»£å‘¨æœŸã€‚**
