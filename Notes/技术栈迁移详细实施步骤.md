# 技术栈迁移详细实施步骤方案 (FAT_TEST 项目)

## 项目目录结构 (Project Directory Structure)

以下是基于 Rust + Angular + Tauri 技术栈的完整项目目录结构，涵盖了后端服务、前端UI和桌面应用打包的所有组件：

```
fat-test-desktop-app/                          # Tauri 项目根目录
├── README.md                                  # 项目总体说明文档
├── package.json                               # npm scripts for Tauri commands
├── node_modules/                              # Node.js 依赖 (Tauri CLI 等)
│
├── src-tauri/                                 # Rust 后端 + Tauri 集成
│   ├── Cargo.toml                            # Rust 依赖配置
│   ├── Cargo.lock                            # 锁定的依赖版本
│   ├── tauri.conf.json                       # Tauri 应用配置
│   ├── build.rs                              # 构建脚本
│   ├── icons/                                # 应用图标资源
│   │   ├── 32x32.png
│   │   ├── 128x128.png
│   │   ├── 128x128@2x.png
│   │   ├── icon.icns                         # macOS 图标
│   │   ├── icon.ico                          # Windows 图标
│   │   ├── installer.ico                     # 安装程序图标
│   │   └── Square***.png                     # Windows Store 图标
│   │
│   └── src/                                  # Rust 源代码
│       ├── main.rs                           # Tauri 应用入口点
│       ├── lib.rs                            # 库根模块 (可选)
│       │
│       ├── commands/                         # Tauri Commands (前端调用接口)
│       │   ├── mod.rs
│       │   ├── batch_management.rs           # 批次管理相关命令
│       │   ├── test_orchestration.rs         # 测试编排相关命令
│       │   ├── manual_test.rs                # 手动测试相关命令
│       │   ├── data_management.rs            # 数据管理相关命令
│       │   ├── channel_config.rs             # 通道配置相关命令
│       │   └── system_settings.rs            # 系统设置相关命令
│       │
│       ├── events/                           # Tauri Events (后端推送给前端)
│       │   ├── mod.rs
│       │   ├── channel_state_events.rs       # 通道状态变更事件
│       │   ├── batch_progress_events.rs      # 批次进度事件
│       │   ├── log_events.rs                 # 日志事件
│       │   └── system_events.rs              # 系统状态事件
│       │
│       ├── state/                            # Tauri 状态管理
│       │   ├── mod.rs
│       │   ├── app_state.rs                  # 应用全局状态
│       │   └── service_container.rs          # 服务容器/依赖注入
│       │
│       ├── models/                           # 数据模型层
│       │   ├── mod.rs
│       │   ├── enums.rs                      # 核心枚举定义
│       │   │   └── # OverallTestStatus, SubTestStatus, ModuleType, 
│       │   │       # PointDataType, SubTestItem, LogLevelEvent
│       │   ├── structs.rs                    # 核心结构体定义
│       │   │   └── # ChannelPointDefinition, ChannelTestInstance, 
│       │   │       # TestBatchInfo, RawTestOutcome, SubTestExecutionResult,
│       │   │       # AnalogReadingPoint
│       │   ├── command_payloads.rs           # Tauri Command 参数/响应模型
│       │   │   └── # ImportExcelAndPrepareBatchCmdArgs, StartTestsForBatchCmdArgs,
│       │   │       # ImportAndPrepareBatchResponse, BatchDetailsPayload,
│       │   │       # ExecuteManualSubTestCmdArgs, ReadChannelValueCmdArgs
│       │   ├── event_payloads.rs             # Tauri Event Payload 模型
│       │   │   └── # ChannelStateChangedEventPayload, BatchProgressEventPayload,
│       │   │       # LogMessageEventPayload
│       │   └── settings.rs                   # 应用设置数据模型
│       │       └── # AppSettings, PlcConnectionSettings, TestConfiguration
│       │
│       ├── services/                         # 业务服务层
│       │   ├── mod.rs
│       │   │
│       │   ├── application/                  # 应用层服务 (编排业务用例)
│       │   │   ├── mod.rs
│       │   │   ├── test_orchestration_service.rs  # 测试编排服务 (核心)
│       │   │   ├── data_management_service.rs     # 数据管理服务 (导入/导出)
│       │   │   ├── manual_test_service.rs         # 手动测试服务
│       │   │   ├── channel_config_service.rs      # 通道配置服务
│       │   │   └── notification_service.rs        # 通知/事件发布服务
│       │   │
│       │   ├── domain/                       # 领域服务层 (核心业务逻辑)
│       │   │   ├── mod.rs
│       │   │   ├── channel_state_manager.rs       # 通道状态管理器 (唯一状态修改点)
│       │   │   ├── test_execution_engine.rs       # 测试执行引擎 (并发控制)
│       │   │   ├── specific_test_executors/       # 特定测试步骤执行器
│       │   │   │   ├── mod.rs
│       │   │   │   ├── ai_test_executor.rs        # AI点测试执行器
│       │   │   │   ├── ao_test_executor.rs        # AO点测试执行器
│       │   │   │   ├── di_test_executor.rs        # DI点测试执行器
│       │   │   │   ├── do_test_executor.rs        # DO点测试执行器
│       │   │   │   ├── communication_test_executor.rs # 通信测试
│       │   │   │   └── generic_read_write_executor.rs # 通用读写执行器
│       │   │   ├── statistics_service.rs          # 统计服务
│       │   │   └── test_record_service.rs         # 测试记录服务
│       │   │
│       │   └── infrastructure/               # 基础设施层 (外部系统交互)
│       │       ├── mod.rs
│       │       ├── plc/                      # PLC 通信相关
│       │       │   ├── mod.rs
│       │       │   ├── plc_communication_service.rs  # PLC通信服务接口
│       │       │   ├── mock_plc_service.rs           # Mock PLC服务 (开发/测试)
│       │       │   ├── modbus_plc_service.rs         # Modbus TCP PLC服务
│       │       │   ├── s7_plc_service.rs             # Siemens S7 PLC服务
│       │       │   └── opcua_plc_service.rs          # OPC UA PLC服务
│       │       ├── persistence/              # 数据持久化相关
│       │       │   ├── mod.rs
│       │       │   ├── persistence_service.rs       # 持久化服务接口
│       │       │   ├── json_file_persistence.rs     # JSON文件持久化
│       │       │   ├── sqlite_persistence.rs        # SQLite数据库持久化
│       │       │   └── mock_persistence.rs          # Mock持久化服务
│       │       └── excel/                    # Excel 处理相关
│       │           ├── mod.rs
│       │           ├── excel_importer.rs            # Excel导入器
│       │           └── excel_exporter.rs            # Excel导出器
│       │
│       ├── utils/                            # 工具模块
│       │   ├── mod.rs
│       │   ├── error.rs                      # 错误类型定义 (AppError)
│       │   ├── logging.rs                    # 日志配置
│       │   ├── config.rs                     # 配置加载/管理
│       │   └── conversion.rs                 # 数据类型转换工具
│       │
│       └── tests/                            # 集成测试
│           ├── mod.rs
│           ├── command_tests.rs              # Tauri Command 测试
│           ├── service_integration_tests.rs  # 服务集成测试
│           └── mock_data.rs                  # 测试数据生成
│
├── fat-test-frontend/                        # Angular 前端应用
│   ├── README.md                             # 前端项目说明
│   ├── package.json                          # npm 依赖和脚本
│   ├── package-lock.json
│   ├── angular.json                          # Angular 项目配置
│   ├── tsconfig.json                         # TypeScript 配置
│   ├── tsconfig.app.json
│   ├── tsconfig.spec.json
│   ├── karma.conf.js                         # 测试配置
│   ├── .eslintrc.json                        # ESLint 配置
│   │
│   ├── src/                                  # Angular 源代码
│   │   ├── main.ts                           # Angular 应用启动入口
│   │   ├── index.html                        # HTML 入口
│   │   ├── styles.scss                       # 全局样式
│   │   ├── favicon.ico
│   │   │
│   │   ├── app/                              # Angular 应用根模块
│   │   │   ├── app.module.ts                 # 根模块
│   │   │   ├── app.component.ts              # 根组件
│   │   │   ├── app.component.html
│   │   │   ├── app.component.scss
│   │   │   ├── app.component.spec.ts
│   │   │   ├── app-routing.module.ts         # 路由配置
│   │   │   │
│   │   │   ├── models/                       # TypeScript 数据模型
│   │   │   │   ├── index.ts                  # 模型导出索引
│   │   │   │   ├── backend-models.ts         # 后端数据模型接口
│   │   │   │   │   └── # (TS interfaces for all Rust structs/enums)
│   │   │   │   │       # OverallTestStatus, SubTestStatus, ModuleType,
│   │   │   │   │       # ChannelPointDefinition, ChannelTestInstance,
│   │   │   │   │       # TestBatchInfo, RawTestOutcome, etc.
│   │   │   │   ├── command-models.ts         # Tauri Command 参数/响应接口
│   │   │   │   ├── event-models.ts           # Tauri Event Payload 接口
│   │   │   │   ├── ui-models.ts              # 前端特有的UI模型
│   │   │   │   └── form-models.ts            # 表单数据模型
│   │   │   │
│   │   │   ├── services/                     # Angular 服务层
│   │   │   │   ├── index.ts
│   │   │   │   ├── backend-comms.service.ts  # Tauri 通信封装服务
│   │   │   │   ├── test-orchestration-api.service.ts    # 测试编排API服务
│   │   │   │   ├── data-management-api.service.ts       # 数据管理API服务
│   │   │   │   ├── manual-test-api.service.ts           # 手动测试API服务
│   │   │   │   ├── channel-config-api.service.ts        # 通道配置API服务
│   │   │   │   ├── event-listener.service.ts            # Tauri事件监听服务
│   │   │   │   ├── ui-state.service.ts                  # UI状态管理服务
│   │   │   │   ├── notification.service.ts              # 通知/提示服务
│   │   │   │   └── settings.service.ts                  # 设置管理服务
│   │   │   │
│   │   │   ├── components/                   # Angular 组件
│   │   │   │   ├── shared/                   # 共享组件
│   │   │   │   │   ├── header/
│   │   │   │   │   │   ├── header.component.ts
│   │   │   │   │   │   ├── header.component.html
│   │   │   │   │   │   └── header.component.scss
│   │   │   │   │   ├── sidebar/
│   │   │   │   │   ├── loading-spinner/
│   │   │   │   │   ├── confirmation-dialog/
│   │   │   │   │   ├── status-indicator/      # 测试状态指示器
│   │   │   │   │   ├── progress-bar/          # 进度条组件
│   │   │   │   │   └── data-table/            # 通用数据表格
│   │   │   │   │
│   │   │   │   ├── batch-management/         # 批次管理页面
│   │   │   │   │   ├── batch-management.component.ts
│   │   │   │   │   ├── batch-management.component.html
│   │   │   │   │   ├── batch-management.component.scss
│   │   │   │   │   ├── batch-list/           # 批次列表子组件
│   │   │   │   │   ├── batch-create/         # 创建批次子组件
│   │   │   │   │   └── batch-details/        # 批次详情子组件
│   │   │   │   │
│   │   │   │   ├── data-import/              # 数据导入页面
│   │   │   │   │   ├── data-import.component.ts
│   │   │   │   │   ├── data-import.component.html
│   │   │   │   │   ├── data-import.component.scss
│   │   │   │   │   ├── excel-upload/         # Excel文件上传子组件
│   │   │   │   │   ├── point-preview/        # 点位预览子组件
│   │   │   │   │   └── import-progress/      # 导入进度子组件
│   │   │   │   │
│   │   │   │   ├── test-execution/           # 测试执行页面 (核心)
│   │   │   │   │   ├── test-execution.component.ts
│   │   │   │   │   ├── test-execution.component.html
│   │   │   │   │   ├── test-execution.component.scss
│   │   │   │   │   ├── channel-list/         # 通道列表子组件
│   │   │   │   │   ├── channel-detail/       # 通道详情子组件
│   │   │   │   │   ├── test-control-panel/   # 测试控制面板
│   │   │   │   │   ├── batch-progress/       # 批次进度显示
│   │   │   │   │   └── real-time-status/     # 实时状态监控
│   │   │   │   │
│   │   │   │   ├── manual-test/              # 手动测试页面
│   │   │   │   │   ├── manual-test.component.ts
│   │   │   │   │   ├── manual-test.component.html
│   │   │   │   │   ├── manual-test.component.scss
│   │   │   │   │   ├── manual-test-panel/    # 手动测试操作面板
│   │   │   │   │   ├── value-input/          # 数值输入子组件
│   │   │   │   │   ├── alarm-test/           # 报警测试子组件
│   │   │   │   │   └── reading-display/      # 读数显示子组件
│   │   │   │   │
│   │   │   │   ├── channel-configuration/    # 通道配置页面
│   │   │   │   │   ├── channel-configuration.component.ts
│   │   │   │   │   ├── channel-configuration.component.html
│   │   │   │   │   ├── channel-configuration.component.scss
│   │   │   │   │   ├── channel-editor/       # 通道编辑器
│   │   │   │   │   ├── module-config/        # 模块配置
│   │   │   │   │   └── plc-address-config/   # PLC地址配置
│   │   │   │   │
│   │   │   │   ├── reports/                  # 报告与导出页面
│   │   │   │   │   ├── reports.component.ts
│   │   │   │   │   ├── reports.component.html
│   │   │   │   │   ├── reports.component.scss
│   │   │   │   │   ├── test-results-report/  # 测试结果报告
│   │   │   │   │   ├── statistics-report/    # 统计报告
│   │   │   │   │   └── export-options/       # 导出选项
│   │   │   │   │
│   │   │   │   ├── system-settings/          # 系统设置页面
│   │   │   │   │   ├── system-settings.component.ts
│   │   │   │   │   ├── system-settings.component.html
│   │   │   │   │   ├── system-settings.component.scss
│   │   │   │   │   ├── plc-settings/         # PLC连接设置
│   │   │   │   │   ├── test-parameters/      # 测试参数设置
│   │   │   │   │   └── application-settings/ # 应用程序设置
│   │   │   │   │
│   │   │   │   └── logs/                     # 日志查看页面
│   │   │   │       ├── logs.component.ts
│   │   │   │       ├── logs.component.html
│   │   │   │       ├── logs.component.scss
│   │   │   │       ├── log-viewer/           # 日志查看器
│   │   │   │       └── log-filter/           # 日志筛选器
│   │   │   │
│   │   │   ├── pipes/                        # Angular 管道
│   │   │   │   ├── index.ts
│   │   │   │   ├── test-status.pipe.ts       # 测试状态显示管道
│   │   │   │   ├── duration.pipe.ts          # 时长格式化管道
│   │   │   │   ├── engineering-unit.pipe.ts  # 工程单位格式化管道
│   │   │   │   └── safe-html.pipe.ts         # 安全HTML管道
│   │   │   │
│   │   │   ├── directives/                   # Angular 指令
│   │   │   │   ├── index.ts
│   │   │   │   ├── auto-focus.directive.ts   # 自动聚焦指令
│   │   │   │   └── number-only.directive.ts  # 仅数字输入指令
│   │   │   │
│   │   │   ├── guards/                       # 路由守卫
│   │   │   │   ├── index.ts
│   │   │   │   ├── batch-loaded.guard.ts     # 批次加载完成守卫
│   │   │   │   └── unsaved-changes.guard.ts  # 未保存更改守卫
│   │   │   │
│   │   │   └── interceptors/                 # HTTP 拦截器
│   │   │       ├── index.ts
│   │   │       ├── error-handler.interceptor.ts  # 错误处理拦截器
│   │   │       └── loading.interceptor.ts         # 加载状态拦截器
│   │   │
│   │   ├── assets/                           # 静态资源
│   │   │   ├── images/                       # 图片资源
│   │   │   │   ├── logo.png
│   │   │   │   ├── icons/                    # UI图标
│   │   │   │   └── illustrations/            # 插画图片
│   │   │   ├── i18n/                         # 国际化文件
│   │   │   │   ├── en.json                   # 英文语言包
│   │   │   │   ├── zh-CN.json                # 中文语言包
│   │   │   │   └── zh-TW.json                # 繁体中文语言包
│   │   │   └── styles/                       # 样式文件
│   │   │       ├── _variables.scss           # SCSS变量
│   │   │       ├── _mixins.scss              # SCSS混合
│   │   │       ├── _themes.scss              # 主题样式
│   │   │       └── _utilities.scss           # 工具类样式
│   │   │
│   │   └── environments/                     # 环境配置
│   │       ├── environment.ts                # 开发环境配置
│   │       ├── environment.prod.ts           # 生产环境配置
│   │       └── environment.test.ts           # 测试环境配置
│   │
│   ├── e2e/                                  # 端到端测试
│   │   ├── protractor.conf.js
│   │   ├── tsconfig.json
│   │   └── src/
│   │       ├── app.e2e-spec.ts
│   │       └── app.po.ts
│   │
│   └── dist/                                 # Angular 构建输出 (由 ng build 生成)
│       └── fat-test-frontend/
│
├── docs/                                     # 项目文档
│   ├── README.md                             # 项目总体文档
│   ├── ARCHITECTURE.md                       # 架构设计文档
│   ├── API.md                                # API接口文档
│   ├── DEPLOYMENT.md                         # 部署说明文档
│   ├── USER_MANUAL.md                        # 用户使用手册
│   ├── DEVELOPMENT.md                        # 开发环境搭建指南
│   └── CHANGELOG.md                          # 版本更新日志
│
├── scripts/                                  # 构建和部署脚本
│   ├── build-all.sh                          # 完整构建脚本
│   ├── dev-setup.sh                          # 开发环境配置脚本
│   ├── test-all.sh                           # 运行所有测试脚本
│   └── release.sh                            # 发布脚本
│
├── tests/                                    # 端到端集成测试
│   ├── fixtures/                             # 测试数据和文件
│   │   ├── sample_excel_imports/             # 示例Excel导入文件
│   │   ├── mock_plc_data/                    # Mock PLC数据
│   │   └── test_configurations/              # 测试配置文件
│   ├── integration/                          # 集成测试用例
│   │   ├── full_workflow_tests.rs
│   │   ├── plc_communication_tests.rs
│   │   └── data_persistence_tests.rs
│   └── performance/                          # 性能测试
│       ├── load_tests.rs
│       └── stress_tests.rs
│
├── config/                                   # 配置文件目录
│   ├── app_settings.json                     # 应用默认设置
│   ├── plc_configurations/                   # PLC配置文件模板
│   │   ├── modbus_tcp_template.json
│   │   ├── s7_template.json
│   │   └── opcua_template.json
│   └── test_parameters/                      # 测试参数配置
│       ├── ai_test_params.json
│       ├── ao_test_params.json
│       ├── di_test_params.json
│       └── do_test_params.json
│
├── data/                                     # 运行时数据目录 (应用生成)
│   ├── batches/                              # 批次数据存储
│   ├── configurations/                       # 保存的配置
│   ├── logs/                                 # 应用日志文件
│   └── exports/                              # 导出的测试报告
│
├── .gitignore                                # Git 忽略文件配置
├── .github/                                  # GitHub Actions CI/CD 配置
│   └── workflows/
│       ├── build-and-test.yml               # 构建和测试工作流
│       └── release.yml                       # 发布工作流
│
└── target/                                   # Rust 构建输出 (由 cargo build 生成)
    ├── debug/                                # 调试版本构建
    ├── release/                              # 发布版本构建
    └── bundle/                               # Tauri 打包输出
        ├── appimage/                         # Linux AppImage
        ├── deb/                              # Debian 包
        ├── dmg/                              # macOS DMG
        ├── msi/                              # Windows MSI 安装包
        └── nsis/                             # Windows NSIS 安装包
```

## 目录结构说明

### 后端架构层次映射
- **应用层**: `src-tauri/src/services/application/` - 编排业务用例，对应架构图中的应用服务层
- **领域层**: `src-tauri/src/services/domain/` - 核心业务逻辑，包含状态管理和测试执行引擎
- **基础设施层**: `src-tauri/src/services/infrastructure/` - 外部系统交互，PLC通信和数据持久化
- **Tauri集成层**: `src-tauri/src/commands/` 和 `src-tauri/src/events/` - 前后端通信桥梁

### 前端组件架构映射
- **视图层**: `fat-test-frontend/src/app/components/` - Angular组件对应架构图中的View层
- **服务层**: `fat-test-frontend/src/app/services/` - 封装Tauri通信，对应ViewModel/Component Logic层
- **状态管理**: `fat-test-frontend/src/app/services/ui-state.service.ts` - 前端状态管理

### 关键设计原则体现
- **单一职责**: 每个服务和组件都有明确的职责范围
- **依赖倒置**: 通过接口抽象和依赖注入实现松耦合
- **分层架构**: 清晰的分层结构，上层依赖下层，下层不依赖上层
- **领域驱动**: 核心业务逻辑集中在domain层，状态管理集中在ChannelStateManager

---

## 0. 引言

本文档基于《技术栈迁移系统架构设计 (FAT_TEST 项目)》文档，旨在提供一个详细的、可操作的步骤化实施方案，指导 FAT_TEST 项目从现有 C# WPF 技术栈平稳、高效地迁移至 `Rust + Angular + Tauri` 新技术栈。

每个步骤将包含以下关键信息：
*   **原因 (Reason)**：为什么需要执行此步骤。
*   **期望效果 (Expected Outcome)**：此步骤完成后应达成的具体目标和产出物。
*   **实施描述 (Implementation Description)**：如何执行此步骤，涉及的关键技术点和任务。
*   **如何测试 (How to Test)**：验证此步骤是否成功完成的方法和标准。

**总体迁移策略：** 采用增量和迭代的方式，优先构建核心后端逻辑和数据流，然后逐步完善应用层服务和前端功能。尽早进行集成测试，确保各组件协同工作。

---

## Phase 1: 后端核心基础建设 - 领域模型与基础设施层（初步）

**目标：** 搭建Rust后端项目的基本骨架，定义核心领域模型，并初步实现基础设施服务的接口和Mock/基本实现，为上层逻辑奠定基础。

### 步骤 1.1: 定义核心领域模型 (Rust Structs & Enums)

*   **原因 (Reason)**:
    *   领域模型是系统的核心，定义了业务实体的数据结构和基本行为约束。
    *   清晰、准确的领域模型是后续所有业务逻辑实现的基础。
    *   在项目早期就统一数据结构，可以减少后续因模型不一致导致的返工。
*   **期望效果 (Expected Outcome)**:
    *   在 Rust 项目中创建 `models.rs` (或类似模块)，包含所有核心枚举和结构体的定义。
    *   **核心枚举定义 (Rust Enums)**:
        *   `OverallTestStatus`: 整体测试状态 (NotTested, Testing, Paused, TestCompletedPassed, TestCompletedFailed, Skipped, WiringConfirmationPending, HardPointTestCompleted, Aborted)。
        *   `SubTestStatus`: 子测试项状态 (NotTested, Testing, Passed, Failed, Skipped, NotApplicable, Aborted)。
        *   `ModuleType`: 模块类型 (AI, AO, DI, DO, Other)。
        *   `PointDataType`: 点位数据类型 (Bool, Float, Int16, UInt16, Int32, UInt32)。
        *   `SubTestItem`: 子测试项枚举，包含所有可能的测试步骤 (e.g., HardPoint, LowAlarm, HighAlarm, Wiring, Communication, OpenCircuit, ShortCircuit, StatusRead, SetPointWrite, etc.)。需要 `Eq, Hash` 以便用作 `HashMap` 的键。
    *   **核心结构体定义 (Rust Structs)**:
        *   `ChannelPointDefinition`: 通道点位静态配置信息。
        *   `ChannelTestInstance`: 通道测试动态实例，包含状态和结果。
        *   `SubTestExecutionResult`: 单个子测试项的执行结果详情。
        *   `AnalogReadingPoint`: 模拟量测试读数点 (用于记录设定值、实际读值等)。
        *   `TestBatchInfo`: 测试批次信息。
        *   `RawTestOutcome`: 原子测试步骤（由 `ISpecificTestStepExecutor` 执行）的原始输出结果。
    *   所有结构体和枚举都应派生 `Debug`, `Clone`, `PartialEq` (按需)。为了IPC和持久化，还需派生 `Serialize`, `Deserialize` (使用 `serde`)。
    *   代码提交到版本控制。
*   **实施描述 (Implementation Description)**:
    1.  在 Rust 项目的 `src` 目录下创建 `models` 模块 (e.g., `src/models/mod.rs` 和 `src/models/enums.rs`, `src/models/structs.rs` 或直接在 `src/models.rs`)。
    2.  添加 `serde` 作为依赖到 `Cargo.toml` (`serde = { version = "1.0", features = ["derive"] }`)。
    3.  添加 `chrono` crate 处理日期时间 (`chrono = { version = "0.4", features = ["serde"] }`)。
    4.  添加 `uuid` crate (`uuid = { version = "1.0", features = ["v4", "serde"] }`) 用于生成唯一ID。
    5.  **枚举定义 (示例 `src/models/enums.rs` 或 `src/models.rs`):**
        ```rust
        use serde::{Serialize, Deserialize};

        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum OverallTestStatus {
            NotTested,
            Testing,
            Paused,
            TestCompletedPassed,
            TestCompletedFailed,
            Skipped,
            WiringConfirmationPending, // 接线确认中
            HardPointTestCompleted,    // 硬点测试完成 (通常用于AI/AO，后续有手动软报警点)
            Aborted,                   // 已中止
        }
        impl Default for OverallTestStatus { fn default() -> Self { OverallTestStatus::NotTested } }

        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum SubTestStatus {
            NotTested,
            Testing,
            Passed,
            Failed,
            Skipped,
            NotApplicable, // 不适用
            Aborted,
        }
        impl Default for SubTestStatus { fn default() -> Self { SubTestStatus::NotTested } }

        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum ModuleType {
            AI, // Analog Input
            AO, // Analog Output
            DI, // Digital Input
            DO, // Digital Output
            Custom, // 自定义或其他特殊类型
        }

        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum PointDataType { // PLC点位的数据类型
            Bool,
            Real, // 通常是 f32
            Int,  // 通常是 i16
            DInt, // 通常是 i32
            Word, // 通常是 u16
            DWord,// 通常是 u32
            // 根据实际PLC支持情况添加
        }
        
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum SubTestItem {
            // 通用
            Communication,      // 通信检查
            WiringConfirmation, // 接线确认

            // 硬接线测试 (AI/AO/DI/DO)
            HardPoint,          // 主要的硬点测试 (如DI的ON/OFF, AI的0%,25%,50%,75%,100%等)
                                // 可以进一步细化，例如 AIHardPoint25, AIHardPoint50等，或在RawTestOutcome中携带参数

            // AI/AO特定
            OpenCircuit,        // 开路检测 (如4-20mA < 3.5mA)
            ShortCircuit,       // 短路检测 (如4-20mA > 21mA) (AO更常见)
            OverRange,          // 超量程
            UnderRange,         // 低于量程
            
            // AI特定报警点 (软报警)
            LowLowAlarm,        // 低低报
            LowAlarm,           // 低报
            HighAlarm,          // 高报
            HighHighAlarm,      // 高高报

            // DO/AO特定
            FeedbackVerification, // DO的反馈验证 (如果DO有反馈点)
            OutputVerification,   // AO输出值验证 (通过外部测量或系统反馈)

            // 其他通用或自定义项
            MaintenanceMode,    // 维护模式测试
            OperatorAction,     // 需要操作员干预的步骤
            VisualInspection,   // 外观检查
            CustomLogicTest1,   // 自定义逻辑测试1
        }
        ```
    6.  **结构体定义 (示例 `src/models/structs.rs` 或 `src/models.rs`):**
        ```rust
        use serde::{Serialize, Deserialize};
        use std::collections::HashMap;
        use chrono::{DateTime, Utc};
        use super::enums::*; // Assuming enums are in a sibling module or same file

        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct ChannelPointDefinition {
            #[serde(default = "default_id")]
            pub id: String, // 唯一ID, e.g., UUID
            pub tag_name: String,                    // 位号
            pub description: String,                 // 描述
            pub module_type: ModuleType,             // 模块类型 (AI, DI, AO, DO)
            
            // PLC 通讯相关 (地址根据实际PLC和协议定义，这里是示例)
            pub plc_node_name_primary: Option<String>, // 主PLC节点名 (可选, 用于多PLC系统)
            pub primary_address_read: Option<String>,  // 主读取地址 (e.g., "DB100.DBD0" or "40001")
            pub primary_address_write: Option<String>, // 主写入地址 (for AO/DO)
            pub primary_data_type: Option<PointDataType>, // 主点位数据类型

            pub plc_node_name_secondary: Option<String>, // 备用/测试台架PLC节点名
            pub secondary_address_read: Option<String>, // 备用/台架读取地址
            pub secondary_address_write: Option<String>,// 备用/台架写入地址
            pub secondary_data_type: Option<PointDataType>,

            // 量程和单位 (主要用于 AI/AO)
            pub eng_unit: Option<String>,            // 工程单位 (e.g., "mA", "bar", "°C")
            pub range_low: Option<f32>,              // 量程下限
            pub range_high: Option<f32>,             // 量程上限
            pub raw_value_low: Option<f32>,          // 对应量程下限的原始值 (e.g., 4 for 4-20mA)
            pub raw_value_high: Option<f32>,         // 对应量程上限的原始值 (e.g., 20 for 4-20mA)

            // 报警设定 (主要用于 AI)
            pub ll_alarm_setpoint: Option<f32>,      // 低低报设定值
            pub l_alarm_setpoint: Option<f32>,       // 低报设定值
            pub h_alarm_setpoint: Option<f32>,       // 高报设定值
            pub hh_alarm_setpoint: Option<f32>,      // 高高报设定值
            pub alarm_deadband: Option<f32>,         // 报警死区

            // 测试允差
            pub tolerance_absolute: Option<f32>,     // 绝对允差
            pub tolerance_percentage: Option<f32>,   // 百分比允差

            pub expected_di_state_on: Option<bool>, // DI点ON状态的期望值 (true/false)
            
            #[serde(default)]
            pub applicable_sub_tests: Vec<SubTestItem>, // 列出此点位适用哪些子测试项
                                                       // (可以由导入逻辑或配置时填充)
            #[serde(default)]
            pub custom_fields: HashMap<String, String>, // 其他自定义字段
        }
        fn default_id() -> String { uuid::Uuid::new_v4().to_string() }

        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct AnalogReadingPoint {
            pub timestamp: DateTime<Utc>,
            pub set_value_eng: Option<f32>,    // 设定工程值
            pub read_value_eng: Option<f32>,   // 读取工程值
            pub set_value_raw: Option<serde_json::Value>,  // 设定原始值 (可以是数字、字符串等)
            pub read_value_raw: Option<serde_json::Value>, // 读取原始值
            pub success: bool,
            pub message: Option<String>,
        }

        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct SubTestExecutionResult {
            pub item: SubTestItem,
            pub status: SubTestStatus,
            pub start_time: Option<DateTime<Utc>>,
            pub end_time: Option<DateTime<Utc>>,
            pub duration_ms: Option<i64>,
            pub message: Option<String>,
            pub readings: Vec<AnalogReadingPoint>, // 对于模拟量测试，可能有一系列的读数点
            #[serde(default)]
            pub details: HashMap<String, serde_json::Value>, // 其他详细结果 (如截图路径，原始报文等)
        }

        #[derive(Debug, Clone, Default, PartialEq, Serialize, Deserialize)]
        pub struct ChannelTestInstance {
            #[serde(default = "default_id")]
            pub instance_id: String, // 唯一测试实例ID
            pub channel_definition_id: String, // 关联的 ChannelPointDefinition ID
            pub batch_id: String, // 所属批次ID
            
            pub overall_status: OverallTestStatus,
            pub error_message: Option<String>, // 如果整体失败，记录错误信息
            
            pub creation_time: DateTime<Utc>,
            pub last_updated_time: DateTime<Utc>,
            pub start_test_time: Option<DateTime<Utc>>,
            pub final_test_time: Option<DateTime<Uttc>>, // 测试完成时间
            pub total_test_duration_ms: Option<i64>,

            #[serde(default)]
            pub sub_test_results: HashMap<SubTestItem, SubTestExecutionResult>,

            pub current_operator: Option<String>, // 当前操作员 (用于手动测试等)
            pub retries_count: u32, // 重测次数

            #[serde(default)]
            pub transient_data: HashMap<String, serde_json::Value>, // 运行时临时数据，不一定持久化
        }
        
        #[derive(Debug, Clone, Default, PartialEq, Serialize, Deserialize)]
        pub struct TestBatchInfo {
            #[serde(default = "default_id")]
            pub batch_id: String, // 唯一批次ID
            pub product_model: Option<String>, // 产品型号
            pub serial_number: Option<String>, // 产品序列号
            pub creation_time: DateTime<Utc>,
            pub last_updated_time: DateTime<Utc>,
            pub operator_name: Option<String>,
            pub status_summary: Option<String>, // 例如 "100/120 tested, 85 passed, 10 failed, 5 skipped"
            pub total_points: u32,
            pub tested_points: u32,
            pub passed_points: u32,
            pub failed_points: u32,
            pub skipped_points: u32,
            #[serde(default)]
            pub custom_data: HashMap<String, String>, // 其他批次相关信息
        }

        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct RawTestOutcome { // ISpecificTestStepExecutor 返回的结果
            pub channel_instance_id: String,
            pub sub_test_item: SubTestItem,
            pub success: bool,
            pub message: Option<String>,
            pub start_time: DateTime<Utc>,
            pub end_time: DateTime<Utc>,
            pub readings: Vec<AnalogReadingPoint>, // 一系列读数，如AI多点测试
            #[serde(default)]
            pub details: HashMap<String, serde_json::Value>, // 更多细节
        }
        ```
    7.  编写简单的单元测试来验证模型的创建、克隆、序列化和反序列化。
*   **如何测试 (How to Test)**:
    *   **单元测试**:
        *   编写简单的单元测试来验证模型的创建、克隆。
        *   测试 `serde` 的序列化和反序列化功能，确保模型可以正确转换为JSON字符串并从JSON字符串恢复。
        *   例如：创建一个 `ChannelPointDefinition` 实例，序列化为JSON，再反序列化回来，比较前后对象是否一致。
    *   **代码审查**: 检查字段名、类型是否与架构文档一致，`derive` 是否完整。

### 步骤 1.2: 搭建 Rust 项目基本结构、配置与统一错误处理

*   **原因 (Reason)**:
    *   一个良好组织的项目结构便于代码管理和模块化开发。
    *   统一的错误处理机制能提高代码的健壮性和可维护性，方便调试。
*   **期望效果 (Expected Outcome)**:
    *   创建 Rust 后端主项目 (e.g., `fat_test_backend`)。
    *   定义清晰的模块结构，如 `src/models`, `src/services`, `src/errors`, `src/config`, `src/main.rs`。
    *   实现架构文档中定义的 `AppError` 枚举，并集成 `thiserror` crate。
    *   建立初步的配置管理方式（如从环境变量或配置文件读取）。
*   **实施描述 (Implementation Description)**:
    1.  使用 `cargo new fat_test_backend --lib` (如果主要是库) 或 `cargo new fat_test_backend` 创建项目。如果使用Tauri，Tauri会创建项目结构。这里假设先独立构建后端核心。
    2.  在 `src` 目录下规划模块：
        *   `errors.rs`: 定义 `AppError`。
        *   `services/mod.rs`: 用于组织服务层trait和实现。
        *   `config.rs`: (可选) 用于加载配置。
    3.  在 `Cargo.toml` 中添加 `thiserror = "1.0"` 和 `serde = { version = "1.0", features = ["derive"] }`, `serde_json = "1.0"`。
    4.  在 `errors.rs` 中实现 `AppError` 枚举，使用 `#[derive(Error, Debug, Clone, Serialize)]`。包含如 `IoError`, `PersistenceError`, `PlcCommunicationError` 等变体。
    5.  实现 `From<std::io::Error> for AppError` 等常用错误转换。
    6.  (可选) 初步设定日志库，如 `log` 和 `env_logger`。
*   **如何测试 (How to Test)**:
    *   **单元测试**:
        *   为 `AppError` 编写测试，验证错误类型的创建和 `to_string()` 输出。
        *   测试 `From` Trait 实现，确保外部错误能正确转换为 `AppError`。
    *   **编译通过**: 确保项目结构清晰，模块间引用正确，能够成功编译。

### 步骤 1.3: 实现 `IPlcCommunicationService` 接口及 Mock/基本实现 (基础设施层)

*   **原因 (Reason)**:
    *   PLC 通信是系统核心功能之一，尽早定义接口和提供Mock实现可以解耦上层逻辑开发。
    *   Mock 实现允许在没有真实PLC硬件或完整驱动的情况下进行测试。
*   **期望效果 (Expected Outcome)**:
    *   在 `src/services/infrastructure/plc_communication.rs` (或类似路径) 中定义 `IPlcCommunicationService` trait，包含架构文档中描述的方法 (connect, disconnect, read_bool, write_f32, etc.)。
    *   提供一个 `MockPlcCommunicationService` 实现该 trait:
        *   `connect`/`disconnect`/`is_connected` 方法只记录日志并返回固定值。
        *   `read_X` 方法返回预设的默认值或根据输入地址返回特定 mock 数据。
        *   `write_X` 方法记录写入的值和地址，但不进行实际操作。
    *   此 Mock 服务应能满足后续 `SpecificTestStepExecutor` 初步开发和测试的需求。
*   **实施描述 (Implementation Description)**:
    1.  创建 `src/services/infrastructure/mod.rs` 和 `src/services/infrastructure/plc_communication.rs`。
    2.  在 `plc_communication.rs` 中定义 `IPlcCommunicationService` trait，使用 `#[async_trait::async_trait]`。定义 `PlcTag` 结构。
    3.  实现 `MockPlcCommunicationService` struct。
        *   可以在 `MockPlcCommunicationService` 中使用 `std::collections::HashMap` 来存储预设的读取值或记录写入的值，以便测试时验证。
        *   例如: `mock_reads: HashMap<String, serde_json::Value>`, `logged_writes: Vec<(String, serde_json::Value)>`。
    4.  所有 trait 方法返回 `Result<T, AppError>`。
*   **如何测试 (How to Test)**:
    *   **单元测试**:
        *   针对 `MockPlcCommunicationService` 编写单元测试。
        *   测试连接/断开状态模拟。
        *   测试读取操作：验证能否返回预设的 mock 数据。
        *   测试写入操作：验证写入的地址和值是否被正确记录在 `MockPlcCommunicationService` 内部状态中。
        *   测试批量读写操作。

### 步骤 1.4: 实现 `IPersistenceService` 接口及 Mock/基本文件实现 (基础设施层)

*   **原因 (Reason)**:
    *   数据持久化是保存配置、测试记录等关键数据的必要环节。
    *   早期定义接口和提供Mock/简单文件实现，可以使依赖此接口的服务（如 `TestRecordService`, `DataManagementService`）先行开发。
*   **期望效果 (Expected Outcome)**:
    *   在 `src/services/infrastructure/persistence.rs` (或类似路径) 中定义 `IPersistenceService` trait，包含架构文档中描述的方法 (save_document, load_document, etc.)。
    *   提供一个 `MockPersistenceService`:
        *   使用内存中的 `HashMap` 来模拟数据存储 (`HashMap<String, HashMap<String, String>>`，外层Key为collection_name，内层Key为document_id，Value为序列化后的JSON字符串)。
    *   (可选，但推荐) 提供一个初步的 `JsonFilePersistenceService`:
        *   将每个 `collection` 实现为磁盘上的一个目录。
        *   将每个 `document` 实现为该目录下的一个JSON文件 (文件名基于 `document_id`)。
        *   `save_document` 时序列化对象为JSON并写入文件。
        *   `load_document` 时从文件读取JSON并反序列化。
*   **实施描述 (Implementation Description)**:
    1.  创建 `src/services/infrastructure/persistence.rs`。
    2.  定义 `IPersistenceService` trait，使用 `#[async_trait::async_trait]`。方法参数和返回值参考架构文档，注意泛型 `T: Serialize + DeserializeOwned + Send + Sync`。
    3.  实现 `MockPersistenceService` struct，内部使用 `Arc<Mutex<HashMap<String, HashMap<String, String>>>>` 来存储数据，以支持并发访问（如果服务实例被共享）。
    4.  (可选) 实现 `JsonFilePersistenceService` struct。
        *   需要配置一个根存储目录。
        *   使用 `tokio::fs` 进行异步文件操作。
        *   使用 `serde_json` 进行序列化/反序列化。
        *   注意处理文件和目录的创建、路径拼接、错误处理。
*   **如何测试 (How to Test)**:
    *   **单元测试 (MockPersistenceService)**:
        *   测试 `save_document` 后，能否通过 `load_document` 取回相同数据。
        *   测试 `load_document` 对于不存在的ID返回 `Ok(None)`。
        *   测试 `delete_document` 和 `document_exists`。
        *   测试 `load_all_documents_in_collection`。
    *   **单元测试 (JsonFilePersistenceService)**:
        *   与 Mock 服务类似的测试用例，但验证数据是否正确写入/读取于指定的文件路径。
        *   测试并发写入/读取同一文件或不同文件时的行为 (如果设计为支持)。
        *   测试文件操作错误（如权限不足、磁盘满）能否被正确捕获并返回 `AppError`。需要mock文件系统操作或在测试环境中设置特定条件。

### 步骤 1.5: 实现 `IChannelStateManager` 接口及核心逻辑 (领域层)

*   **原因 (Reason)**:
    *   `ChannelStateManager` 是整个测试状态管理的核心，封装了最复杂的业务规则。
    *   它的正确实现是保证测试结果准确性和流程正确性的关键。
*   **期望效果 (Expected Outcome)**:
    *   在 `src/services/domain/channel_state_manager.rs` 中定义 `IChannelStateManager` trait。
    *   实现 `ChannelStateManager` struct，包含架构文档中描述的核心方法：
        *   `initialize_channel_test_instance`
        *   `apply_raw_outcome` (这是最核心的，内部包含复杂的 `EvaluateOverallStatus` 逻辑)
        *   `mark_as_skipped`
        *   `prepare_for_wiring_confirmation`
        *   `begin_hard_point_test`
        *   `begin_manual_sub_test`
        *   `reset_for_retest`
    *   此实现应严格遵守不进行I/O操作、不直接发布事件的原则。
    *   状态转换逻辑清晰，易于理解和修改。
*   **实施描述 (Implementation Description)**:
    1.  创建 `src/services/domain/mod.rs` 和 `src/services/domain/channel_state_manager.rs`。
    2.  定义 `IChannelStateManager` trait。
    3.  实现 `ChannelStateManager` struct。此服务通常是无状态的，或者只依赖配置信息，不持有可变运行时数据。
    4.  **`initialize_channel_test_instance`**:
        *   接收 `ChannelPointDefinition` 和 `batch_id`。
        *   创建一个新的 `ChannelTestInstance`。
        *   根据 `definition.module_type` 和其他配置（如报警点位是否配置），初始化 `instance.sub_test_results` 中各项 `SubTestItem` 的状态为 `NotTested` 或 `NotApplicable`。
        *   设置 `instance.overall_status = OverallTestStatus::NotTested`。
    5.  **`apply_raw_outcome`**:
        *   接收 `&mut ChannelTestInstance` 和 `RawTestOutcome`。
        *   根据 `outcome.sub_test_item` 更新 `instance.sub_test_results` 中对应条目的状态、时间戳、详细信息等。
        *   **调用内部私有方法 `evaluate_overall_status(&mut instance)`**。
    6.  **`evaluate_overall_status` (私有方法)**:
        *   这是状态机核心。遍历 `instance.sub_test_results`。
        *   根据各项子测试的状态，以及预定义的规则（例如：所有必需项 `Passed` 则整体 `TestCompletedPassed`；任何关键项 `Failed` 则整体 `TestCompletedFailed`；硬点测试完成但有手动项未测则可能是 `HardPointTestCompleted` 等），更新 `instance.overall_status`。
        *   更新 `instance.final_test_time`, `instance.total_test_duration_ms` (如果测试完成)。
        *   构建 `instance.error_message` (如果失败)。
    7.  实现其他方法 (`mark_as_skipped` 等)，它们通常会设置特定的子测试项状态或整体状态，并调用 `evaluate_overall_status`。
*   **如何测试 (How to Test)**:
    *   **单元测试 (非常重要且详细)**:
        *   **初始化测试**:
            *   针对不同 `ModuleType` (AI, DI, AO, DO等) 的 `ChannelPointDefinition`，测试 `initialize_channel_test_instance` 后，`ChannelTestInstance` 的 `overall_status` 和 `sub_test_results` 是否符合预期（哪些是 `NotTested`，哪些是 `NotApplicable`）。
        *   **状态转换测试 (apply_raw_outcome)**:
            *   为每个 `SubTestItem` 和不同的 `RawTestOutcome` (成功/失败) 构造测试场景。
            *   例如：
                *   初始化的AI点实例 -> 应用成功的 `HardPoint` outcome -> 验证 `sub_test_results[HardPoint].status` 为 `Passed` 及 `overall_status` 的变化。
                *   AI点实例，`HardPoint` 已 `Passed` -> 应用成功的 `LowAlarm` outcome -> 验证状态。
                *   AI点实例 -> 应用失败的 `HardPoint` outcome -> 验证 `sub_test_results[HardPoint].status` 为 `Failed` 及 `overall_status` 为 `TestCompletedFailed`。
            *   覆盖所有定义的 `SubTestItem`。
            *   测试组合场景：多个子测试成功后整体通过；一个关键子测试失败导致整体失败。
        *   **`mark_as_skipped` 测试**: 验证调用后 `overall_status` 为 `Skipped`。
        *   **`reset_for_retest` 测试**: 验证调用后状态是否恢复到适合重测的初始状态。
        *   **边界条件和错误条件**: 例如，传入无效的 `RawTestOutcome` (不匹配的 `instance_id` -- 虽然这里是传 `&mut instance`，但逻辑上要考虑)。

---

## Phase 2: 后端核心业务流程实现 - 测试执行与初步应用服务

**目标：** 实现核心的测试执行逻辑，包括 `SpecificTestStepExecutor` 和 `TestExecutionEngine`，并开始搭建部分应用层服务以串联流程，为后续与前端集成做准备。

### 步骤 2.1: 实现 `ISpecificTestStepExecutor` 接口及若干具体执行器 (领域层)

*   **原因 (Reason)**:
    *   `SpecificTestStepExecutor` 是实际执行与PLC交互并获取原始测试结果的单元。
    *   实现具体的执行器是 `TestExecutionEngine` 能够工作的先决条件。
*   **期望效果 (Expected Outcome)**:
    *   在 `src/services/domain/test_executors/` 目录下创建模块。
    *   定义 `ISpecificTestStepExecutor` trait。
    *   至少实现以下几个关键的执行器 (以AI点为例，其他类型类似)：
        *   `AIHardPointPercentExecutor`: 执行AI点硬接线测试中某个百分比的设定与读取（如模拟输出25%值，读取AI反馈）。
        *   `AIAlarmTestExecutor`: 执行AI点某个报警项的测试（如设置高报触发条件，验证报警是否产生）。
        *   `DIStateReadExecutor`: 读取DI点的状态。
        *   `DOSetStateExecutor`: 设置DO点的状态并验证回读（如果硬件支持）。
    *   每个执行器应能接收 `ChannelTestInstance` (只读), `ChannelPointDefinition` (只读), 以及 `IPlcCommunicationService` 的实例 (测试台架和被测系统)。
    *   每个执行器执行完毕后返回一个 `RawTestOutcome` 对象，包含执行的 `SubTestItem`、成功与否、原始读值、消息等。
*   **实施描述 (Implementation Description)**:
    1.  创建 `src/services/domain/test_executors/mod.rs` 以及各个执行器的 `ai_hardpoint_executor.rs`, `ai_alarm_executor.rs` 等文件。
    2.  在 `mod.rs` 或一个共享文件中定义 `ISpecificTestStepExecutor` trait。
    3.  **`AIHardPointPercentExecutor` 实现**: (示例逻辑)
        *   构造函数可能接收目标百分比 (e.g., 0.25, 0.50)。
        *   `item_type()` 返回 `SubTestItem::HardPoint` (可能需要更细分的 `SubTestItem` 来区分百分比点，或者 `RawTestOutcome` 中包含额外信息)。
        *   `execute()` 方法:
            *   从 `ChannelPointDefinition` 获取量程 (`range_lower_limit`, `range_upper_limit`) 和测试台架输出地址 (`test_rig_plc_address`) 以及被测AI点读取地址 (`plc_communication_address`)。
            *   计算目标百分比对应的工程单位设定值和（可能的）原始设定值。
            *   调用 `plc_service_test_rig.write_f32(test_rig_plc_address, calculated_set_value_raw)`。
            *   等待一小段时间 (可配置) 以确保信号稳定。
            *   调用 `plc_service_target.read_f32(plc_communication_address)` 获取实际读值。
            *   将实际读值转换为工程单位。
            *   比较实际读值与期望读值 (考虑容差范围)。
            *   构造并返回 `RawTestOutcome`，包含 `success` 状态，设定的百分比，设定值，实际读值，原始读值等信息 (利用 `RawTestOutcome::analog_reading_point` 字段)。
    4.  **`AIAlarmTestExecutor` 实现**: (示例逻辑)
        *   构造函数接收要测试的报警类型 (e.g., `SubTestItem::HighAlarm`)。
        *   `item_type()` 返回对应的 `SubTestItem`。
        *   `execute()` 方法:
            *   从 `ChannelPointDefinition` 获取报警设定值写入地址 (e.g., `sh_set_point_address`)、报警状态反馈地址 (e.g., `sh_feedback_address`) 和报警设定值 (e.g., `sh_set_value`)。
            *   调用 `plc_service_target.write_f32(sh_set_point_address, alarm_trigger_value)` (写入一个能触发报警的值)。
            *   等待。
            *   调用 `plc_service_target.read_bool(sh_feedback_address)` 验证报警是否有效。
            *   (重要) 测试完毕后，可能需要将设定值恢复原状或设定一个安全值。
            *   构造并返回 `RawTestOutcome`。
    5.  对DI/DO等其他类型的执行器进行类似实现。
    6.  所有与PLC的交互都应通过传入的 `IPlcCommunicationService` 实例进行。
*   **如何测试 (How to Test)**:
    *   **单元测试 (对每个具体执行器)**:
        *   **Mocking `IPlcCommunicationService`**: 这是测试的关键。为 `MockPlcCommunicationService` 设置预期的读取返回值，并验证写入操作是否符合预期 (地址、值)。
        *   **成功场景**: 模拟PLC返回预期值，验证执行器是否返回 `success: true` 的 `RawTestOutcome`，且outcome中的数据正确。
        *   **失败场景**:
            *   模拟PLC返回意外值 (超出容差范围)，验证 `success: false` 及错误信息。
            *   模拟PLC通信错误 (e.g., `read_f32` 返回 `Err(AppError::PlcCommunicationError)`)，验证执行器是否能正确处理并向上传播错误 (或包装为特定的 `RawTestOutcome` 失败)。
        *   **边界条件**: 测试量程的0%, 100%点，报警的触发与解除等。

### 步骤 2.2: 实现 `ITestExecutionEngine` 接口及并发控制逻辑 (领域层)

*   **原因 (Reason)**:
    *   `TestExecutionEngine` 负责管理和并发执行由多个 `SpecificTestStepExecutor` 构成的完整测试序列。
    *   其正确实现是保证测试高效、有序进行的关键。
*   **期望效果 (Expected Outcome)**:
    *   在 `src/services/domain/test_execution_engine.rs` 中定义 `ITestExecutionEngine` trait。
    *   实现 `TestExecutionEngine` struct。
    *   `submit_test_instance` 方法应能接收 `ChannelTestInstance` 和 `ChannelPointDefinition`，并根据其类型决定需要执行的 `SpecificTestStepExecutor` 序列。
    *   使用 `tokio::spawn` 来异步执行每个测试实例的测试序列。
    *   使用 `tokio::sync::Semaphore` 来控制最大并发测试实例数。
    *   每个执行的 `SpecificTestStepExecutor` 返回的 `RawTestOutcome` 通过 `outcome_sender` (MPSC channel) 发送出去。
    *   初步实现 `pause`, `resume`, `stop` 功能 (可能通过 `CancellationToken` 或 `Arc<Mutex<bool>>` 标志位，需要仔细设计)。
*   **实施描述 (Implementation Description)**:
    1.  创建 `src/services/domain/test_execution_engine.rs`。
    2.  定义 `ITestExecutionEngine` trait。
    3.  实现 `TestExecutionEngine` struct:
        *   包含字段: `max_concurrent_tests: Arc<Semaphore>`, `plc_service_test_rig: Arc<dyn IPlcCommunicationService>`, `plc_service_target: Arc<dyn IPlcCommunicationService>` (这些应在创建引擎时注入)。
        *   (可选) `active_tasks: Arc<Mutex<HashMap<String, CancellationToken>>>` 用于管理可取消的任务。
    4.  **`submit_test_instance` 实现**: (核心逻辑)
        *   获取一个信号量许可: `let permit = self.max_concurrent_tests.clone().acquire_owned().await.unwrap();`
        *   `tokio::spawn` 一个新的异步任务，此任务负责执行该 `instance` 的完整测试序列。在任务结束时，`permit` 会被自动释放。
        *   在spawn的异步块内：
            *   根据 `definition.module_type` 和预定义的测试策略，构建一个 `Vec<Arc<dyn ISpecificTestStepExecutor>>` 序列。
                *   例如，AI点可能包含：HardPoint 0%, 25%, 50%, 75%, 100%, LL Alarm, L Alarm, H Alarm, HH Alarm, Maintenance, Trend, Report。
                *   这个构建逻辑可以封装在一个私有辅助函数 `fn determine_test_steps(definition: &ChannelPointDefinition) -> Vec<Arc<dyn ISpecificTestStepExecutor>>` 中，该函数会实例化具体的执行器。
            *   按顺序（或特定逻辑）迭代执行 `steps` 中的每个 `executor`:
                *   `let outcome = executor.execute(&instance_clone, &definition_clone, self.plc_test_rig.clone(), self.plc_target.clone()).await;`
                *   通过 `outcome_sender.send(outcome).await` 发送结果。
                *   如果某个步骤失败且需要中止后续步骤 (e.g., 硬点测试基础部分失败)，则提前 `break`。
                *   处理暂停/停止信号 (检查 `CancellationToken` 或共享标志位)。
    5.  **并发控制**: `Semaphore` 在 `submit_test_instance` 中获取许可，在 `tokio::spawn` 的任务结束时自动释放。
    6.  **任务控制 (`pause`/`resume`/`stop`)**: 这部分比较复杂。
        *   **Stop**: 可以使用 `tokio-util::sync::CancellationToken`。每个spawn的任务持有一个 `child_token`，引擎持有 `parent_token`。停止时取消 `parent_token`。
        *   **Pause/Resume**: 可能需要更复杂的机制，如每个执行器在关键点检查一个共享的 `Arc<Mutex<PauseState>>`。或者使用 `tokio::sync::watch` channel 来广播暂停/继续信号。
        *   初步实现可以先侧重 `stop`。
*   **如何测试 (How to Test)**:
    *   **单元测试/集成测试**: (这部分更偏向集成测试，因为它协调多个组件)
        *   **Mock `ISpecificTestStepExecutor`**: 创建几个Mock执行器，它们可以模拟成功、失败、或长时间运行，并返回预设的 `RawTestOutcome`。
        *   **Mock `IPlcCommunicationService`**: 仍然需要，因为执行引擎会将PLC服务传递给执行器。
        *   **测试并发控制**: 提交N个任务（N > max_concurrent），验证同时活动的任务数不超过 `max_concurrent`。
        *   **测试结果传递**: 验证所有 `RawTestOutcome` 都通过 `outcome_sender` 正确发送出来，并且顺序基本符合预期 (对于同一实例内的步骤)。
        *   **测试错误处理**: 如果一个 `executor.execute` 返回 `Err`, 或者 `outcome_sender.send` 失败，引擎应如何处理（记录日志，可能中止该实例的后续步骤）。
        *   **测试 Stop 功能**: 提交多个任务，中途调用 `stop_instance_execution` (或全局停止)，验证正在运行和等待的任务是否能被取消，并且 `outcome_sender` 不再收到它们的结果。

### 步骤 2.3: 实现 `ITestRecordService` 接口及基本实现 (领域层)

*   **原因 (Reason)**:
    *   测试记录的保存和查询是系统的基本需求。
    *   `TestOrchestrationService` 等上层服务会依赖此服务。
*   **期望效果 (Expected Outcome)**:
    *   在 `src/services/domain/test_record_service.rs` 中定义 `ITestRecordService` trait。
    *   实现 `TestRecordService` struct。
    *   该服务的方法应能将 `TestBatchInfo` 和 `ChannelTestInstance` 对象通过注入的 `IPersistenceService` 保存到持久化存储中，并能读取它们。
*   **实施描述 (Implementation Description)**:
    1.  创建 `src/services/domain/test_record_service.rs`。
    2.  定义 `ITestRecordService` trait。
    3.  实现 `TestRecordService` struct，它依赖 `Arc<dyn IPersistenceService>`。
    4.  实现 trait 中的方法：
        *   `save_test_batch_info`: 调用 `persistence_service.save_document("batches", batch_info.batch_id, batch_info)`。
        *   `get_test_batch_info`: 调用 `persistence_service.load_document("batches", batch_id)`。
        *   `save_channel_test_instance`: 调用 `persistence_service.save_document("instances", instance.instance_id, instance)`。
        *   类似地实现其他方法，注意 `collection_name` 的一致性。
*   **如何测试 (How to Test)**:
    *   **单元测试**: (主要测试与 `IPersistenceService` 的交互)
        *   **Mock `IPersistenceService`**: 创建一个 `MockPersistenceService` 的实例。
        *   验证 `TestRecordService` 的每个方法是否以正确的参数（collection_name, document_id, document）调用了 `IPersistenceService` 的对应方法。
        *   例如，调用 `save_test_batch_info` 后，检查 `mock_persistence_service` 内部是否记录了对 `save_document` 的调用，并且参数正确。
        *   测试 `TestRecordService` 如何处理 `IPersistenceService` 返回的 `Err`。

### 步骤 2.4: 实现 `IDataManagementService` 接口及初步Excel导入逻辑 (应用层)

*   **原因 (Reason)**:
    *   数据导入是启动测试流程的第一步。
    *   实现此服务可以初步打通"外部数据 -> 内部模型"的路径。
*   **期望效果 (Expected Outcome)**:
    *   在 `src/services/application/data_management_service.rs` 中定义 `IDataManagementService` trait。
    *   实现 `DataManagementService` struct。
    *   `import_channel_definitions_from_excel` 方法能读取指定Excel文件 (使用如 `calamine` crate)，将行数据转换为 `ChannelPointDefinition` 列表。
    *   (可选) 初步实现配置的保存/加载 (`save_channel_definitions`, `load_channel_definitions`)，使用 `IPersistenceService`。
*   **实施描述 (Implementation Description)**:
    1.  创建 `src/services/application/mod.rs` 和 `src/services/application/data_management_service.rs`。
    2.  定义 `IDataManagementService` trait。
    3.  实现 `DataManagementService` struct，它可能依赖 `Arc<dyn IPersistenceService>` 和 `Arc<dyn IChannelStateManager>` (如果初始化逻辑部分放在这里或需要调用)。通常，应用服务不直接调用 `ChannelStateManager` 进行初始化，而是 `OrchestrationService` 在准备实例时调用。
    4.  **`import_channel_definitions_from_excel` 实现**: (核心)
        *   添加 `calamine = "0.22.0"` (或最新版) 到 `Cargo.toml`。
        *   方法接收 `file_path: PathBuf`。
        *   使用 `calamine::open_workbook_auto(file_path)` 打开Excel。
        *   选择合适的sheet，遍历行和单元格。
        *   将每行数据映射到 `ChannelPointDefinition` 的字段。注意数据类型转换和错误处理（如单元格为空、格式不正确）。
            *   例如，从Excel读取的量程、报警设定值等是字符串，需要转换为 `Option<f32>`。
            *   模块类型字符串需要转换为 `ModuleType` enum。
        *   为每个成功转换的 `ChannelPointDefinition` 生成一个唯一 `id` (e.g., `uuid::Uuid::new_v4().to_string()`)。
        *   (可选) 从Excel特定单元格或文件名提取批次信息 (`TestBatchInfo`)。
        *   返回 `Result<(Vec<ChannelPointDefinition>, Option<TestBatchInfo>), AppError>`。
    5.  `save/load_channel_definitions`: 使用 `IPersistenceService` 保存/加载 `Vec<ChannelPointDefinition>` 到名为 "channel_definitions_config_XXX" 的集合/文档中。
*   **如何测试 (How to Test)**:
    *   **单元测试**: (针对Excel解析逻辑)
        *   准备几个小型的测试用Excel文件：
            *   包含有效数据的标准文件。
            *   包含部分空单元格的文件。
            *   包含错误数据类型的文件（如量程列填了文本）。
            *   不同模块类型 (AI, DI, AO, DO) 的行。
        *   测试 `import_channel_definitions_from_excel`:
            *   验证返回的 `Vec<ChannelPointDefinition>` 数量和内容是否与Excel文件匹配。
            *   验证字段映射是否正确 (e.g., Excel的"位号"列是否正确赋给了 `ChannelPointDefinition::tag`)。
            *   验证数据类型转换是否正确（字符串到 `Option<f32>`，字符串到 `ModuleType` enum）。
            *   验证错误处理：对于包含错误数据的Excel，服务应如何反应（跳过错误行并记录日志？返回 `Err`？）。
        *   测试配置保存/加载 (如果实现): 使用 `MockPersistenceService` 验证交互。

### 步骤 2.5: 实现 `ITestOrchestrationService` 接口骨架及核心流程的初步串联 (应用层)

*   **原因 (Reason)**:
    *   `TestOrchestrationService` 是后端的核心协调者，负责将各个领域服务串联起来完成业务流程。
    *   早期搭建其骨架并实现一两个核心流程，有助于验证整体架构的连通性。
*   **期望效果 (Expected Outcome)**:
    *   在 `src/services/application/test_orchestration_service.rs` 定义 `ITestOrchestrationService` trait。
    *   实现 `TestOrchestrationService` struct，注入所有必要的依赖 (如 `IDataManagementService`, `ITestExecutionEngine`, `IChannelStateManager`, `ITestRecordService`, `IChannelConfigurationService` (如果使用) 等)。
    *   初步实现 `create_test_batch`, `prepare_test_instances_for_batch`, `start_tests_for_batch` 方法的骨架。
    *   `start_tests_for_batch` 应能:
        *   从 `prepare_test_instances_for_batch` 获取 `ChannelTestInstance` 列表。
        *   为每个 `instance` 调用 `ITestExecutionEngine.submit_test_instance`，并传入一个 MPSC sender。
        *   启动一个异步任务来接收 `ITestExecutionEngine` 通过 MPSC channel 发回的 `RawTestOutcome`。
        *   对于每个收到的 `RawTestOutcome`，获取对应的 `ChannelTestInstance` (可能需要一个 `Arc<Mutex<HashMap<String, ChannelTestInstance>>>` 来存储当前批次所有实例的状态)，然后调用 `IChannelStateManager.apply_raw_outcome` 更新其状态。
        *   调用 `ITestRecordService.save_channel_test_instance` 保存更新后的实例。
*   **实施描述 (Implementation Description)**:
    1.  创建 `src/services/application/test_orchestration_service.rs`。
    2.  定义 `ITestOrchestrationService` trait。
    3.  实现 `TestOrchestrationService` struct。字段包括：
        *   `data_management_service: Arc<dyn IDataManagementService>`
        *   `test_execution_engine: Arc<dyn ITestExecutionEngine>`
        *   `channel_state_manager: Arc<dyn IChannelStateManager>`
        *   `test_record_service: Arc<dyn ITestRecordService>`
        *   (可选) `channel_config_service: Arc<dyn IChannelConfigurationService>`
        *   (可选) `active_batches: Arc<Mutex<HashMap<String, BatchRuntimeState>>>`，其中 `BatchRuntimeState` 包含 `TestBatchInfo` 和 `HashMap<String, ChannelTestInstance>` (实例ID -> 实例数据)。
        *   (可选) `app_handle: tauri::AppHandle` (如果需要发送Tauri事件)。
    4.  **`create_test_batch` 实现**: 创建 `TestBatchInfo`，（可选）存入 `active_batches` 和 `ITestRecordService`。
    5.  **`prepare_test_instances_for_batch` 实现**:
        *   (如果使用 `IChannelConfigurationService`) 根据 `definition_ids` 从 `channel_config_service` 加载 `ChannelPointDefinition`。
        *   (如果直接从导入获取) `definition_ids` 可能是 `ChannelPointDefinition` 本身。
        *   遍历 `definitions`，为每个调用 `channel_state_manager.initialize_channel_test_instance`。
        *   将初始化的 `ChannelTestInstance` 存入 `active_batches` (如果使用) 并返回。
    6.  **`start_tests_for_batch` 实现**: (核心)
        *   从 `active_batches` (或参数) 获取要测试的 `ChannelTestInstance` 及其对应的 `ChannelPointDefinition`。
        *   创建 `tokio::sync::mpsc::channel` (e.g., `(outcome_tx, mut outcome_rx)` )。
        *   `let batch_instances_clone = self.active_batches.clone();`
        *   `let state_manager_clone = self.channel_state_manager.clone();`
        *   `let record_service_clone = self.test_record_service.clone();`
        *   `tokio::spawn(async move { while let Some(outcome_result) = outcome_rx.recv().await { ... } });` // Outcome processing loop
            *   在循环内部：
                *   `if let Ok(raw_outcome) = outcome_result { ... }`
                *   `let mut batches = batch_instances_clone.lock().await;`
                *   `if let Some(batch_state) = batches.get_mut(batch_id_from_outcome_or_context) { ... }`
                *   `if let Some(instance_to_update) = batch_state.instances.get_mut(&raw_outcome.channel_instance_id) { ... }`
                *   `state_manager_clone.apply_raw_outcome(instance_to_update, raw_outcome).await.unwrap_or_else(|e| error!("Failed to apply outcome: {}", e));`
                *   `record_service_clone.save_channel_test_instance(instance_to_update).await.unwrap_or_else(|e| error!("Failed to save instance: {}", e));`
                *   (TODO: 发送Tauri事件 `ChannelStateChanged`)
        *   遍历要测试的 `(instance, definition)`:
            *   `self.test_execution_engine.submit_test_instance(instance.clone(), definition.clone(), outcome_tx.clone()).await...`
*   **如何测试 (How to Test)**:
    *   **集成测试**: (这是本阶段最重要的测试)
        *   **Mock所有依赖**: `MockDataManagementService`, `MockTestExecutionEngine`, `MockChannelStateManager`, `MockTestRecordService`。
        *   **`MockTestExecutionEngine` 的行为**: 当调用 `submit_test_instance` 时，它应能模拟发送一个或多个预设的 `RawTestOutcome` 到传入的 `outcome_sender`。
        *   **测试 `start_tests_for_batch` 流程**:
            1.  调用 `create_test_batch`。
            2.  调用 `prepare_test_instances_for_batch` (使用mock的 `ChannelPointDefinition`，`MockChannelStateManager` 返回预期的初始 `ChannelTestInstance`)。
            3.  调用 `start_tests_for_batch`。
            4.  验证 `MockTestExecutionEngine.submit_test_instance` 是否被正确调用。
            5.  验证 `TestOrchestrationService` 中的 outcome processing loop 是否能接收到 `MockTestExecutionEngine` 发送的 `RawTestOutcome`。
            6.  验证对于每个收到的 `RawTestOutcome`，`MockChannelStateManager.apply_raw_outcome` 是否被以正确的参数调用。
            7.  验证 `MockTestRecordService.save_channel_test_instance` 是否被调用。
        *   测试错误场景：如 `submit_test_instance` 失败，`apply_raw_outcome` 失败等。

---

## Phase 3: 后端服务完善与 Tauri 集成

**目标：** 完善所有后端服务的接口和主要功能实现，搭建Tauri应用，并通过Tauri Command将后端服务暴露给未来的前端，实现初步的前后端通信。

### 步骤 3.1: 完善所有后端服务接口的其余方法实现

*   **原因 (Reason)**:
    *   在与前端集成之前，后端应具备相对完整的功能集，以支持核心业务流程的闭环。
*   **期望效果 (Expected Outcome)**:
    *   **`ITestOrchestrationService`**: 实现 `confirm_wiring_for_batch`, `pause/resume/stop_tests_for_batch`, `retest_channel_instance`, `skip_channel_instance`, `get_batch_status_and_instances`, `get_channel_instance_details` 等方法。
        *   **新增/相关数据模型 (Rust, in `models.rs` or a new `payloads.rs`):**
            ```rust
            use crate::models::{TestBatchInfo, ChannelTestInstance, ChannelPointDefinition}; // Assuming models are in crate::models
            use serde::{Serialize, Deserialize};

            #[derive(Debug, Clone, Serialize, Deserialize)]
            pub struct BatchDetailsPayload {
                pub batch_info: TestBatchInfo,
                pub instances: Vec<ChannelTestInstance>,
            }

            #[derive(Debug, Clone, Serialize, Deserialize)]
            pub struct ChannelInstanceDetailsPayload {
                pub instance: ChannelTestInstance,
                pub definition: ChannelPointDefinition,
            }
            ```
    *   **`IDataManagementService`**: 完善 `export_test_results_to_excel` (可能使用 `rust_xlsxwriter` crate) 和其他数据管理功能。
    *   **`IManualTestService`**: 实现 `execute_manual_sub_test`, `read_current_value`, `write_value_manual`。
        *   **相关数据模型 (Rust):**
            *   `execute_manual_sub_test` 参数可能需要: `instance_id: String`, `sub_test_item: SubTestItem`, `params: Option<HashMap<String, serde_json::Value>>` (用于传递如手动设定的值)。
    *   **`IChannelConfigurationService`**: (如果需要) 实现完整的CRUD操作。
    *   **`IStatisticsService`**: 实现 `calculate_batch_statistics`。
    *   所有实现都应包含完整的错误处理和日志记录。
*   **实施描述 (Implementation Description)**:
    1.  **`ITestOrchestrationService` 方法实现**:
        *   `confirm_wiring_for_batch`: 遍历实例，调用 `IChannelStateManager.prepare_for_wiring_confirmation`。
        *   `pause/resume/stop`: 调用 `ITestExecutionEngine` 对应的方法，并管理 `active_batches` 中的状态。
        *   `retest_channel_instance`: 调用 `IChannelStateManager.reset_for_retest`，然后重新将实例提交给 `ITestExecutionEngine`。
        *   `skip_channel_instance`: 调用 `IChannelStateManager.mark_as_skipped`。
        *   Getter方法: 从 `active_batches` (或 `ITestRecordService`) 读取数据并返回。
    2.  **`IDataManagementService.export_test_results_to_excel`**: 使用 `rust_xlsxwriter` crate 创建和写入Excel。遍历 `ChannelTestInstance` 数据，将其格式化到工作表中。
    3.  **`IManualTestService` 方法实现**:
        *   `execute_manual_sub_test`: 获取 `ChannelTestInstance` 和 `ChannelPointDefinition`。创建对应的 `ISpecificTestStepExecutor`，调用其 `execute` 方法。获取 `RawTestOutcome`，然后调用 `IChannelStateManager.apply_raw_outcome`。返回 `RawTestOutcome`。
        *   `read_current_value`/`write_value_manual`: 可能需要特定的 `ISpecificTestStepExecutor` (如 `GenericReadExecutor`, `GenericWriteExecutor`) 或直接调用 `IPlcCommunicationService`。
    4.  **`IStatisticsService.calculate_batch_statistics`**: 遍历 `ChannelTestInstance` 列表，根据其 `overall_status` 统计总数、通过数、失败数等，并更新传入的 `TestBatchInfo`。
    5.  为所有新实现的方法编写单元测试和集成测试，重点测试服务间的交互和业务逻辑的正确性。
*   **如何测试 (How to Test)**:
    *   **单元测试**: 针对每个服务新增的方法，mock其依赖项，验证方法逻辑。
        *   例如，测试 `ITestOrchestrationService.retest_channel_instance` 时，验证 `MockChannelStateManager.reset_for_retest` 和 `MockTestExecutionEngine.submit_test_instance` 是否被正确调用。
        *   测试 `IDataManagementService.export_test_results_to_excel`，可以不实际写文件，而是验证传递给 `rust_xlsxwriter` mock 包装器的数据是否正确。
    *   **集成测试**: 扩展 Phase 2 的集成测试，覆盖更完整的业务流程，如"导入->接线->开始测试->部分失败->重测失败点->跳过某个点->导出结果"。

### 步骤 3.2: 搭建 Tauri 应用骨架

*   **原因 (Reason)**:
    *   Tauri 是连接 Rust 后端和 Angular 前端的桥梁。
    *   尽早搭建Tauri应用，可以验证基本的项目配置和构建流程。
*   **期望效果 (Expected Outcome)**:
    *   使用 Tauri CLI 创建一个新的 Tauri 项目 (其中包含一个简单的 Rust 后端和一个Web前端的占位符)。
    *   能够成功构建并运行一个空白的 Tauri 应用窗口。
    *   Rust 后端核心逻辑 (在 Phase 1 & 2 开发的 services, models 等) 能够被Tauri主项目的 `main.rs` (或其模块) 引用和访问。
*   **实施描述 (Implementation Description)**:
    1.  确保已安装 Tauri 开发环境 (`Node.js`, `Rust`, `WebView2` (Windows), `webkit2gtk` (Linux), `Xcode Command Line Tools` (macOS))。
    2.  在项目根目录下 (与 `fat_test_backend` 平级或将其作为 `src-tauri` 的一部分) 执行 `npm create tauri-app@latest` (或 `yarn create tauri-app`, `pnpm create tauri-app`)。
    3.  按照提示选择项目名称 (e.g., `fat_test_desktop_app`)，选择前端模板 (可以选择 Vanilla JS 或一个简单的 HTML 页面作为初始占位，后续替换为 Angular)。
    4.  进入 `src-tauri` 目录，修改 `Cargo.toml` 以引用本地开发的后端核心库 (`fat_test_backend`)。例如，将其添加为 path dependency:
        ```toml
        # src-tauri/Cargo.toml
        [dependencies]
        # ... other tauri dependencies
        fat_test_backend = { path = "../fat_test_backend" } # 假设 fat_test_backend 与 tauri 项目根目录同级
        serde = "1.0"
        serde_json = "1.0"
        tokio = { version = "1", features = ["full"] }
        # ... 其他共享依赖
        ```
    5.  在 `src-tauri/src/main.rs` 中，尝试引入并实例化后端服务 (此时服务实例可能还未通过Tauri state管理)。
    6.  运行 `npm run tauri dev` (或 `yarn tauri dev`)，确保能看到一个Tauri窗口。
*   **如何测试 (How to Test)**:
    *   **成功构建和运行**: `npm run tauri dev` 命令成功执行，没有编译错误，并弹出一个桌面窗口。
    *   **日志输出**: 在 `src-tauri/src/main.rs` 的 `setup` 钩子中尝试调用后端服务的一个简单方法（例如，一个返回版本号的mock方法），并打印日志，确认后端代码被执行。

### 步骤 3.3: 通过 Tauri State 共享后端服务实例

*   **原因 (Reason)**:
    *   Tauri commands 需要访问后端服务的实例来执行操作。
    *   Tauri State 是推荐的在不同 command 之间安全共享状态（如服务实例）的方式。
*   **期望效果 (Expected Outcome)**:
    *   在 `src-tauri/src/main.rs` 中，创建所有后端服务（应用层服务为主）的实例。
    *   将这些服务实例包装在 `Arc<Mutex<T>>` (或 `Arc<T>` 如果服务本身是线程安全的且只需只读访问) 中。
    *   定义一个 `AppState` struct，包含这些包装后的服务实例。
    *   在 Tauri `Builder::manage` 中注册 `AppState`。
    *   Tauri commands 能够通过 `tauri::State<AppState>` 参数访问这些服务。
*   **实施描述 (Implementation Description)**:
    1.  在 `src-tauri/src/main.rs` (或一个单独的 `app_state.rs` 模块) 中定义 `AppState` struct:
        ```rust
        use std::sync::{Arc, Mutex};
        // 假设已正确 use 后端服务的 trait 和实现
        // use fat_test_backend::services::application::test_orchestration::{ITestOrchestrationService, TestOrchestrationService};
        // ... 其他服务

        pub struct AppState {
            pub test_orchestration_service: Arc<dyn ITestOrchestrationService + Send + Sync>,
            pub data_management_service: Arc<dyn IDataManagementService + Send + Sync>,
            // ... 其他服务
        }
        ```
    2.  在 `main` 函数中初始化服务和 `AppState`:
        ```rust
        fn main() {
            // 1. 初始化基础设施服务 (Mock 或真实实现)
            let mock_plc_service = Arc::new(MockPlcCommunicationService::new());
            let mock_persistence_service = Arc::new(MockPersistenceService::new()); // Or JsonFilePersistenceService

            // 2. 初始化领域服务 (它们依赖基础设施服务)
            let channel_state_manager = Arc::new(ChannelStateManager::new());
            let test_execution_engine = Arc::new(TestExecutionEngine::new(
                mock_plc_service.clone(), // test rig plc
                mock_plc_service.clone(), // target plc (can be different instances)
                4 // max concurrent tasks
            ));
            let test_record_service = Arc::new(TestRecordService::new(mock_persistence_service.clone()));
            // ...其他领域服务

            // 3. 初始化应用服务 (它们依赖领域服务)
            let data_management_service_impl = Arc::new(DataManagementService::new(
                mock_persistence_service.clone()
                // channel_state_manager.clone() // if needed
            ));
            let test_orchestration_service_impl = Arc::new(TestOrchestrationService::new(
                data_management_service_impl.clone(),
                test_execution_engine.clone(),
                channel_state_manager.clone(),
                test_record_service.clone(),
                // channel_config_service, // if any
                // app_handle (set later in setup hook or passed if available)
            ));

            let app_state = AppState {
                test_orchestration_service: test_orchestration_service_impl,
                data_management_service: data_management_service_impl,
            };

            tauri::Builder::default()
                .manage(app_state) // 注册 AppState
                // .setup(|app| { ... Optional: set app_handle in services if needed ... })
                .invoke_handler(tauri::generate_handler![/* command functions here */])
                .run(tauri::generate_context!()) disgraceful_exit
                .expect("error while running tauri application");
        }
        ```
        *   注意：服务实例化顺序，确保依赖被正确注入。
        *   `Send + Sync` 对于 `Arc<dyn Trait>` 是必需的，以便在Tauri的多线程环境中安全共享。
*   **如何测试 (How to Test)**:
    *   **编写简单的Tauri Command**: 创建一个测试用的Tauri command，它接收 `tauri::State<AppState>`，并尝试调用 `AppState` 中某个服务的一个简单方法。从前端（或使用 `curl` 如果Tauri HTTP API暴露）调用此command，验证是否成功执行并返回预期结果。
    *   **日志确认**: 在command和服务方法中添加日志，确认服务实例被正确访问。

### 步骤 3.4: 实现核心业务流程的 Tauri Commands

*   **原因 (Reason)**:
    *   将后端核心业务流程通过Tauri Command暴露出来，是前端能够调用这些功能的前提。
*   **期望效果 (Expected Outcome)**:
    *   为架构文档和本实施计划中涉及的关键业务流程（导入、准备批次、开始测试、获取状态、手动测试等）创建对应的Tauri command函数。
    *   每个command函数应:
        *   接收来自前端的参数 (如文件路径、批次ID、实例ID、用户输入等)。
        *   通过 `tauri::State<AppState>` 获取相应的应用服务实例。
        *   调用服务实例的方法来执行业务逻辑。
        *   将服务方法返回的 `Result<T, AppError>` 转换为前端期望的 `Result<T_Serializable, String>`。
    *   在 `tauri::Builder::invoke_handler` 中注册所有这些commands。
    *   **相关数据模型 (Rust, for Command Payloads/Responses, in `commands.rs` or `payloads.rs`):**
        ```rust
        use crate::models::enums::SubTestItem;
        use crate::models::structs::{TestBatchInfo, ChannelTestInstance, RawTestOutcome};
        use crate::models::payloads::BatchDetailsPayload; // Assuming BatchDetailsPayload is defined elsewhere
        use serde::{Serialize, Deserialize};
        use std::collections::HashMap;

        #[derive(Debug, Clone, Serialize, Deserialize)]
        pub struct ImportExcelAndPrepareBatchCmdArgs {
            pub file_path_str: String, 
            pub product_model: Option<String>,
            pub serial_number: Option<String>,
        }
        // 返回值使用 BatchDetailsPayload or a specific response struct
        // Example of specific response struct:
        #[derive(Debug, Clone, Serialize, Deserialize)]
        pub struct ImportAndPrepareBatchResponse {
             pub batch_info: TestBatchInfo,
             pub instances: Vec<ChannelTestInstance>,
        }
        // Command: Result<ImportAndPrepareBatchResponse, String>

        #[derive(Debug, Clone, Serialize, Deserialize)]
        pub struct StartTestsForBatchCmdArgs {
            pub batch_id: String,
        }
        // Command: Result<(), String>

        #[derive(Debug, Clone, Serialize, Deserialize)]
        pub struct GetBatchStatusCmdArgs {
            pub batch_id: String,
        }
        // Command: Result<BatchDetailsPayload, String>

        #[derive(Debug, Clone, Serialize, Deserialize)]
        pub struct ExecuteManualSubTestCmdArgs {
            pub instance_id: String, 
            pub sub_test_item: SubTestItem,
            pub params: Option<HashMap<String, serde_json::Value>>
        }
        // Command: Result<RawTestOutcome, String>
        
        #[derive(Debug, Clone, Serialize, Deserialize)]
        pub struct ReadChannelValueCmdArgs { // For manual read
            pub instance_id: String,
            //pub definition_id: String, // Or pass enough context to find the address
            pub plc_address: String, // Specific address to read
            pub data_type: crate::models::enums::PointDataType, // Expected data type
        }
        // Command: Result<serde_json::Value, String>

        #[derive(Debug, Clone, Serialize, Deserialize)]
        pub struct WriteChannelValueCmdArgs { // For manual write
            pub instance_id: String, 
            //pub definition_id: String,
            pub plc_address: String, // Specific address to write
            pub data_type: crate::models::enums::PointDataType,
            pub value_to_write: serde_json::Value,
        }
        // Command: Result<(), String>
        ```
*   **实施描述 (Implementation Description)**:
    1.  创建一个 `src-tauri/src/commands.rs` (或多个) 文件来组织command函数。
    2.  **示例 Command (`import_excel_and_prepare_batch_cmd`)**:
        ```rust
        // src-tauri/src/commands.rs
        use crate::AppState;
        // Assuming command-specific arg/response structs are defined (e.g., in a sub-module or payloads.rs)
        use super::payloads::{ImportExcelAndPrepareBatchCmdArgs, ImportAndPrepareBatchResponse, BatchDetailsPayload, /* other command args/responses */ }; 
        use fat_test_backend::models::{TestBatchInfo, ChannelTestInstance, ChannelPointDefinition}; // Core models
        use fat_test_backend::errors::AppError;
        use std::path::PathBuf;

        #[tauri::command]
        pub async fn import_excel_and_prepare_batch_cmd(
            args: ImportExcelAndPrepareBatchCmdArgs, 
            state: tauri::State<'_, AppState>
        ) -> Result<ImportAndPrepareBatchResponse, String> { // Using specific response struct
            let file_path = PathBuf::from(args.file_path_str);
            
            let (definitions, extracted_batch_info) = state.data_management_service
                .import_channel_definitions_from_excel(file_path).await
                .map_err(|e| e.to_string())?;

            let batch_to_create = extracted_batch_info.unwrap_or_else(|| TestBatchInfo {
                batch_id: uuid::Uuid::new_v4().to_string(),
                product_model: args.product_model,
                serial_number: args.serial_number,
                ..Default::default()
            });

            let test_batch_info = state.test_orchestration_service
                .create_test_batch(batch_to_create.product_model, batch_to_create.serial_number).await
                .map_err(|e| e.to_string())?;

            let definition_ids: Vec<String> = definitions.iter().map(|d| d.id.clone()).collect();
            // Assuming prepare_test_instances_for_batch is modified or a new method prepares based on full definitions
            let instances = state.test_orchestration_service
                .prepare_test_instances_for_batch_from_defs(&test_batch_info.batch_id, definitions).await // Hypothetical method
                .map_err(|e| e.to_string())?;
            
            Ok(ImportAndPrepareBatchResponse { batch_info: test_batch_info, instances })
        }
        
        // Implement other commands similarly using their respective Arg and Response structs
        #[tauri::command]
        pub async fn start_tests_for_batch_cmd(
            args: StartTestsForBatchCmdArgs,
            state: tauri::State<'_, AppState>
        ) -> Result<(), String> {
            state.test_orchestration_service.start_tests_for_batch(&args.batch_id).await.map_err(|e| e.to_string())
        }

        #[tauri::command]
        pub async fn get_batch_status_cmd(
            args: GetBatchStatusCmdArgs,
            state: tauri::State<'_, AppState>
        ) -> Result<BatchDetailsPayload, String> { // Using BatchDetailsPayload directly
            state.test_orchestration_service.get_batch_status_and_instances(&args.batch_id).await.map_err(|e| e.to_string())
        }

        // ... other commands: execute_manual_sub_test_cmd, etc.
        ```
    3.  实现其他核心流程的Tauri Commands，如 `execute_manual_sub_test_cmd` 等，它们分别调用 `ITestOrchestrationService` 和 `IManualTestService` 的方法。
    4.  在 `src-tauri/src/main.rs` 中注册这些commands:
        ` .invoke_handler(tauri::generate_handler![import_excel_and_prepare_batch_cmd, start_tests_for_batch_cmd, get_batch_status_cmd, /* more commands */])`
*   **如何测试 (How to Test)**:
    *   **Tauri DevTools + 前端占位符**: (如果前端还是简单页面)
        *   在Tauri应用的Webview中打开开发者工具。
        *   在控制台使用 `window.__TAURI__.invoke('command_name', { param1: value1 })` 来手动调用Tauri commands。
        *   检查控制台输出的 `Promise` 解析结果是否符合预期（成功时的数据，失败时的错误字符串）。
        *   检查后端Rust控制台的日志输出，确认服务方法被调用，逻辑按预期执行。
    *   **自动化API测试工具 (如果可能)**: 如果Tauri的HTTP Server被启用（默认不用于IPC），可以使用Postman或类似工具测试。但通常IPC测试更依赖前端交互或特定测试脚本。
    *   **端到端流程模拟**: 通过手动调用一系列Tauri commands来模拟一个完整的业务流程，例如：
        1.  `import_excel_and_prepare_batch_cmd` (使用一个测试Excel文件)。
        2.  `confirm_wiring_cmd` (使用上一步返回的 `batch_id`)。
        3.  `start_tests_for_batch_cmd`。
        4.  多次调用 `get_batch_status_cmd` 观察状态变化 (此时需要 `MockTestExecutionEngine` 模拟发送 `RawTestOutcome` 给 `TestOrchestrationService` 的内部循环，这个循环再通过 `MockChannelStateManager` 更新状态)。
        *   这一步的测试会比较复杂，因为它依赖于Phase 2中 `TestOrchestrationService` 内部事件循环和状态更新的正确性，以及所有Mock服务的协同工作。

### 步骤 3.5: 实现后端到前端的事件通知机制 (Tauri Events)

*   **原因 (Reason)**:
    *   许多操作（如测试进度、单点状态更新）需要从后端实时通知前端，而不是前端轮询。
*   **期望效果 (Expected Outcome)**:
    *   在 `TestOrchestrationService` (或其他需要发事件的服务) 中，当关键状态变化时（如 `ChannelTestInstance` 状态更新，批次进度更新），能够通过 `tauri::AppHandle.emit_all` 发送事件给前端。
    *   定义清晰的事件名称 (e.g., `"channel_state_changed"`, `"batch_progress_update"`, `"log_message_event"`) 和对应的Payload结构体 (需 `Serialize`)。
    *   **事件Payload定义 (Rust, in `models/payloads.rs` or a dedicated `events.rs`):**
        ```rust
        use crate::models::structs::{ChannelTestInstance, TestBatchInfo}; // Or specific fields from them
        use crate::models::enums::OverallTestStatus;
        use serde::{Serialize, Deserialize};
        use chrono::{DateTime, Utc};

        #[derive(Debug, Clone, Serialize, Deserialize)]
        pub struct ChannelStateChangedEventPayload {
            pub batch_id: String,
            pub instance_id: String,
            // 可以只发送更新后的实例，或者更细粒度的变更信息
            pub updated_instance: ChannelTestInstance, 
        }

        #[derive(Debug, Clone, Serialize, Deserialize)]
        pub struct BatchProgressEventPayload {
            pub batch_id: String,
            pub tested_points: u32,
            pub total_points: u32,
            pub passed_points: u32,
            pub failed_points: u32,
            pub skipped_points: u32,
            pub overall_batch_status: OverallTestStatus,
            pub status_summary: Option<String>, // Optional: A human-readable summary string
        }

        #[derive(Debug, Clone, Serialize, Deserialize)]
        pub enum LogLevelEvent {
            Info,
            Warn,
            Error,
            Debug,
        }

        #[derive(Debug, Clone, Serialize, Deserialize)]
        pub struct LogMessageEventPayload {
            pub timestamp: DateTime<Utc>,
            pub level: LogLevelEvent,
            pub message: String,
            pub module_path: Option<String>, // e.g., "fat_test_backend::services::test_orchestration"
        }
        ```
    *   前端 (即使是占位符页面) 能够通过 `tauri-apps/api/event.listen` 接收到这些事件并打印其Payload。
*   **实施描述 (Implementation Description)**:
    1.  确保 `TestOrchestrationService` (或其他发事件的服务) 能够访问 `tauri::AppHandle`。
        *   可以在 `main` 函数中 `tauri::Builder::default().setup(|app| { ... })` 钩子中获取 `app.handle()`，并将其传递/设置到服务实例中（需要服务设计为可接收 `AppHandle`，可能通过 `Option<AppHandle>` 字段和初始化方法）。
    2.  在 `TestOrchestrationService` 中处理 `RawTestOutcome` 的循环内部，当 `ChannelTestInstance` 状态被 `ChannelStateManager` 更新后，或批次统计更新后:
        ```rust
        // In TestOrchestrationService, after instance state is updated
        // Assuming payloads are defined in e.g. crate::models::events::* 
        use crate::models::events::{ChannelStateChangedEventPayload, BatchProgressEventPayload};

        if let Some(handle) = &self.app_handle { // Assuming self.app_handle: Option<tauri::AppHandle>
            let event_payload = ChannelStateChangedEventPayload {
                batch_id: updated_instance.batch_id.clone(),
                instance_id: updated_instance.instance_id.clone(),
                updated_instance: updated_instance.clone(),
            };
            if let Err(e) = handle.emit_all("fat://channel_state_changed", event_payload) { // Using custom event name
                error!("Failed to emit channel_state_changed event: {}", e);
            }

            // After batch statistics are updated (e.g., in TestBatchInfo)
            let batch_progress_payload = BatchProgressEventPayload {
                batch_id: current_batch_info.batch_id.clone(),
                tested_points: current_batch_info.tested_points,
                total_points: current_batch_info.total_points,
                passed_points: current_batch_info.passed_points,
                failed_points: current_batch_info.failed_points,
                skipped_points: current_batch_info.skipped_points,
                overall_batch_status: current_batch_info.overall_status, // Assuming TestBatchInfo now has this
                status_summary: current_batch_info.status_summary.clone(),
            };
            if let Err(e) = handle.emit_all("fat://batch_progress_update", batch_progress_payload) {
                error!("Failed to emit batch_progress_update event: {}", e);
            }
        }
        ```
    3.  (如果实现全局日志推送) 在日志系统的实现中，当捕获到日志条目时，构建 `LogMessageEventPayload` 并通过 `AppHandle` 发送 `"fat://log_message"` 事件。
    4.  在前端的简单JS中 (Tauri模板自带的 `main.js` 或一个简单HTML的 `<script>` 标签内):
        ```javascript
        // Using global tauri functions if in simple HTML/JS page
        const { listen } = window.__TAURI__.event;

        async function setupEventListeners() {
            await listen('fat://channel_state_changed', (event) => {
                console.log('Event: channel_state_changed', event.payload);
            });
            await listen('fat://batch_progress_update', (event) => {
                console.log('Event: batch_progress_update', event.payload);
            });
            await listen('fat://log_message', (event) => {
                console.log('Log [' + event.payload.level + ']: ' + event.payload.message, event.payload);
            });
            console.log('Tauri event listeners set up.');
        }
        setupEventListeners();
        ```
*   **如何测试 (How to Test)**:
    *   **前端控制台日志**: 运行Tauri应用。通过调用Tauri Command触发后端逻辑（如 `start_tests_for_batch_cmd`，它内部会更新状态并应发送事件）。
    *   观察前端Webview开发者工具的控制台，确认是否收到了 `channel_state_changed` 等事件，并且Payload内容正确。
    *   **后端日志**: 确认后端服务中 `emit_all` 调用成功，没有错误日志。
    *   测试不同类型的事件和Payload。

---

## Phase 4: 前端 (Angular) 基础搭建与初步集成

**目标：** 搭建 Angular 前端项目，实现与 Tauri 后端的基本通信（调用Commands，监听Events），并构建核心页面和组件的骨架，为实现完整功能做准备。

### 步骤 4.1: 初始化 Angular 项目并集成到 Tauri

*   **原因 (Reason)**:
    *   Angular 将作为前端 UI 框架。
    *   需要将 Angular 项目正确配置为 Tauri 应用的前端部分。
*   **期望效果 (Expected Outcome)**:
    *   在 Tauri 项目的根目录下 (与 `src-tauri` 同级) 创建一个新的 Angular 项目 (e.g., `fat_test_frontend`)。
    *   配置 `tauri.conf.json` 中的 `build.devPath` 和 `build.distDir` 以指向 Angular 开发服务器和构建输出目录。
    *   能够通过 `npm run tauri dev` 同时启动 Rust 后端和 Angular 开发服务器，并在 Tauri 窗口中看到 Angular 应用的默认页面。
    *   Angular 项目中安装 `@tauri-apps/api`。
*   **实施描述 (Implementation Description)**:
    1.  在 Tauri 项目的根目录下，使用 Angular CLI 创建新项目: `ng new fat_test_frontend --routing --style=scss` (或根据喜好选择)。
    2.  进入 `fat_test_frontend` 目录，安装 Tauri API: `npm install @tauri-apps/api`。
    3.  **配置 `tauri.conf.json`** (位于 `src-tauri/tauri.conf.json`):
        *   `build.devPath`: 通常是 Angular 开发服务器的地址，默认为 `http://localhost:4200`。检查 `fat_test_frontend/angular.json` 中 `serve.options.port` 的设置。
        *   `build.distDir`: Angular 构建输出的目录，相对于 `tauri.conf.json` 的路径。通常是 `../fat_test_frontend/dist/fat_test_frontend` (具体路径取决于 Angular 项目名和 `angular.json` 中的 `outputPath` 配置)。
        *   `build.beforeDevCommand`: 设置为 `"npm run --prefix ../fat_test_frontend start"` (或 `yarn --cwd ../fat_test_frontend start`)，以便 `tauri dev` 自动启动 Angular 开发服务器。
        *   `build.beforeBuildCommand`: 设置为 `"npm run --prefix ../fat_test_frontend build"` (或 `yarn --cwd ../fat_test_frontend build`)，以便 `tauri build` 自动构建 Angular 应用。
    4.  **修改 Angular `package.json`** (`fat_test_frontend/package.json`):
        *   修改 `scripts.start` 为 `ng serve` (如果原来是 `ng serve --open`，去掉 `--open`)。
        *   修改 `scripts.build` 为 `ng build` (确保生成到正确的 `distDir`)。
    5.  运行 `npm run tauri dev` 从项目根目录启动，验证 Tauri 窗口加载了 Angular 应用。
*   **如何测试 (How to Test)**:
    *   **成功运行**: `npm run tauri dev` 启动后，Tauri 窗口显示 Angular 的欢迎页面。
    *   **热重载**: 修改 Angular 组件的 HTML 或 TS 文件，Tauri 窗口中的内容应自动更新。
    *   **控制台无错误**: Rust 控制台和浏览器控制台都没有与Tauri或Angular集成相关的明显错误。

### 步骤 4.2: 创建 Angular 核心服务以封装 Tauri 通信

*   **原因 (Reason)**:
    *   将与 Tauri 后端的直接交互 (invoke commands, listen to events) 封装在 Angular 服务中，可以使组件代码更简洁、更易于测试，并提供一个统一的 API 供其他组件使用。
*   **期望效果 (Expected Outcome)**:
    *   创建 Angular 服务，如 `BackendCommsService` (或更具体的如 `TestOrchestrationApiService`, `DataManagementApiService`)。
    *   这些服务将使用 `@tauri-apps/api/tauri` 的 `invoke` 函数来调用后端 Tauri Commands。
    *   这些服务将使用 `@tauri-apps/api/event` 的 `listen` 和 `emit` 函数来处理后端事件。
    *   服务方法应返回 `Promise<T>` 或 `Observable<T>`，并处理来自后端的错误。
    *   **前端数据模型 (TypeScript Interfaces, in `src/app/models/` or similar):**
        *   需要为所有通过Tauri Commands参数传递、或作为返回值接收、或通过Tauri Events的Payload接收的Rust数据结构，在Angular前端创建对应的TypeScript接口。
        *   这些TS接口的结构（字段名、类型）必须与Rust结构体经过`serde`序列化后的JSON格式完全对应。
        *   **主要包括 (但不限于):**
            *   Enums: `OverallTestStatus`, `SubTestStatus`, `ModuleType`, `PointDataType`, `SubTestItem`, `LogLevelEvent` (TS中通常用字符串字面量联合类型或数字枚举实现)。
            *   Structs: `ChannelPointDefinition`, `ChannelTestInstance`, `SubTestExecutionResult`, `AnalogReadingPoint`, `TestBatchInfo`, `RawTestOutcome`.
            *   Command Args/Response Payloads: `ImportExcelAndPrepareBatchCmdArgs`, `ImportAndPrepareBatchResponse`, `StartTestsForBatchCmdArgs`, `GetBatchStatusCmdArgs`, `BatchDetailsPayload`, `ExecuteManualSubTestCmdArgs`, `ReadChannelValueCmdArgs`, `WriteChannelValueCmdArgs`.
            *   Event Payloads: `ChannelStateChangedEventPayload`, `BatchProgressEventPayload`, `LogMessageEventPayload`.
        *   **建议**: 可以考虑使用工具如 `ts-rs` (Rust crate) 自动从Rust数据结构生成TypeScript定义，以确保一致性并减少手动编写错误。如果手动编写，务必仔细核对。
*   **实施描述 (Implementation Description)**:
    1.  使用 Angular CLI 生成服务：
        `ng generate service services/backend-comms` (或按功能划分，如 `services/test-orchestration-api`)
    2.  **创建TypeScript接口文件 (e.g., `src/app/models/backend-models.ts`)**:
        ```typescript
        // src/app/models/backend-models.ts

        // --- Enums (example using string literal union types) ---
        export type OverallTestStatus = 
            | 'NotTested' | 'Testing' | 'Paused' | 'TestCompletedPassed' 
            | 'TestCompletedFailed' | 'Skipped' | 'WiringConfirmationPending' 
            | 'HardPointTestCompleted' | 'Aborted';

        export type SubTestStatus =
            | 'NotTested' | 'Testing' | 'Passed' | 'Failed' 
            | 'Skipped' | 'NotApplicable' | 'Aborted';

        export type ModuleType = 'AI' | 'AO' | 'DI' | 'DO' | 'Custom';
        
        export type PointDataType = 'Bool' | 'Real' | 'Int' | 'DInt' | 'Word' | 'DWord';

        // SubTestItem can be extensive, map carefully or use string
        export type SubTestItem = 
            | 'Communication' | 'WiringConfirmation' | 'HardPoint' // ... and so on
            | string; // Or list all explicitly
        
        export type LogLevelEvent = 'Info' | 'Warn' | 'Error' | 'Debug';

        // --- Structs & Payloads ---
        export interface AnalogReadingPoint {
            timestamp: string; // ISO DateTime string
            set_value_eng?: number | null;
            read_value_eng?: number | null;
            set_value_raw?: any | null;
            read_value_raw?: any | null;
            success: boolean;
            message?: string | null;
        }

        export interface SubTestExecutionResult {
            item: SubTestItem;
            status: SubTestStatus;
            start_time?: string | null; // ISO DateTime string
            end_time?: string | null;   // ISO DateTime string
            duration_ms?: number | null;
            message?: string | null;
            readings: AnalogReadingPoint[];
            details?: { [key: string]: any };
        }

        export interface ChannelPointDefinition {
            id: string;
            tag_name: string;
            description: string;
            module_type: ModuleType;
            plc_node_name_primary?: string | null;
            primary_address_read?: string | null;
            primary_address_write?: string | null;
            primary_data_type?: PointDataType | null;
            // ... other fields from Rust struct, ensure casing (snake_case from Rust -> camelCase in TS by serde default, or match as is)
            // For example, if serde doesn't rename, then: range_low, range_high etc.
            // If serde renames to camelCase: rangeLow, rangeHigh.
            // It's CRUCIAL to match the JSON structure produced by Rust's serde.
            // Assuming no field renaming for simplicity here, matching Rust fields directly.
            eng_unit?: string | null;
            range_low?: number | null;
            range_high?: number | null;
            // ... all other fields
            applicable_sub_tests: SubTestItem[];
            custom_fields: { [key: string]: string };
        }

        export interface ChannelTestInstance {
            instance_id: string;
            channel_definition_id: string;
            batch_id: string;
            overall_status: OverallTestStatus;
            error_message?: string | null;
            creation_time: string; // ISO DateTime string
            last_updated_time: string; // ISO DateTime string
            start_test_time?: string | null;
            final_test_time?: string | null;
            total_test_duration_ms?: number | null;
            sub_test_results: { [key: string /* SubTestItem as string */]: SubTestExecutionResult };
            current_operator?: string | null;
            retries_count: number;
            transient_data?: { [key: string]: any };
        }

        export interface TestBatchInfo {
            batch_id: string;
            product_model?: string | null;
            serial_number?: string | null;
            creation_time: string; // ISO DateTime string
            // ... all other fields, carefully matching Rust TestBatchInfo
            total_points: number;
            tested_points: number;
            passed_points: number;
            failed_points: number;
            skipped_points: number;
            status_summary?: string | null;
            custom_data: { [key: string]: string };
        }

        export interface RawTestOutcome {
            channel_instance_id: string;
            sub_test_item: SubTestItem;
            success: boolean;
            message?: string | null;
            start_time: string; // ISO DateTime string
            end_time: string;   // ISO DateTime string
            readings: AnalogReadingPoint[];
            details?: { [key: string]: any };
        }

        // Command Specific Payloads (Args & Responses)
        export interface ImportExcelAndPrepareBatchCmdArgs {
            file_path_str: string;
            product_model?: string | null;
            serial_number?: string | null;
        }
        export interface ImportAndPrepareBatchResponse {
            batch_info: TestBatchInfo;
            instances: ChannelTestInstance[];
        }

        export interface StartTestsForBatchCmdArgs { batch_id: string; }
        export interface GetBatchStatusCmdArgs { batch_id: string; }
        // Assuming BatchDetailsPayload is defined based on Rust: 
        export interface BatchDetailsPayload {
            batch_info: TestBatchInfo;
            instances: ChannelTestInstance[];
        }

        export interface ExecuteManualSubTestCmdArgs {
            instance_id: string;
            sub_test_item: SubTestItem;
            params?: { [key: string]: any } | null;
        }
        // ReadChannelValueCmdArgs, WriteChannelValueCmdArgs similarly...

        // Event Payloads
        export interface ChannelStateChangedEventPayload {
            batch_id: string;
            instance_id: string;
            updated_instance: ChannelTestInstance;
        }

        export interface BatchProgressEventPayload {
            batch_id: string;
            tested_points: number;
            total_points: number;
            passed_points: number;
            failed_points: number;
            skipped_points: number;
            overall_batch_status: OverallTestStatus;
            status_summary?: string | null;
        }

        export interface LogMessageEventPayload {
            timestamp: string; // ISO DateTime string
            level: LogLevelEvent;
            message: string;
            module_path?: string | null;
        }
        ```
    3.  **`BackendCommsService` (示例 - updated with more specific types)**:
        ```typescript
        // src/app/services/backend-comms.service.ts
        import { Injectable, OnDestroy } from '@angular/core';
        import { invoke } from '@tauri-apps/api/tauri';
        import { listen, Event as TauriEvent, UnlistenFn } from '@tauri-apps/api/event';
        import { Observable, Subject } from 'rxjs';
        import { 
            TestBatchInfo, ChannelTestInstance, ChannelStateChangedEventPayload, 
            ImportExcelAndPrepareBatchCmdArgs, ImportAndPrepareBatchResponse,
            StartTestsForBatchCmdArgs, GetBatchStatusCmdArgs, BatchDetailsPayload,
            ExecuteManualSubTestCmdArgs, RawTestOutcome 
            // ... import other TS models as needed
        } from '../models/backend-models'; // Adjust path as needed

        @Injectable({
            providedIn: 'root'
        })
        export class BackendCommsService implements OnDestroy {
            private channelStateChangedSubject = new Subject<ChannelStateChangedEventPayload>();
            public channelStateChanged$: Observable<ChannelStateChangedEventPayload> = this.channelStateChangedSubject.asObservable();
            // Other event subjects and observables...

            private unlistenFns: UnlistenFn[] = [];

            constructor() {
                this.listenToAllEvents();
            }

            async importExcelAndPrepareBatch(args: ImportExcelAndPrepareBatchCmdArgs):
                Promise<ImportAndPrepareBatchResponse> {
                try {
                    // Note: Rust command might return a tuple [TestBatchInfo, ChannelTestInstance[]]
                    // which needs to be mapped to ImportAndPrepareBatchResponse if not directly returned as such.
                    // The example Rust command for import_excel_and_prepare_batch_cmd was updated to return ImportAndPrepareBatchResponse.
                    return await invoke<ImportAndPrepareBatchResponse>('import_excel_and_prepare_batch_cmd', args);
                } catch (error) {
                    console.error('Error invoking import_excel_and_prepare_batch_cmd:', error);
                    throw error; // Or handle more gracefully
                }
            }

            async startTestsForBatch(args: StartTestsForBatchCmdArgs): Promise<void> {
                try {
                    await invoke<void>('start_tests_for_batch_cmd', args);
                } catch (error) {
                    console.error('Error invoking start_tests_for_batch_cmd:', error);
                    throw error;
                }
            }
            
            async getBatchDetails(args: GetBatchStatusCmdArgs): Promise<BatchDetailsPayload> {
                try {
                    return await invoke<BatchDetailsPayload>('get_batch_status_cmd', args);
                } catch (error) {
                    console.error('Error invoking get_batch_status_cmd:', error);
                    throw error;
                }
            }

            async executeManualSubTest(args: ExecuteManualSubTestCmdArgs): Promise<RawTestOutcome> {
                try {
                    return await invoke<RawTestOutcome>('execute_manual_sub_test_cmd', args);
                } catch (error) {
                    console.error('Error invoking execute_manual_sub_test_cmd:', error);
                    throw error;
                }
            }

            // ... Other Command-calling methods

            private async listenToAllEvents(): Promise<void> {
                const unlistenChannelState = await listen<ChannelStateChangedEventPayload>('fat://channel_state_changed', (event) => {
                    console.log('FE: Received channel_state_changed', event.payload);
                    this.channelStateChangedSubject.next(event.payload);
                });
                this.unlistenFns.push(unlistenChannelState);
                
                // Add listeners for BatchProgressEventPayload, LogMessageEventPayload etc.
            }

            ngOnDestroy() {
                this.unlistenFns.forEach(fn => fn());
            }
        }
        ```
*   **如何测试 (How to Test)**:
    *   **Angular 单元测试 (Jasmine/Karma)**:
        *   Mock `@tauri-apps/api/tauri` 的 `invoke` 函数和 `@tauri-apps/api/event` 的 `listen` 函数。
        *   测试服务方法调用 `invoke` 时是否使用了正确的 command 名称和参数 (matching the TS Args interfaces)。
        *   测试服务方法是否能正确处理 `invoke` 成功 (matching TS Response interfaces) 和失败的 `Promise`。
        *   测试事件监听是否被设置，并在 `ngOnDestroy` 中被清理。
        *   测试事件触发时，服务内部的 `Subject` 是否正确发出值 (matching TS Event Payload interfaces)。
    *   **组件集成测试**: 创建一个简单的测试组件，注入这些服务，调用服务方法并订阅事件，验证组件是否能正确接收数据和更新。

### 步骤 4.3: 创建核心页面和组件骨架 (Angular)

*   **原因 (Reason)**:
    *   为应用的主要功能区创建占位符页面和组件，明确应用的导航结构和主要视图。
*   **期望效果 (Expected Outcome)**:
    *   创建主要的 Angular 组件，例如：
        *   `AppComponent` (根组件，可能包含总体布局、导航栏、页脚)。
        *   `BatchManagementComponent` (用于创建/选择批次、导入点位表)。
        *   `TestExecutionComponent` (用于显示测试进度、通道列表、单个通道详细信息)。
        *   `ManualTestComponent` (用于手动测试功能)。
        *   `ChannelListComponent`, `ChannelDetailComponent`, `TestProgressSummaryComponent` (可复用子组件)。
    *   配置 Angular 路由 (`app-routing.module.ts`) 以实现页面间的导航。
    *   组件具有基本的 HTML 结构和样式，但逻辑可能还很简单。
*   **实施描述 (Implementation Description)**:
    1.  使用 Angular CLI 生成组件和模块：
        `ng generate component components/batch-management --module app`
        `ng generate component components/test-execution --module app`
        `ng generate component components/manual-test --module app`
        `ng generate component components/shared/channel-list --module app` (如果需要共享组件模块)
    2.  **`app-routing.module.ts` 配置**:
        ```typescript
        import { NgModule } from '@angular/core';
        import { RouterModule, Routes } from '@angular/router';
        import { BatchManagementComponent } from './components/batch-management/batch-management.component';
        import { TestExecutionComponent } from './components/test-execution/test-execution.component';
        import { ManualTestComponent } from './components/manual-test/manual-test.component';

        const routes: Routes = [
            { path: 'batch', component: BatchManagementComponent },
            { path: 'test/:batchId', component: TestExecutionComponent }, // Example with param
            { path: 'manual', component: ManualTestComponent },
            { path: '', redirectTo: '/batch', pathMatch: 'full' }
        ];

        @NgModule({
            imports: [RouterModule.forRoot(routes, { useHash: true })], // useHash for Tauri if not using custom protocol
            exports: [RouterModule]
        })
        export class AppRoutingModule { }
        ```
        *   `useHash: true` 通常在Tauri的Webview环境中是推荐的，除非你配置了自定义协议来处理深链接。
    3.  **`app.component.html` (示例布局)**:
        ```html
        <nav>
            <ul>
                <li><a routerLink="/batch">Batch Management</a></li>
                <li><a routerLink="/manual">Manual Test</a></li>
                <!-- Test Execution link might be dynamic or part of batch flow -->
            </ul>
        </nav>
        <router-outlet></router-outlet>
        ```
    4.  为每个新创建的组件添加基本的 HTML 占位符内容。
*   **如何测试 (How to Test)**:
    *   **手动导航测试**: 运行 `npm run tauri dev`，在应用中点击导航链接，验证路由是否按预期工作，对应的组件是否被加载显示。
    *   **Angular 单元测试**: 为组件编写基本的单元测试，验证它们是否能被创建。

### 步骤 4.4: 初步实现核心页面的数据绑定和交互

*   **原因 (Reason)**:
    *   使前端页面能够通过调用 `BackendCommsService` 来获取数据、发送命令，并通过订阅其 `Observable` 来响应后端事件，从而实现基本的功能交互。
*   **期望效果 (Expected Outcome)**:
    *   `BatchManagementComponent`: 实现文件选择 (`<input type="file">`)，调用 `BackendCommsService.importExcelAndPrepareBatch`，显示返回的批次信息和实例列表的摘要，并导航到测试执行页面。
    *   `TestExecutionComponent`: 接收 `batchId` 路由参数，调用服务获取批次详情和实例列表，展示通道列表。当用户点击"开始测试"按钮时，调用 `BackendCommsService.startTestsForBatch`。订阅 `BackendCommsService.channelStateChanged$` 以实时更新通道状态。
    *   组件能够处理加载状态 (loading indicators) 和错误显示。
*   **实施描述 (Implementation Description)**:
    1.  **`BatchManagementComponent.ts` (示例)**:
        ```typescript
        import { Component } from '@angular/core';
        import { Router } from '@angular/router';
        import { BackendCommsService, TestBatchInfo, ChannelTestInstance } from '../../services/backend-comms.service';
        import { open } from '@tauri-apps/api/dialog';

        @Component({
          selector: 'app-batch-management',
          templateUrl: './batch-management.component.html',
          // ...
        })
        export class BatchManagementComponent {
          isLoading = false;
          error: string | null = null;
          currentBatch: TestBatchInfo | null = null;
          currentInstances: ChannelTestInstance[] = [];

          constructor(private backendService: BackendCommsService, private router: Router) {}

          async onFileSelectAndImport() {
            try {
                const selectedPath = await open({ directory: false, multiple: false });
                if (selectedPath && !Array.isArray(selectedPath)) { // Single file selected
                    this.isLoading = true;
                    this.error = null;
                    const { batchInfo, instances } = await this.backendService.importExcelAndPrepareBatch(selectedPath);
                    this.currentBatch = batchInfo;
                    this.currentInstances = instances;
                    // Optionally navigate or enable next steps
                    if (this.currentBatch) {
                        this.router.navigate(['/test', this.currentBatch.batch_id]);
                    }
                } else {
                    console.log("File selection cancelled or multiple files selected (not supported).");
                }
            } catch (err: any) {
                this.error = err.message || 'Failed to import and prepare batch.';
                console.error(err);
            } finally {
                this.isLoading = false;
            }
          }
        }
        ```
    2.  **`TestExecutionComponent.ts` (示例)**:
        ```typescript
        import { Component, OnInit, OnDestroy } from '@angular/core';
        import { ActivatedRoute } from '@angular/router';
        import { BackendCommsService, ChannelTestInstance, ChannelStateChangedPayload } from '../../services/backend-comms.service';
        import { Subscription } from 'rxjs';

        @Component({
          selector: 'app-test-execution',
          templateUrl: './test-execution.component.html',
          // ...
        })
        export class TestExecutionComponent implements OnInit, OnDestroy {
          batchId: string | null = null;
          instances: ChannelTestInstance[] = [];
          isLoading = false;
          error: string | null = null;
          private stateChangeSub: Subscription | null = null;

          constructor(private route: ActivatedRoute, private backendService: BackendCommsService) {}

          ngOnInit(): void {
            this.batchId = this.route.snapshot.paramMap.get('batchId');
            if (this.batchId) {
              this.loadInitialData(this.batchId);
              this.stateChangeSub = this.backendService.channelStateChanged$.subscribe(payload => {
                if (payload.batch_id === this.batchId) {
                  this.updateInstanceInList(payload.instance);
                }
              });
            }
          }

          async loadInitialData(batchId: string) {
            // Placeholder: Need a backend command to get instances for an existing batch
            // For now, assume instances might be passed via state or re-fetched
            // This might be part of the data returned by import/prepare, or a new command
            // e.g., this.instances = await this.backendService.getInstancesForBatch(batchId);
          }

          updateInstanceInList(updatedInstance: ChannelTestInstance) {
            const index = this.instances.findIndex(inst => inst.instance_id === updatedInstance.instance_id);
            if (index !== -1) {
              this.instances[index] = updatedInstance;
              this.instances = [...this.instances]; // Trigger change detection if needed
            }
          }

          async startBatchTest() {
            if (!this.batchId) return;
            this.isLoading = true; this.error = null;
            try {
                await this.backendService.startTestsForBatch(this.batchId);
                // UI might show a global "testing in progress" state
            } catch (err: any) {
                this.error = err.message || 'Failed to start batch test.';
            } finally {
                this.isLoading = false;
            }
          }

          ngOnDestroy(): void {
            if (this.stateChangeSub) {
              this.stateChangeSub.unsubscribe();
            }
          }
        }
        ```
    3.  在对应的 HTML 模板中，使用 `*ngIf` 显示加载状态和错误消息，使用 `*ngFor` 遍历和显示数据列表。
*   **如何测试 (How to Test)**:
    *   **手动端到端测试**: 运行 `npm run tauri dev`。
        *   在 `BatchManagementComponent` 中，点击导入按钮，选择一个（需要预先准备的）测试用Excel文件。验证数据是否加载，批次信息是否显示，以及是否导航到测试执行页面。
        *   在 `TestExecutionComponent` 中，验证通道列表是否（初步）显示。点击"开始测试"按钮。观察后端日志和（如果已实现）前端状态更新（通过Tauri事件）。
    *   **浏览器控制台**: 监控网络请求 (Tauri IPC 调用在浏览器网络面板中不可见，但可以在Rust端日志和JS `console.log` 追踪) 和JS错误。
    *   **组件单元/集成测试**: 扩展之前的单元测试，mock `BackendCommsService` 的方法调用，验证组件的属性和视图是否根据服务返回的数据或错误正确更新。

---

## Phase 5: UI/UX 细化与功能完善

**目标：** 基于骨架，细化 Angular 组件的 UI 设计和用户体验，实现更完整的前端功能，包括数据显示、用户交互、表单验证、错误提示、国际化等，并对现有功能进行迭代和优化。

### 步骤 5.1: UI 组件库集成与全局样式定义

*   **原因 (Reason)**:
    *   使用成熟的 UI 组件库可以快速构建美观且一致的用户界面，提高开发效率。
    *   定义全局样式和主题有助于保持应用的视觉统一性。
*   **期望效果 (Expected Outcome)**:
    *   选择并集成一个 Angular UI 组件库 (如 Angular Material, NG-ZORRO, PrimeNG 等)。
    *   定义应用的全局 CSS 变量、主题色、基本布局样式等。
    *   核心页面 (`BatchManagement`, `TestExecution`, `ManualTest`) 开始使用所选 UI 组件库的组件替换原生 HTML 元素，以改善外观和交互。
*   **实施描述 (Implementation Description)**:
    1.  **选择 UI 组件库**: 评估各组件库的特性、文档、社区支持和设计风格，选择一个适合项目的。
        *   例如，若选择 Angular Material: `ng add @angular/material`。
        *   若选择 NG-ZORRO: `ng add ng-zorro-antd`。
    2.  **导入所需模块**: 在 `app.module.ts` (或共享模块) 中导入所选 UI 组件库提供的模块。
        ```typescript
        // Example for Angular Material
        import { MatButtonModule } from '@angular/material/button';
        import { MatInputModule } from '@angular/material/input';
        import { MatTableModule } from '@angular/material/table';
        // ... other modules

        @NgModule({
          imports: [
            // ..., MatButtonModule, MatInputModule, MatTableModule
          ]
        })
        export class AppModule { }
        ```
    3.  **全局样式**: 在 `src/styles.scss` (或相应的主题文件) 中定义全局样式、CSS 变量，或配置组件库的主题。
        ```scss
        // src/styles.scss
        // @use '@angular/material' as mat;
        // @include mat.core();
        // $my-primary: mat.define-palette(mat.$indigo-palette, 500);
        // $my-accent: mat.define-palette(mat.$pink-palette, A200, A100, A400);
        // $my-theme: mat.define-light-theme((
        //   color: (
        //     primary: $my-primary,
        //     accent: $my-accent,
        //   )
        // ));
        // @include mat.all-component-themes($my-theme);

        body { margin: 0; font-family: Roboto, "Helvetica Neue", sans-serif; }
        .container { padding: 20px; }
        // ... other global styles
        ```
    4.  **替换组件**: 逐步修改现有组件的 HTML 模板，使用 UI 组件库提供的组件。例如，用 `<button mat-raised-button color="primary">Import</button>` 替换 `<button>`。
*   **如何测试 (How to Test)**:
    *   **视觉检查**: 运行 `npm run tauri dev`，检查各页面组件是否正确渲染了新 UI 库的样式。
    *   **交互测试**: 测试新组件的交互行为 (如按钮点击、表单输入、表格排序等) 是否符合预期。
    *   **响应式检查**: 如果 UI 库支持响应式设计，检查在不同窗口大小下的布局表现。

### 步骤 5.2: 完善 `BatchManagementComponent` 功能与UI

*   **原因 (Reason)**:
    *   批次管理是应用的入口，需要清晰的用户引导和完整的操作流程。
*   **期望效果 (Expected Outcome)**:
    *   使用 UI 组件库美化文件选择按钮和显示区域。
    *   显示导入的 `ChannelPointDefinition` 列表的摘要 (例如，总数，各类型模块数量)。
    *   允许用户输入或确认批次信息 (产品型号、序列号) - 可以从Excel提取或用户手动输入。
    *   提供清晰的加载状态和错误反馈 (例如，使用进度条、消息框/Toast)。
    *   成功导入并准备好批次后，界面引导用户进入接线确认或直接开始测试的步骤。
*   **实施描述 (Implementation Description)**:
    1.  **UI 改进**: 使用如 `<mat-form-field>`, `<mat-progress-bar>`, `NzUpload`, `NzInput`, `NzModal` 等组件。
    2.  **批次信息表单**: 添加表单让用户可以编辑从Excel提取或新输入的批次信息。
    3.  **点位定义预览**: (可选) 显示一个可滚动的表格，简要列出导入的点位定义。
    4.  **错误处理**: 当 `BackendCommsService.importExcelAndPrepareBatch` 抛出错误时，使用对话框或Toast组件显示友好的错误消息。
    5.  **流程引导**: 成功后，按钮状态改变，例如"下一步：接线确认"或"开始测试"。
*   **如何测试 (How to Test)**:
    *   **手动测试所有交互**: 文件选择、批次信息输入、不同导入结果（成功、失败、部分成功）的UI反馈。
    *   **表单验证测试**: 如果有表单，测试其验证逻辑。

### 步骤 5.3: 完善 `TestExecutionComponent` 功能与UI

*   **原因 (Reason)**:
    *   测试执行是应用的核心监控界面，需要清晰地展示大量动态信息。
*   **期望效果 (Expected Outcome)**:
    *   使用表格组件 (如 `MatTable`, `NzTable`) 显示 `ChannelTestInstance` 列表，包含关键列：位号、描述、模块类型、当前状态、测试结果、进度等。
    *   表格应支持排序、筛选（按状态、模块类型等）。
    *   实时更新表格中通道的状态和测试结果 (基于从 `BackendCommsService` 订阅的事件)。
    *   实现测试控制按钮 (开始批次测试、暂停、继续、停止) 并调用相应的后端服务方法。
    *   提供批次整体进度的可视化 (如进度条、统计数据：总数/已测/通过/失败)。
    *   点击列表中的某个通道，可以导航到/显示一个 `ChannelDetailComponent`，展示该通道更详细的测试信息和子测试项状态。
*   **实施描述 (Implementation Description)**:
    1.  **表格实现**: 使用 UI 库的表格组件配置列定义、数据源 (`this.instances`)。
    2.  **实时更新**: 在 `updateInstanceInList` 方法中，确保 Angular 的变更检测能够捕获到数据的变化并刷新表格。对于大型列表，考虑使用 `trackBy` 函数优化性能。
    3.  **控制按钮**: 添加按钮并绑定到 `TestExecutionComponent` 的方法，这些方法再调用 `BackendCommsService` 中对应的方法 (如 `pauseTestsForBatch`, `stopTestsForBatch`)。
    4.  **进度显示**: 根据 `this.instances` 数组计算统计数据，并绑定到模板。
    5.  **通道详情**: 实现 `ChannelDetailComponent` 并设置路由，或者使用模态框/侧边栏显示通道详情。
*   **如何测试 (How to Test)**:
    *   **动态数据显示**: 模拟后端发送大量通道状态更新事件，验证表格数据是否实时、正确地刷新，并且没有性能问题。
    *   **交互控制**: 测试开始、暂停、停止等控制按钮的功能，并观察UI状态和后端日志。
    *   **排序与筛选**: 测试表格的排序和筛选功能。
    *   **导航/详情显示**: 测试点击通道后是否能正确显示详细信息。

### 步骤 5.4: 实现 `ChannelDetailComponent` 和 `ManualTestComponent`

*   **原因 (Reason)**:
    *   提供对单个通道的详细视图和手动干预能力。
*   **期望效果 (Expected Outcome)**:
    *   **`ChannelDetailComponent`**: 显示选定 `ChannelTestInstance` 的所有配置信息 (`ChannelPointDefinition`) 和所有子测试项 (`SubTestItem`) 的当前状态、结果、时间戳、详细读值/消息。
    *   **`ManualTestComponent`**: (可能与 `ChannelDetailComponent` 集成或独立)
        *   允许用户选择一个通道和该通道的一个具体子测试项 (如 AI高报、DO置ON)。
        *   调用 `BackendCommsService` 中的手动测试方法 (`executeManualSubTestCmd`, `readCurrentValueCmd`, `writeValueManualCmd`)。
        *   显示手动操作的结果和反馈。
    *   UI清晰，操作直观。
*   **实施描述 (Implementation Description)**:
    1.  **`ChannelDetailComponent`**: 接收 `instanceId` (可能还有 `batchId`)，从服务获取完整的 `ChannelTestInstance` 和 `ChannelPointDefinition` 数据。使用描述列表或卡片布局来展示信息。子测试项可以用一个表格或列表显示。
    2.  **`ManualTestComponent`**: 
        *   提供下拉框或搜索框让用户选择通道和子测试项。
        *   根据选择的子测试项，动态显示相应的输入字段 (如模拟输出值、DO开关状态)。
        *   按钮触发对 `BackendCommsService` 相应方法的调用。
        *   使用UI组件显示操作结果 (成功/失败消息，读取到的值)。
*   **如何测试 (How to Test)**:
    *   **数据显示准确性**: 验证 `ChannelDetailComponent` 显示的所有信息是否与后端数据一致。
    *   **手动测试流程**: 对不同类型的点 (AI, DI, AO, DO) 和不同的子测试项，完整测试手动执行、读值、写值流程，验证UI反馈和后端实际执行情况（通过mock的PLC服务日志）。

### 步骤 5.5: 实现应用设置、日志查看等辅助功能 (可选，根据优先级)

*   **原因 (Reason)**:
    *   增强应用的可用性和可维护性。
*   **期望效果 (Expected Outcome)**:
    *   **应用设置页面**: 允许用户配置一些参数 (如PLC连接参数 - 如果不是硬编码或通过配置文件，最大并发数等)。这些设置需要能被后端服务读取和使用 (可能通过Tauri command保存到配置文件，后端启动时加载)。
        *   **相关数据模型 (Rust & TypeScript):**
            *   **Rust (e.g., in `models/config.rs` or `models.rs`):**
                ```rust
                use serde::{Serialize, Deserialize};
                use std::collections::HashMap;

                #[derive(Debug, Clone, Serialize, Deserialize, Default)]
                pub struct AppSettings {
                    pub plc_address_primary: Option<String>,
                    pub plc_port_primary: Option<u16>,
                    pub plc_address_secondary: Option<String>, // For test rig PLC
                    pub plc_port_secondary: Option<u16>,      // For test rig PLC
                    pub max_concurrent_tests: Option<u32>,
                    pub default_operator_name: Option<String>,
                    pub default_product_model: Option<String>,
                    pub log_level: Option<String>, // e.g., "Info", "Debug", "Error"
                    #[serde(default)]
                    pub custom_settings: HashMap<String, String>,
                }
                ```
            *   **TypeScript (e.g., in `src/app/models/app-settings.model.ts`):**
                ```typescript
                export interface AppSettings {
                    plcAddressPrimary?: string | null;
                    plcPortPrimary?: number | null;
                    plcAddressSecondary?: string | null;
                    plcPortSecondary?: number | null;
                    maxConcurrentTests?: number | null;
                    defaultOperatorName?: string | null;
                    defaultProductModel?: string | null;
                    logLevel?: 'Info' | 'Debug' | 'Warn' | 'Error' | null;
                    customSettings?: { [key: string]: string };
                }
                ```
            *   **Tauri Commands:**
                *   `load_app_settings_cmd()` -> `Result<AppSettings, String>`
                *   `save_app_settings_cmd(settings: AppSettings)` -> `Result<(), String>`
    *   **日志查看界面**: (高级功能) 如果后端日志记录到特定文件，可以提供一个界面读取并显示日志内容，支持筛选和搜索。
    *   **国际化 (i18n)**: 如果需要支持多语言，集成 Angular 的 i18n方案 (如 `@ngx-translate`)，并为UI文本提供翻译。
*   **实施描述 (Implementation Description)**:
    1.  **设置页面**: 创建 `SettingsComponent`，使用表单组件 (如 `ReactiveFormsModule` in Angular) 绑定到 `AppSettings` 模型。
        *   组件加载时调用 `load_app_settings_cmd` 获取当前设置并填充表单。
        *   用户修改并保存时，调用 `save_app_settings_cmd` 将新设置传递给后端。
        *   后端服务 (可能是 `ConfigService` 或直接在 `main.rs` 的 command 中处理) 负责将 `AppSettings` 序列化为JSON并保存到用户应用配置目录下的文件 (使用 `tauri::api::path::app_config_dir()`)。启动时或需要时反序列化加载。
    2.  **日志查看**: 创建 `LogViewerComponent`。Tauri command读取日志文件内容 (注意文件大小和性能，可能需要分页或流式读取)，或通过步骤3.5中定义的 `LogMessageEventPayload` 事件实时收集日志条目，显示在前端。
    3.  **国际化**: 安装 `@ngx-translate/core` 和 `@ngx-translate/http-loader`。创建语言JSON文件 (`assets/i18n/en.json`, `assets/i18n/zh.json`)。在组件中使用 `TranslatePipe` 或 `TranslateService`。
*   **如何测试 (How to Test)**:
    *   **设置功能**: 修改设置，重启应用或触发相关逻辑，验证新设置是否生效。
    *   **日志查看**: 验证日志内容是否正确显示，筛选搜索是否有效。
    *   **国际化**: 切换语言，验证UI文本是否按预期翻译。

---

## Phase 6: 真实硬件联调、打包与部署准备

**目标：** 将系统与真实的PLC硬件进行集成测试，确保所有功能在实际环境中按预期工作。准备应用的最终打包和部署。

### 步骤 6.1: `IPlcCommunicationService` 真实实现

*   **原因 (Reason)**:
    *   Mock 实现无法验证与真实PLC的通信。
    *   需要针对目标PLC型号和通信协议（如Modbus TCP, S7, OPC UA等）实现具体的通信逻辑。
*   **期望效果 (Expected Outcome)**:
    *   根据项目选用的PLC型号和协议，选择合适的Rust crate (如 `tokio-modbus`, `s7-rs`, `opcua` 等) 或自行实现通信协议的必要部分。
    *   实现 `RealPlcCommunicationService` struct，完整实现 `IPlcCommunicationService` trait 中定义的所有方法 (connect, disconnect, read/write various types)。
    *   包含详细的错误处理和重连机制。
    *   能够在开发环境中连接到测试用PLC并成功读写数据。
*   **实施描述 (Implementation Description)**:
    1.  **选择/实现协议库**: 
        *   Modbus TCP: 使用 `tokio-modbus`。
        *   Siemens S7: 使用 `s7-rs` 或其他类似库。
        *   OPC UA: 使用 `opcua` crate。
        *   如果协议特殊或没有现成库，可能需要基于TCP/UDP套接字和协议文档自行实现。
    2.  **`RealPlcCommunicationService` 实现**: 
        *   `connect`: 建立与PLC的连接 (e.g., `tokio_modbus::client::tcp::connect_slave`).
        *   `disconnect`: 关闭连接。
        *   `read_bool/f32/u16`等: 调用相应库的读线圈/保持寄存器等功能，并处理数据类型转换。
            *   例如, `tokio-modbus`: `ctx.read_coils(addr, count).await?`, `ctx.read_holding_registers(addr, count).await?`。
            *   需要处理字节序 (endianness) 和数据类型转换 (e.g., 两个u16寄存器组合成f32)。
        *   `write_X`: 调用相应库的写功能。
        *   错误处理: 包装库返回的错误到 `AppError::PlcCommunicationError`，提供清晰的错误信息。
        *   重连机制: 实现简单的自动重连逻辑，例如在连接断开或读写失败后尝试几次重连。
    3.  **配置**: PLC的IP地址、端口、Slave ID等应可配置 (例如通过之前实现的设置功能或配置文件)。
*   **如何测试 (How to Test)**:
    *   **独立单元测试/集成测试 (连接真实PLC)**: 
        *   准备一个测试PLC程序，包含各种类型的测试点位（开关量、模拟量输入输出）。
        *   编写测试用例，直接调用 `RealPlcCommunicationService` 的方法：
            *   测试连接和断开。
            *   对已知地址和值的点位进行读操作，验证返回值是否与PLC中的实际值一致。
            *   对已知地址的点位进行写操作，然后在PLC监控软件中或通过后续读操作验证值是否被成功写入。
            *   测试不同数据类型（bool, u16, f32, etc.）。
            *   测试并发读写 (如果 `RealPlcCommunicationService` 设计为支持，例如内部使用 `Mutex` 保护客户端上下文)。
            *   测试PLC断开连接或网络故障时的错误报告和重连行为。

### 步骤 6.2: 替换 Mock 服务为真实实现并进行完整流程联调

*   **原因 (Reason)**:
    *   确保整个应用在真实硬件环境下能正常工作。
*   **期望效果 (Expected Outcome)**:
    *   在 `src-tauri/src/main.rs` 中，将 `MockPlcCommunicationService` 和 `MockPersistenceService` (如果之前用的是Mock) 替换为 `RealPlcCommunicationService` 和 `JsonFilePersistenceService` (或数据库实现)。
    *   在连接真实PLC和目标测试设备的环境中，运行完整的 FAT 测试流程：
        *   通过UI导入Excel点位表。
        *   配置批次信息。
        *   执行（模拟的或真实的）接线确认。
        *   启动自动测试。
        *   观察UI上测试进度、各通道状态的实时更新。
        *   执行部分手动测试项。
        *   验证测试结果是否与预期一致 (需要人工比对PLC状态和UI显示)。
        *   验证测试报告是否能正确生成和导出。
    *   所有功能按预期工作，数据准确，系统稳定。
*   **实施描述 (Implementation Description)**:
    1.  **修改 `main.rs`**: 更新服务实例化部分，使用真实的PLC服务和持久化服务。
        ```rust
        // src-tauri/src/main.rs
        // ...
        let plc_service = Arc::new(RealPlcCommunicationService::new(/* plc config */)); // 传入PLC配置
        let persistence_service = Arc::new(JsonFilePersistenceService::new(/* base_path */));
        // ...然后用这些实例创建其他服务...
        ```
    2.  **环境准备**: 
        *   连接好PLC、测试台架、被测设备。
        *   确保网络通畅，PLC程序已下载并运行。
    3.  **执行测试场景**: 
        *   **完整自动测试**: 导入一个包含各种类型点位的Excel表，运行完整测试流程。
        *   **手动干预测试**: 在自动测试过程中或完成后，进行手动测试操作。
        *   **异常处理测试**: 模拟PLC通信中断、设备故障等情况，观察系统反应和错误提示。
        *   **数据一致性检查**: 对比UI显示的测试结果、导出的报告与PLC的实际状态。
        *   **长时间运行测试**: (如果条件允许) 让系统长时间运行，检查是否有内存泄漏或性能下降。
*   **如何测试 (How to Test)**:
    *   **端到端场景通过性**: 如"实施描述"中所列的各项测试场景能够顺利完成，并且结果符合预期。
    *   **日志分析**: 仔细检查Rust后端日志和前端控制台日志，排查任何错误或异常。
    *   **人工观察与验证**: 测试工程师根据测试用例，比对系统行为和预期结果。

### 步骤 6.3: 应用图标、元数据和打包配置

*   **原因 (Reason)**:
    *   为应用提供专业的门面和正确的打包信息，以便生成可分发的安装包。
*   **期望效果 (Expected Outcome)**:
    *   为应用设计并准备不同尺寸的图标文件 (如 .ico, .png, .icns)。
    *   在 `tauri.conf.json` 中配置应用元数据：
        *   `package.productName`, `package.version`
        *   `tauri.bundle.identifier` (唯一包名，如 `com.mycompany.fattesst`)
        *   `tauri.bundle.icon` (指向图标文件列表)
        *   `tauri.bundle.publisher`, `tauri.bundle.copyright` 等。
    *   配置特定平台的打包选项 (如Windows的 `nsis` 或 `msi`，macOS的 `.app` 和 `.dmg`)。
*   **实施描述 (Implementation Description)**:
    1.  **创建图标**: 使用图像编辑工具创建符合各平台要求的图标文件，并放置在 `src-tauri/icons` 或约定的目录中。
        *   Windows: 通常需要一个 `.ico` 文件，包含多种尺寸 (e.g., 16x16, 32x32, 48x48, 256x256)。
        *   macOS: 需要一个 `.icns` 文件集。
        *   Linux: 通常使用 `.png`。
    2.  **修改 `tauri.conf.json`**: 
        ```json
        {
          "package": {
            "productName": "FAT Test Suite",
            "version": "1.0.0"
          },
          "tauri": {
            "bundle": {
              "active": true,
              "identifier": "com.example.fattest",
              "icon": [
                "icons/32x32.png",
                "icons/128x128.png",
                "icons/128x128@2x.png",
                "icons/icon.icns",
                "icons/icon.ico"
              ],
              "publisher": "My Company",
              "copyright": "Copyright © My Company 2023",
              // ... Windows specific (NSIS or WiX/MSI)
              "windows": {
                "certificateThumbprint": null, // For code signing
                "digestAlgorithm": "sha256",
                "timestampUrl": "",
                "nsis": {
                    "installerIcon": "icons/installer.ico",
                    "sidebarImage": "icons/sidebar.bmp", // Optional
                    "headerImage": "icons/header.bmp" // Optional
                }
              },
              // ... macOS specific
              "macOS": {
                "frameworks": [],
                "minimumSystemVersion": "10.13",
                "exceptionDomain": "",
                "signingIdentity": null, // For code signing
                "providerShortName": null,
                "entitlements": null
              }
            }
            // ...
          }
        }
        ```
    3.  查阅 Tauri 打包和签名的官方文档，了解各平台特定配置的详细信息。
*   **如何测试 (How to Test)**:
    *   **配置验证**: 仔细检查 `tauri.conf.json` 中的路径和值是否正确。
    *   后续通过实际打包来验证图标和元数据是否正确应用到安装包和已安装的应用上。

### 步骤 6.4: 构建生产版本并测试安装包

*   **原因 (Reason)**:
    *   生成最终的可分发安装包，并在干净的环境中测试其安装和运行情况。
*   **期望效果 (Expected Outcome)**:
    *   运行 `npm run tauri build` 成功生成目标平台的安装包 (如 `.msi` 或 `.exe` for Windows, `.dmg` for macOS, `.deb` or `.AppImage` for Linux)。
    *   在干净的虚拟机或物理机（未安装过开发环境）上成功安装应用程序。
    *   安装后的应用程序能够正常启动，图标、名称等元数据正确显示。
    *   应用的核心功能（如导入、连接PLC（如果测试环境允许）、显示数据）能够基本工作。
*   **实施描述 (Implementation Description)**:
    1.  **执行构建命令**: 在项目根目录运行 `npm run tauri build`。
    2.  **定位安装包**: 构建成功后，安装包通常位于 `src-tauri/target/release/bundle/` 目录下对应的平台文件夹中。
    3.  **测试环境准备**: 准备一个或多个干净的测试环境 (虚拟机是理想选择)，覆盖目标操作系统版本。
    4.  **安装测试**: 
        *   将安装包拷贝到测试环境。
        *   执行安装程序，注意安装过程中的提示、选项、许可协议（如果配置了）。
        *   验证安装路径、开始菜单/桌面快捷方式是否正确创建。
    5.  **运行测试**: 
        *   从快捷方式或安装目录启动应用。
        *   检查应用窗口标题、图标是否正确。
        *   执行基本的核心功能进行冒烟测试。
        *   检查应用是否能正确创建和访问其数据文件（如JSON持久化文件，日志文件）。
    6.  **卸载测试**: 测试应用的卸载过程是否干净，是否正确移除了所有文件和注册表项（如果适用）。
*   **如何测试 (How to Test)**:
    *   **构建成功**: `tauri build` 命令无错误完成。
    *   **安装/卸载成功**: 在目标平台上，安装和卸载过程符合预期。
    *   **应用运行正常**: 安装后的应用能够启动并执行核心功能，无明显崩溃或错误。
    *   **元数据正确**: 应用的名称、图标、版本号等在操作系统中正确显示。

### 步骤 6.5: 编写用户手册和部署文档 (可选)

*   **原因 (Reason)**:
    *   为最终用户和部署人员提供必要的指导。
*   **期望效果 (Expected Outcome)**:
    *   **用户手册**: 描述如何安装、配置和使用应用的主要功能，包含截图和操作步骤。
    *   **部署文档**: (如果应用有特殊的服务器端或环境依赖) 描述部署环境要求、配置步骤、故障排除指南。
*   **实施描述 (Implementation Description)**:
    1.  根据应用功能，编写用户操作流程。
    2.  截图并加以说明。
    3.  整理部署所需的系统要求、依赖项、配置文件说明等。
*   **如何测试 (How to Test)**:
    *   **文档审阅**: 由不熟悉项目的测试人员或同事按照文档进行操作，检查文档的清晰度、准确性和完整性。
    *   **实际操作验证**: 按照部署文档在测试环境中尝试部署，验证步骤可行性。

---
**项目完成！后续可能进入维护和迭代周期。**
