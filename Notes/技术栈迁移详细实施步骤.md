# 技术栈迁移详细实施步骤方案 (FAT_TEST 项目)

## 项目目录结构 (Project Directory Structure)

以下是基于 Rust + Angular + Tauri 技术栈的完整项目目录结构，涵盖了后端服务、前端UI和桌面应用打包的所有组件：

```
fat-test-desktop-app/                          # Tauri 项目根目录
├── README.md                                  # 项目总体说明文档
├── package.json                               # npm scripts for Tauri commands
├── node_modules/                              # Node.js 依赖 (Tauri CLI 等)
│
├── src-tauri/                                 # Rust 后端 + Tauri 集成
│   ├── Cargo.toml                            # Rust 依赖配置
│   ├── Cargo.lock                            # 锁定的依赖版本
│   ├── tauri.conf.json                       # Tauri 应用配置
│   ├── build.rs                              # 构建脚本
│   ├── icons/                                # 应用图标资源
│   │   ├── 32x32.png
│   │   ├── 128x128.png
│   │   ├── 128x128@2x.png
│   │   ├── icon.icns                         # macOS 图标
│   │   ├── icon.ico                          # Windows 图标
│   │   ├── installer.ico                     # 安装程序图标
│   │   └── Square***.png                     # Windows Store 图标
│   │
│   └── src/                                  # Rust 源代码
│       ├── main.rs                           # Tauri 应用入口点
│       ├── lib.rs                            # 库根模块 (可选)
│       │
│       ├── commands/                         # Tauri Commands (前端调用接口)
│       │   ├── mod.rs
│       │   ├── batch_management.rs           # 批次管理相关命令
│       │   ├── test_orchestration.rs         # 测试编排相关命令
│       │   ├── manual_test.rs                # 手动测试相关命令
│       │   ├── data_management.rs            # 数据管理相关命令
│       │   ├── channel_config.rs             # 通道配置相关命令
│       │   └── system_settings.rs            # 系统设置相关命令
│       │
│       ├── events/                           # Tauri Events (后端推送给前端)
│       │   ├── mod.rs
│       │   ├── channel_state_events.rs       # 通道状态变更事件
│       │   ├── batch_progress_events.rs      # 批次进度事件
│       │   ├── log_events.rs                 # 日志事件
│       │   └── system_events.rs              # 系统状态事件
│       │
│       ├── state/                            # Tauri 状态管理
│       │   ├── mod.rs
│       │   ├── app_state.rs                  # 应用全局状态
│       │   └── service_container.rs          # 服务容器/依赖注入
│       │
│       ├── models/                           # 数据模型层
│       │   ├── mod.rs
│       │   ├── enums.rs                      # 核心枚举定义
│       │   │   └── # OverallTestStatus, SubTestStatus, ModuleType, 
│       │   │       # PointDataType, SubTestItem, LogLevelEvent
│       │   ├── structs.rs                    # 核心结构体定义
│       │   │   └── # ChannelPointDefinition, ChannelTestInstance, 
│       │   │       # TestBatchInfo, RawTestOutcome, SubTestExecutionResult,
│       │   │       # AnalogReadingPoint
│       │   ├── command_payloads.rs           # Tauri Command 参数/响应模型
│       │   │   └── # ImportExcelAndPrepareBatchCmdArgs, StartTestsForBatchCmdArgs,
│       │   │       # ImportAndPrepareBatchResponse, BatchDetailsPayload,
│       │   │       # ExecuteManualSubTestCmdArgs, ReadChannelValueCmdArgs
│       │   ├── event_payloads.rs             # Tauri Event Payload 模型
│       │   │   └── # ChannelStateChangedEventPayload, BatchProgressEventPayload,
│       │   │       # LogMessageEventPayload
│       │   └── settings.rs                   # 应用设置数据模型
│       │       └── # AppSettings, PlcConnectionSettings, TestConfiguration
│       │
│       ├── services/                         # 业务服务层
│       │   ├── mod.rs
│       │   │
│       │   ├── application/                  # 应用层服务 (编排业务用例)
│       │   │   ├── mod.rs
│       │   │   ├── test_orchestration_service.rs  # 测试编排服务 (核心)
│       │   │   ├── data_management_service.rs     # 数据管理服务 (导入/导出)
│       │   │   ├── manual_test_service.rs         # 手动测试服务
│       │   │   ├── channel_config_service.rs      # 通道配置服务
│       │   │   └── notification_service.rs        # 通知/事件发布服务
│       │   │
│       │   ├── domain/                       # 领域服务层 (核心业务逻辑)
│       │   │   ├── mod.rs
│       │   │   ├── channel_state_manager.rs       # 通道状态管理器 (唯一状态修改点)
│       │   │   ├── test_execution_engine.rs       # 测试执行引擎 (并发控制)
│       │   │   ├── specific_test_executors/       # 特定测试步骤执行器
│       │   │   │   ├── mod.rs
│       │   │   │   ├── ai_test_executor.rs        # AI点测试执行器
│       │   │   │   ├── ao_test_executor.rs        # AO点测试执行器
│       │   │   │   ├── di_test_executor.rs        # DI点测试执行器
│       │   │   │   ├── do_test_executor.rs        # DO点测试执行器
│       │   │   │   ├── communication_test_executor.rs # 通信测试
│       │   │   │   └── generic_read_write_executor.rs # 通用读写执行器
│       │   │   ├── statistics_service.rs          # 统计服务
│       │   │   └── test_record_service.rs         # 测试记录服务
│       │   │
│       │   └── infrastructure/               # 基础设施层 (外部系统交互)
│       │       ├── mod.rs
│       │       ├── plc/                      # PLC 通信相关
│       │       │   ├── mod.rs
│       │       │   ├── plc_communication_service.rs  # PLC通信服务接口
│       │       │   ├── mock_plc_service.rs           # Mock PLC服务 (开发/测试)
│       │       │   ├── modbus_plc_service.rs         # Modbus TCP PLC服务
│       │       │   ├── s7_plc_service.rs             # Siemens S7 PLC服务
│       │       │   └── opcua_plc_service.rs          # OPC UA PLC服务
│       │       ├── persistence/              # 数据持久化相关
│       │       │   ├── mod.rs
│       │       │   ├── persistence_service.rs       # 持久化服务接口
│       │       │   ├── app_settings_service.rs      # 应用配置服务 (JSON文件)
│       │       │   ├── sqlite_persistence.rs        # SQLite数据库持久化
│       │       │   └── mock_persistence.rs          # Mock持久化服务
│       │       └── excel/                    # Excel 处理相关
│       │           ├── mod.rs
│       │           ├── excel_importer.rs            # Excel导入器
│       │           └── excel_exporter.rs            # Excel导出器
│       │
│       ├── utils/                            # 工具模块
│       │   ├── mod.rs
│       │   ├── error.rs                      # 错误类型定义 (AppError)
│       │   ├── logging.rs                    # 日志配置
│       │   ├── config.rs                     # 配置加载/管理
│       │   └── conversion.rs                 # 数据类型转换工具
│       │
│       └── tests/                            # 集成测试
│           ├── mod.rs
│           ├── command_tests.rs              # Tauri Command 测试
│           ├── service_integration_tests.rs  # 服务集成测试
│           └── mock_data.rs                  # 测试数据生成
│
├── fat-test-frontend/                        # Angular 前端应用
│   ├── README.md                             # 前端项目说明
│   ├── package.json                          # npm 依赖和脚本
│   ├── package-lock.json
│   ├── angular.json                          # Angular 项目配置
│   ├── tsconfig.json                         # TypeScript 配置
│   ├── tsconfig.app.json
│   ├── tsconfig.spec.json
│   ├── karma.conf.js                         # 测试配置
│   ├── .eslintrc.json                        # ESLint 配置
│   │
│   ├── src/                                  # Angular 源代码
│   │   ├── main.ts                           # Angular 应用启动入口
│   │   ├── index.html                        # HTML 入口
│   │   ├── styles.scss                       # 全局样式
│   │   ├── favicon.ico
│   │   │
│   │   ├── app/                              # Angular 应用根模块
│   │   │   ├── app.module.ts                 # 根模块
│   │   │   ├── app.component.ts              # 根组件
│   │   │   ├── app.component.html
│   │   │   ├── app.component.scss
│   │   │   ├── app.component.spec.ts
│   │   │   ├── app-routing.module.ts         # 路由配置
│   │   │   │
│   │   │   ├── models/                       # TypeScript 数据模型
│   │   │   │   ├── index.ts                  # 模型导出索引
│   │   │   │   ├── backend-models.ts         # 后端数据模型接口
│   │   │   │   │   └── # (TS interfaces for all Rust structs/enums)
│   │   │   │   │       # OverallTestStatus, SubTestStatus, ModuleType,
│   │   │   │   │       # ChannelPointDefinition, ChannelTestInstance,
│   │   │   │   │       # TestBatchInfo, RawTestOutcome, etc.
│   │   │   │   ├── command-models.ts         # Tauri Command 参数/响应接口
│   │   │   │   ├── event-models.ts           # Tauri Event Payload 接口
│   │   │   │   ├── ui-models.ts              # 前端特有的UI模型
│   │   │   │   └── form-models.ts            # 表单数据模型
│   │   │   │
│   │   │   ├── services/                     # Angular 服务层
│   │   │   │   ├── index.ts
│   │   │   │   ├── backend-comms.service.ts  # Tauri 通信封装服务
│   │   │   │   ├── test-orchestration-api.service.ts    # 测试编排API服务
│   │   │   │   ├── data-management-api.service.ts       # 数据管理API服务
│   │   │   │   ├── manual-test-api.service.ts           # 手动测试API服务
│   │   │   │   ├── channel-config-api.service.ts        # 通道配置API服务
│   │   │   │   ├── event-listener.service.ts            # Tauri事件监听服务
│   │   │   │   ├── ui-state.service.ts                  # UI状态管理服务
│   │   │   │   ├── notification.service.ts              # 通知/提示服务
│   │   │   │   └── settings.service.ts                  # 设置管理服务
│   │   │   │
│   │   │   ├── components/                   # Angular 组件
│   │   │   │   ├── shared/                   # 共享组件
│   │   │   │   │   ├── header/
│   │   │   │   │   │   ├── header.component.ts
│   │   │   │   │   │   ├── header.component.html
│   │   │   │   │   │   └── header.component.scss
│   │   │   │   │   ├── sidebar/
│   │   │   │   │   ├── loading-spinner/
│   │   │   │   │   ├── confirmation-dialog/
│   │   │   │   │   ├── status-indicator/      # 测试状态指示器
│   │   │   │   │   ├── progress-bar/          # 进度条组件
│   │   │   │   │   └── data-table/            # 通用数据表格
│   │   │   │   │
│   │   │   │   ├── batch-management/         # 批次管理页面
│   │   │   │   │   ├── batch-management.component.ts
│   │   │   │   │   ├── batch-management.component.html
│   │   │   │   │   ├── batch-management.component.scss
│   │   │   │   │   ├── batch-list/           # 批次列表子组件
│   │   │   │   │   ├── batch-create/         # 创建批次子组件
│   │   │   │   │   └── batch-details/        # 批次详情子组件
│   │   │   │   │
│   │   │   │   ├── data-import/              # 数据导入页面
│   │   │   │   │   ├── data-import.component.ts
│   │   │   │   │   ├── data-import.component.html
│   │   │   │   │   ├── data-import.component.scss
│   │   │   │   │   ├── excel-upload/         # Excel文件上传子组件
│   │   │   │   │   ├── point-preview/        # 点位预览子组件
│   │   │   │   │   └── import-progress/      # 导入进度子组件
│   │   │   │   │
│   │   │   │   ├── test-execution/           # 测试执行页面 (核心)
│   │   │   │   │   ├── test-execution.component.ts
│   │   │   │   │   ├── test-execution.component.html
│   │   │   │   │   ├── test-execution.component.scss
│   │   │   │   │   ├── channel-list/         # 通道列表子组件
│   │   │   │   │   ├── channel-detail/       # 通道详情子组件
│   │   │   │   │   ├── test-control-panel/   # 测试控制面板
│   │   │   │   │   ├── batch-progress/       # 批次进度显示
│   │   │   │   │   └── real-time-status/     # 实时状态监控
│   │   │   │   │
│   │   │   │   ├── manual-test/              # 手动测试页面
│   │   │   │   │   ├── manual-test.component.ts
│   │   │   │   │   ├── manual-test.component.html
│   │   │   │   │   ├── manual-test.component.scss
│   │   │   │   │   ├── manual-test-panel/    # 手动测试操作面板
│   │   │   │   │   ├── value-input/          # 数值输入子组件
│   │   │   │   │   ├── alarm-test/           # 报警测试子组件
│   │   │   │   │   └── reading-display/      # 读数显示子组件
│   │   │   │   │
│   │   │   │   ├── channel-configuration/    # 通道配置页面
│   │   │   │   │   ├── channel-configuration.component.ts
│   │   │   │   │   ├── channel-configuration.component.html
│   │   │   │   │   ├── channel-configuration.component.scss
│   │   │   │   │   ├── channel-editor/       # 通道编辑器
│   │   │   │   │   ├── module-config/        # 模块配置
│   │   │   │   │   └── plc-address-config/   # PLC地址配置
│   │   │   │   │
│   │   │   │   ├── reports/                  # 报告与导出页面
│   │   │   │   │   ├── reports.component.ts
│   │   │   │   │   ├── reports.component.html
│   │   │   │   │   ├── reports.component.scss
│   │   │   │   │   ├── test-results-report/  # 测试结果报告
│   │   │   │   │   ├── statistics-report/    # 统计报告
│   │   │   │   │   └── export-options/       # 导出选项
│   │   │   │   │
│   │   │   │   ├── system-settings/          # 系统设置页面
│   │   │   │   │   ├── system-settings.component.ts
│   │   │   │   │   ├── system-settings.component.html
│   │   │   │   │   ├── system-settings.component.scss
│   │   │   │   │   ├── plc-settings/         # PLC连接设置
│   │   │   │   │   ├── test-parameters/      # 测试参数设置
│   │   │   │   │   └── application-settings/ # 应用程序设置
│   │   │   │   │
│   │   │   │   └── logs/                     # 日志查看页面
│   │   │   │       ├── logs.component.ts
│   │   │   │       ├── logs.component.html
│   │   │   │       ├── logs.component.scss
│   │   │   │       ├── log-viewer/           # 日志查看器
│   │   │   │       └── log-filter/           # 日志筛选器
│   │   │   │
│   │   │   ├── pipes/                        # Angular 管道
│   │   │   │   ├── index.ts
│   │   │   │   ├── test-status.pipe.ts       # 测试状态显示管道
│   │   │   │   ├── duration.pipe.ts          # 时长格式化管道
│   │   │   │   ├── engineering-unit.pipe.ts  # 工程单位格式化管道
│   │   │   │   └── safe-html.pipe.ts         # 安全HTML管道
│   │   │   │
│   │   │   ├── directives/                   # Angular 指令
│   │   │   │   ├── index.ts
│   │   │   │   ├── auto-focus.directive.ts   # 自动聚焦指令
│   │   │   │   └── number-only.directive.ts  # 仅数字输入指令
│   │   │   │
│   │   │   ├── guards/                       # 路由守卫
│   │   │   │   ├── index.ts
│   │   │   │   ├── batch-loaded.guard.ts     # 批次加载完成守卫
│   │   │   │   └── unsaved-changes.guard.ts  # 未保存更改守卫
│   │   │   │
│   │   │   └── interceptors/                 # HTTP 拦截器
│   │   │       ├── index.ts
│   │   │       ├── error-handler.interceptor.ts  # 错误处理拦截器
│   │   │       └── loading.interceptor.ts         # 加载状态拦截器
│   │   │
│   │   ├── assets/                           # 静态资源
│   │   │   ├── images/                       # 图片资源
│   │   │   │   ├── logo.png
│   │   │   │   ├── icons/                    # UI图标
│   │   │   │   └── illustrations/            # 插画图片
│   │   │   ├── i18n/                         # 国际化文件
│   │   │   │   ├── en.json                   # 英文语言包
│   │   │   │   ├── zh-CN.json                # 中文语言包
│   │   │   │   └── zh-TW.json                # 繁体中文语言包
│   │   │   └── styles/                       # 样式文件
│   │   │       ├── _variables.scss           # SCSS变量
│   │   │       ├── _mixins.scss              # SCSS混合
│   │   │       ├── _themes.scss              # 主题样式
│   │   │       └── _utilities.scss           # 工具类样式
│   │   │
│   │   └── environments/                     # 环境配置
│   │       ├── environment.ts                # 开发环境配置
│   │       ├── environment.prod.ts           # 生产环境配置
│   │       └── environment.test.ts           # 测试环境配置
│   │
│   ├── e2e/                                  # 端到端测试
│   │   ├── protractor.conf.js
│   │   ├── tsconfig.json
│   │   └── src/
│   │       ├── app.e2e-spec.ts
│   │       └── app.po.ts
│   │
│   └── dist/                                 # Angular 构建输出 (由 ng build 生成)
│       └── fat-test-frontend/
│
├── docs/                                     # 项目文档
│   ├── README.md                             # 项目总体文档
│   ├── ARCHITECTURE.md                       # 架构设计文档
│   ├── API.md                                # API接口文档
│   ├── DEPLOYMENT.md                         # 部署说明文档
│   ├── USER_MANUAL.md                        # 用户使用手册
│   ├── DEVELOPMENT.md                        # 开发环境搭建指南
│   └── CHANGELOG.md                          # 版本更新日志
│
├── scripts/                                  # 构建和部署脚本
│   ├── build-all.sh                          # 完整构建脚本
│   ├── dev-setup.sh                          # 开发环境配置脚本
│   ├── test-all.sh                           # 运行所有测试脚本
│   └── release.sh                            # 发布脚本
│
├── tests/                                    # 端到端集成测试
│   ├── fixtures/                             # 测试数据和文件
│   │   ├── sample_excel_imports/             # 示例Excel导入文件
│   │   ├── mock_plc_data/                    # Mock PLC数据
│   │   └── test_configurations/              # 测试配置文件
│   ├── integration/                          # 集成测试用例
│   │   ├── full_workflow_tests.rs
│   │   ├── plc_communication_tests.rs
│   │   └── data_persistence_tests.rs
│   └── performance/                          # 性能测试
│       ├── load_tests.rs
│       └── stress_tests.rs
│
├── config/                                   # 配置文件目录
│   ├── app_settings.json                     # 应用默认设置
│   ├── plc_configurations/                   # PLC配置文件模板
│   │   ├── modbus_tcp_template.json
│   │   ├── s7_template.json
│   │   └── opcua_template.json
│   └── test_parameters/                      # 测试参数配置
│       ├── ai_test_params.json
│       ├── ao_test_params.json
│       ├── di_test_params.json
│       └── do_test_params.json
│
├── data/                                     # 运行时数据目录 (应用生成)
│   ├── batches/                              # 批次数据存储
│   ├── configurations/                       # 保存的配置
│   ├── logs/                                 # 应用日志文件
│   └── exports/                              # 导出的测试报告
│
├── .gitignore                                # Git 忽略文件配置
├── .github/                                  # GitHub Actions CI/CD 配置
│   └── workflows/
│       ├── build-and-test.yml               # 构建和测试工作流
│       └── release.yml                       # 发布工作流
│
└── target/                                   # Rust 构建输出 (由 cargo build 生成)
    ├── debug/                                # 调试版本构建
    ├── release/                              # 发布版本构建
    └── bundle/                               # Tauri 打包输出
        ├── appimage/                         # Linux AppImage
        ├── deb/                              # Debian 包
        ├── dmg/                              # macOS DMG
        ├── msi/                              # Windows MSI 安装包
        └── nsis/                             # Windows NSIS 安装包
```

## 目录结构说明

### 后端架构层次映射
- **应用层**: `src-tauri/src/services/application/` - 编排业务用例，对应架构图中的应用服务层
- **领域层**: `src-tauri/src/services/domain/` - 核心业务逻辑，包含状态管理和测试执行引擎
- **基础设施层**: `src-tauri/src/services/infrastructure/` - 外部系统交互，PLC通信和数据持久化
- **Tauri集成层**: `src-tauri/src/commands/` 和 `src-tauri/src/events/` - 前后端通信桥梁

### 前端组件架构映射
- **视图层**: `fat-test-frontend/src/app/components/` - Angular组件对应架构图中的View层
- **服务层**: `fat-test-frontend/src/app/services/` - 封装Tauri通信，对应ViewModel/Component Logic层
- **状态管理**: `fat-test-frontend/src/app/services/ui-state.service.ts` - 前端状态管理

### 关键设计原则体现
- **单一职责**: 每个服务和组件都有明确的职责范围
- **依赖倒置**: 通过接口抽象和依赖注入实现松耦合
- **分层架构**: 清晰的分层结构，上层依赖下层，下层不依赖上层
- **领域驱动**: 核心业务逻辑集中在domain层，状态管理集中在ChannelStateManager

---

## 0. 引言

本文档基于《技术栈迁移系统架构设计 (FAT_TEST 项目)》文档，旨在提供一个详细的、可操作的步骤化实施方案，指导 FAT_TEST 项目从现有 C# WPF 技术栈平稳、高效地迁移至 `Rust + Angular + Tauri` 新技术栈。

每个步骤将包含以下关键信息：
*   **原因 (Reason)**：为什么需要执行此步骤。
*   **期望效果 (Expected Outcome)**：此步骤完成后应达成的具体目标和产出物。
*   **实施描述 (Implementation Description)**：如何执行此步骤，涉及的关键技术点和任务。
*   **如何测试 (How to Test)**：验证此步骤是否成功完成的方法和标准。

**总体迁移策略：** 采用增量和迭代的方式，优先构建核心后端逻辑和数据流，然后逐步完善应用层服务和前端功能。尽早进行集成测试，确保各组件协同工作。

---

## Phase 1: 后端核心基础建设 - 领域模型与基础设施层（初步）

**目标：** 搭建Rust后端项目的基本骨架，定义核心领域模型，并初步实现基础设施服务的接口和Mock/基本实现，为上层逻辑奠定基础。

### (完成)步骤 1.1: 定义核心领域模型 (Rust Structs & Enums)

*   **原因 (Reason)**:
    *   领域模型是系统的核心，定义了业务实体的数据结构和基本行为约束。
    *   清晰、准确的领域模型是后续所有业务逻辑实现的基础。
    *   在项目早期就统一数据结构，可以减少后续因模型不一致导致的返工。
*   **期望效果 (Expected Outcome)**:
    *   在 Rust 项目中创建 `models.rs` (或类似模块)，包含所有核心枚举和结构体的定义。
    *   **核心枚举定义 (Rust Enums)** (与架构文档同步):
        *   `OverallTestStatus`: (NotTested, Skipped, WiringConfirmed, HardPointTesting, HardPointTestCompleted, ManualTesting, TestCompletedPassed, TestCompletedFailed, Retesting)
        *   `SubTestStatus`: (NotTested, Testing, Passed, Failed, NotApplicable, Skipped)
        *   `ModuleType`: (AI, AO, DI, DO, AINone, AONone, DINone, DONone)
        *   `PointDataType`: (Bool, Float, Int)
        *   `SubTestItem`: (HardPoint, TrendCheck, ReportCheck, LowLowAlarm, LowAlarm, HighAlarm, HighHighAlarm, AlarmValueSetting, MaintenanceFunction, StateDisplay) - 需 `Eq, Hash`
    *   **核心结构体定义 (Rust Structs)** (与架构文档同步):
        *   `ChannelPointDefinition`
        *   `ChannelTestInstance`
        *   `SubTestExecutionResult`
        *   `AnalogReadingPoint`
        *   `TestBatchInfo`
        *   `RawTestOutcome`
    *   所有结构体和枚举都应派生 `Debug`, `Clone`, `PartialEq` (按需)。为了IPC和持久化，还需派生 `Serialize`, `Deserialize` (使用 `serde`)。
    *   **重要**: 这些核心结构体（特别是 `ChannelPointDefinition`, `ChannelTestInstance`, `TestBatchInfo`）也将作为数据库的实体 (Entities)，因此在选择并集成 ORM (如 `SeaORM`, `Diesel`) 后，可能需要为它们添加 ORM 特定的 `derive` 宏 (例如 `#[derive(EntityModel)]` for `SeaORM` or `#[derive(Queryable, Insertable)]` for `Diesel`) 并定义它们与数据库表的关系。
    *   代码提交到版本控制。
*   **实施描述 (Implementation Description)**:
    1.  在 Rust 项目的 `src` 目录下创建 `models` 模块 (e.g., `src/models/mod.rs` 和 `src/models/enums.rs`, `src/models/structs.rs` 或直接在 `src/models.rs`)。
    2.  添加 `serde` 作为依赖到 `Cargo.toml` (`serde = { version = "1.0", features = ["derive"] }`)。
    3.  添加 `chrono` crate 处理日期时间 (`chrono = { version = "0.4", features = ["serde"] }`)。
    4.  添加 `uuid` crate (`uuid = { version = "1.0", features = ["v4", "serde"] }`) 用于生成唯一ID。
    5.  **枚举定义 (示例 `src/models/enums.rs` 或 `src/models.rs` - 与架构文档对齐):**
        ```rust
        use serde::{Serialize, Deserialize};

        // 与架构文档一致
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum OverallTestStatus {
            NotTested,
            Skipped,
            WiringConfirmed,
            HardPointTesting,
            HardPointTestCompleted,
            ManualTesting,
            TestCompletedPassed,
            TestCompletedFailed,
            Retesting,
        }
        impl Default for OverallTestStatus { fn default() -> Self { OverallTestStatus::NotTested } }

        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum SubTestStatus {
            NotTested,
            Testing,
            Passed,
            Failed,
            NotApplicable,
            Skipped,
        }
        impl Default for SubTestStatus { fn default() -> Self { SubTestStatus::NotTested } }

        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum ModuleType {
            AI,
            AO,
            DI,
            DO,
            AINone,
            AONone,
            DINone,
            DONone,
        }

        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum PointDataType {
            Bool,
            Float,
            Int,
        }
        
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum SubTestItem {
            HardPoint,
            TrendCheck,
            ReportCheck,
            LowLowAlarm,
            LowAlarm,
            HighAlarm,
            HighHighAlarm,
            AlarmValueSetting,
            MaintenanceFunction,
            StateDisplay,
        }
        ```
    6.  **结构体定义 (示例 `src/models/structs.rs` 或 `src/models.rs` - 与架构文档对齐):**
        ```rust
        use serde::{Serialize, Deserialize};
        use std::collections::HashMap;
        use chrono::{DateTime, Utc};
        use uuid::Uuid; // 用于生成ID
        use super::enums::*; // Assuming enums are in a sibling module or same file

        // Helper for default UUID
        fn default_uuid_string() -> String {
            Uuid::new_v4().to_string()
        }

        #[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
        pub struct ChannelPointDefinition {
            #[serde(default = "default_uuid_string")]
            pub id: String,
            pub tag: String,
            pub variable_name: String,
            pub variable_description: String,
            pub station_name: String,
            pub module_name: String,
            pub module_type: ModuleType,
            pub channel_tag_in_module: String,
            pub data_type: PointDataType,
            pub power_supply_type: String,
            pub wire_system: String,
            pub plc_absolute_address: Option<String>,
            pub plc_communication_address: String, // 核心
            pub range_lower_limit: Option<f32>,
            pub range_upper_limit: Option<f32>,
            pub engineering_unit: Option<String>,
            pub sll_set_value: Option<f32>,
            pub sll_set_point_address: Option<String>,
            pub sll_feedback_address: Option<String>,
            pub sl_set_value: Option<f32>,
            pub sl_set_point_address: Option<String>,
            pub sl_feedback_address: Option<String>,
            pub sh_set_value: Option<f32>,
            pub sh_set_point_address: Option<String>,
            pub sh_feedback_address: Option<String>,
            pub shh_set_value: Option<f32>,
            pub shh_set_point_address: Option<String>,
            pub shh_feedback_address: Option<String>,
            pub maintenance_value_set_point_address: Option<String>,
            pub maintenance_enable_switch_point_address: Option<String>,
            pub access_property: Option<String>,
            pub save_history: Option<bool>,
            pub power_failure_protection: Option<bool>,
            pub test_rig_plc_address: Option<String>,
        }

        #[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
        pub struct SubTestExecutionResult {
            pub status: SubTestStatus,
            pub details: Option<String>,
            pub expected_value: Option<String>,
            pub actual_value: Option<String>,
            #[serde(with = "chrono::serde::ts_seconds")] // 保持与架构文档一致，尽管具体格式可调整
            pub timestamp: DateTime<Utc>,
        }

        #[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
        pub struct AnalogReadingPoint {
            pub set_percentage: f32,
            pub set_value_eng: f32,
            pub expected_reading_raw: Option<f32>,
            pub actual_reading_raw: Option<f32>,
            pub actual_reading_eng: Option<f32>,
            pub status: SubTestStatus,
        }

        #[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
        pub struct ChannelTestInstance {
            #[serde(default = "default_uuid_string")]
            pub instance_id: String,
            pub definition_id: String,
            pub test_batch_id: String,
            pub overall_status: OverallTestStatus,
            pub current_step_details: Option<String>,
            pub error_message: Option<String>,
            pub start_time: Option<DateTime<Utc>>,
            pub last_updated_time: DateTime<Utc>,
            pub final_test_time: Option<DateTime<Utc>>,
            pub total_test_duration_ms: Option<i64>,
            pub sub_test_results: HashMap<SubTestItem, SubTestExecutionResult>,
            pub hardpoint_readings: Option<Vec<AnalogReadingPoint>>,
            pub manual_test_current_value_input: Option<String>,
            pub manual_test_current_value_output: Option<String>,
        }
        
        impl Default for ChannelTestInstance {
            fn default() -> Self {
                ChannelTestInstance {
                    instance_id: default_uuid_string(),
                    definition_id: String::new(),
                    test_batch_id: String::new(),
                    overall_status: OverallTestStatus::default(),
                    current_step_details: None,
                    error_message: None,
                    start_time: None,
                    last_updated_time: Utc::now(),
                    final_test_time: None,
                    total_test_duration_ms: None,
                    sub_test_results: HashMap::new(),
                    hardpoint_readings: None,
                    manual_test_current_value_input: None,
                    manual_test_current_value_output: None,
                }
            }
        }

        #[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
        pub struct TestBatchInfo {
            #[serde(default = "default_uuid_string")]
            pub batch_id: String,
            pub product_model: Option<String>,
            pub serial_number: Option<String>,
            pub customer_name: Option<String>,
            pub creation_time: DateTime<Utc>,
            pub status_summary: Option<String>,
            pub total_points: u32,
            pub tested_points: u32,
            pub passed_points: u32,
            pub failed_points: u32,
        }

        impl Default for TestBatchInfo {
            fn default() -> Self {
                TestBatchInfo {
                    batch_id: default_uuid_string(),
                    product_model: None,
                    serial_number: None,
                    customer_name: None,
                    creation_time: Utc::now(),
                    status_summary: None,
                    total_points: 0,
                    tested_points: 0,
                    passed_points: 0,
                    failed_points: 0,
                }
            }
        }

        #[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
        pub struct RawTestOutcome {
            pub channel_instance_id: String,
            pub sub_test_item: SubTestItem,
            pub success: bool,
            pub raw_value_read: Option<String>,
            pub eng_value_calculated: Option<String>,
            pub message: Option<String>,
            pub timestamp: DateTime<Utc>,
            pub analog_reading_point: Option<AnalogReadingPoint>, 
        }
        ```
*   **如何测试 (How to Test)**:
    *   **单元测试**:
        *   编写简单的单元测试来验证模型的创建、克隆。
        *   测试 `serde` 的序列化和反序列化功能，确保模型可以正确转换为JSON字符串并从JSON字符串恢复。
        *   例如：创建一个 `ChannelPointDefinition` 实例，序列化为JSON，再反序列化回来，比较前后对象是否一致。
    *   **代码审查**: 检查字段名、类型是否与架构文档一致，`derive` 是否完整。

### (完成)步骤 1.2: 搭建 Rust 项目基本结构、配置与统一错误处理

*   **原因 (Reason)**:
    *   一个良好组织的项目结构便于代码管理和模块化开发。
    *   统一的错误处理机制能提高代码的健壮性和可维护性，方便调试。
*   **期望效果 (Expected Outcome)**:
    *   创建 Rust 后端主项目 (e.g., `fat_test_backend`)。
    *   定义清晰的模块结构，如 `src/models`, `src/services`, `src/errors`, `src/config`, `src/main.rs`。
    *   实现架构文档中定义的 `AppError` 枚举，并集成 `thiserror` crate。确保 `AppError` 能够封装来自 ORM 和数据库操作的特定错误。
    *   建立初步的配置管理方式（如从环境变量或配置文件读取）。
*   **实施描述 (Implementation Description)**:
    1.  使用 `cargo new fat_test_backend --lib` (如果主要是库) 或 `cargo new fat_test_backend` 创建项目。如果使用Tauri，Tauri会创建项目结构。这里假设先独立构建后端核心。
    2.  在 `src` 目录下规划模块：
        *   `errors.rs`: 定义 `AppError`。
        *   `services/mod.rs`: 用于组织服务层trait和实现。
        *   `config.rs`: (可选) 用于加载配置。
    3.  在 `Cargo.toml` 中添加 `thiserror = "1.0"` 和 `serde = { version = "1.0", features = ["derive"] }`, `serde_json = "1.0"`。后续根据选择的ORM (如 `sea-orm`, `diesel`) 添加相应依赖。
    4.  在 `errors.rs` 中实现 `AppError` 枚举，使用 `#[derive(Error, Debug, Clone, Serialize)]`。包含如 `IoError`, `PersistenceError` (更名为 `DatabaseOrmError` 或类似以明确来源), `PersistenceFileError` (用于文件操作如JSON配置), `PlcCommunicationError` 等变体。
        ```rust
        // Example AppError structure in errors.rs
        use serde::Serialize;
        use thiserror::Error;

        #[derive(Error, Debug, Clone, Serialize)]
        pub enum AppError {
            #[error("IO Error: {0}")]
            IoError(String),

            #[error("Database/ORM Error: {0}")]
            DatabaseOrmError(String),

            #[error("File Persistence Error: {0}")]
            FilePersistenceError(String), // For JSON config files etc.

            #[error("PLC Communication Error: {0}")]
            PlcCommunicationError(String),

            #[error("Configuration Error: {0}")]
            ConfigurationError(String),

            #[error("Invalid Input: {0}")]
            InvalidInputError(String),

            #[error("Not Found: {0} not found")]
            NotFoundError(String),

            #[error("Test Execution Error: {0}")]
            TestExecutionError(String),

            #[error("State Transition Error: {0}")]
            StateTransitionError(String),

            #[error("Service Error: {0}")]
            InternalServiceError(String),
            
            #[error("Tauri API Error: {0}")]
            TauriError(String),
        }

        // Helper for converting other errors to AppError
        // #[cfg(feature = "sea-orm")] // Conditional compilation if SeaORM is optional
        // impl From<sea_orm::DbErr> for AppError {
        //     fn from(err: sea_orm::DbErr) -> Self {
        //         AppError::DatabaseOrmError(err.to_string())
        //     }
        // }

        // Example: Convert Diesel's result::Error to AppError
        // #[cfg(feature = "diesel")] // Conditional compilation
        // impl From<diesel::result::Error> for AppError {
        //     fn from(err: diesel::result::Error) -> Self {
        //         AppError::DatabaseOrmError(err.to_string())
        //     }
        // }

        impl From<std::io::Error> for AppError {
            fn from(err: std::io::Error) -> Self {
                AppError::IoError(err.to_string())
            }
        }
        impl From<serde_json::Error> for AppError {
            fn from(err: serde_json::Error) -> Self {
                AppError::InternalServiceError(format!("JSON serialization/deserialization error: {}", err))
            }
        }
        ```
    5.  实现其他必要的 `From` Trait 以便将外部库的错误（特别是选定的 ORM 库的错误类型）方便地转换为 `AppError`。
    6.  (可选) 初步设定日志库，如 `log` 和 `env_logger`。
*   **如何测试 (How to Test)**:
    *   **单元测试**:
        *   为 `AppError` 编写测试，验证错误类型的创建和 `to_string()` 输出。
        *   测试 `From` Trait 实现，确保外部错误能正确转换为 `AppError`。
    *   **编译通过**: 确保项目结构清晰，模块间引用正确，能够成功编译。

### (完成)步骤 1.3: 实现 `IPlcCommunicationService` 接口及 Mock/基本实现 (基础设施层)

*   **原因 (Reason)**:
    *   PLC 通信是系统核心功能之一，尽早定义接口和提供Mock实现可以解耦上层逻辑开发。
    *   Mock 实现允许在没有真实PLC硬件或完整驱动的情况下进行测试。
*   **期望效果 (Expected Outcome)**:
    *   在 `src/services/infrastructure/plc_communication.rs` (或类似路径) 中定义 `IPlcCommunicationService` trait，包含架构文档中描述的方法 (connect, disconnect, read_bool, write_f32, etc.)。
    *   提供一个 `MockPlcCommunicationService` 实现该 trait:
        *   `connect`/`disconnect`/`is_connected` 方法只记录日志并返回固定值。
        *   `read_X` 方法返回预设的默认值或根据输入地址返回特定 mock 数据。
        *   `write_X` 方法记录写入的值和地址，但不进行实际操作。
    *   此 Mock 服务应能满足后续 `SpecificTestStepExecutor` 初步开发和测试的需求。
*   **实施描述 (Implementation Description)**:
    1.  创建 `src/services/infrastructure/mod.rs` 和 `src/services/infrastructure/plc_communication.rs`。
    2.  在 `plc_communication.rs` 中定义 `IPlcCommunicationService` trait，使用 `#[async_trait::async_trait]`。定义 `PlcTag` 结构。
    3.  实现 `MockPlcCommunicationService` struct。
        *   可以在 `MockPlcCommunicationService` 中使用 `std::collections::HashMap` 来存储预设的读取值或记录写入的值，以便测试时验证。
        *   例如: `mock_reads: HashMap<String, serde_json::Value>`, `logged_writes: Vec<(String, serde_json::Value)>`。
    4.  所有 trait 方法返回 `Result<T, AppError>`。
*   **如何测试 (How to Test)**:
    *   **单元测试**:
        *   针对 `MockPlcCommunicationService` 编写单元测试。
        *   测试连接/断开状态模拟。
        *   测试读取操作：验证能否返回预设的 mock 数据。
        *   测试写入操作：验证写入的地址和值是否被正确记录在 `MockPlcCommunicationService` 内部状态中。
        *   测试批量读写操作。

### (完成)步骤 1.4: 实现 `IPersistenceService` 接口 (基础设施层)

*   **原因 (Reason)**:
    *   为上层服务提供统一的数据持久化抽象，解耦业务逻辑与具体的存储技术。
    *   支持后续在 SQLite (通过ORM) 和 JSON文件 (应用配置) 之间切换或共存。
*   **期望效果 (Expected Outcome)**:
    *   在 `src/services/infrastructure/persistence/persistence_service.rs` 中定义 `IPersistenceService` trait，包含架构文档中定义的所有方法。
    *   提供一个初步的 `MockPersistenceService` 实现，用于早期测试，所有方法可能只记录日志或返回固定数据。
    *   初步实现 `SqliteOrmPersistenceService` (骨架，具体ORM集成在后续步骤)。它的数据库操作方法 (如 `save_document`, `load_document`) 设计为通用接口，**供上层服务（如 `ITestRecordService`）调用。这些调用通常发生在特定的业务流程节点（例如，一个主要测试阶段完成、用户请求保存、测试批次结束时），而不是在微小的状态变化后立即进行。`ChannelTestInstance` 的更新主要在内存中进行，其持久化是由业务流程决定的按需操作。**
    *   应用配置管理将由专门的 `AppSettingsService` 处理，与通用的业务数据持久化分离。
*   **实施描述 (Implementation Description)**:
    1.  创建 `src/services/infrastructure/persistence/mod.rs` 和 `persistence_service.rs`。
    2.  定义 `IPersistenceService` trait (参考架构文档 4.3.2 节)。
        ```rust
        // src/services/infrastructure/persistence/persistence_service.rs
        use serde::{Serialize, de::DeserializeOwned};
        use crate::models::AppError; // 统一错误类型
        use std::path::PathBuf;
        use async_trait::async_trait;

        #[async_trait]
        pub trait IPersistenceService: Send + Sync {
            async fn save_document<T: Serialize + Send + Sync + 'static>(
                &self, collection_name: &str, document_id: &str, document: &T
            ) -> Result<(), AppError>;

            async fn load_document<T: DeserializeOwned + Send + Sync + 'static>(
                &self, collection_name: &str, document_id: &str
            ) -> Result<Option<T>, AppError>;
            
            async fn load_all_documents_in_collection<T: DeserializeOwned + Send + Sync + 'static>(
                &self, collection_name: &str
            ) -> Result<Vec<T>, AppError>;

            async fn delete_document(
                &self, collection_name: &str, document_id: &str
            ) -> Result<(), AppError>;

            async fn document_exists(
                &self, collection_name: &str, document_id: &str
            ) -> Result<bool, AppError>;
        }
        ```
    3.  创建 `MockPersistenceService` 结构体并实现 `IPersistenceService` trait。
        ```rust
        // In a new file: src/services/infrastructure/persistence/mock_persistence_service.rs
        use super::persistence_service::IPersistenceService;
        use crate::models::AppError;
        use async_trait::async_trait;
        use serde::{Serialize, de::DeserializeOwned};
        use std::collections::HashMap;
        use std::sync::Arc;
        use tokio::sync::Mutex;

        pub struct MockPersistenceService {
            // Mock in-memory store for documents
            documents: Arc<Mutex<HashMap<String, HashMap<String, String>>>>,
        }

        impl MockPersistenceService {
            pub fn new() -> Self {
                Self {
                    documents: Arc::new(Mutex::new(HashMap::new())),
                }
            }
        }

        #[async_trait]
        impl IPersistenceService for MockPersistenceService {
            async fn save_document<T: Serialize + Send + Sync + 'static>(
                &self, collection_name: &str, document_id: &str, document: &T
            ) -> Result<(), AppError> {
                println!("[MockPersistence] Saving doc '{}' in collection '{}'", document_id, collection_name);
                let mut collections = self.documents.lock().await;
                let collection = collections.entry(collection_name.to_string()).or_insert_with(HashMap::new);
                collection.insert(document_id.to_string(), serde_json::to_string(document).unwrap_or_default());
                Ok(())
            }

            async fn load_document<T: DeserializeOwned + Send + Sync + 'static>(
                &self, collection_name: &str, document_id: &str
            ) -> Result<Option<T>, AppError> {
                println!("[MockPersistence] Loading doc '{}' from collection '{}'", document_id, collection_name);
                let collections = self.documents.lock().await;
                if let Some(collection) = collections.get(collection_name) {
                    if let Some(doc_str) = collection.get(document_id) {
                        return Ok(serde_json::from_str(doc_str).ok());
                    }
                }
                Ok(None)
            }
            
            async fn load_all_documents_in_collection<T: DeserializeOwned + Send + Sync + 'static>(
                &self, collection_name: &str
            ) -> Result<Vec<T>, AppError> {
                println!("[MockPersistence] Loading all docs from collection '{}'", collection_name);
                let collections = self.documents.lock().await;
                let mut result_vec = Vec::new();
                if let Some(collection) = collections.get(collection_name) {
                    for doc_str in collection.values() {
                        if let Ok(doc) = serde_json::from_str(doc_str) {
                            result_vec.push(doc);
                        }
                    }
                }
                Ok(result_vec)
            }

            async fn delete_document(
                &self, collection_name: &str, document_id: &str
            ) -> Result<(), AppError> {
                println!("[MockPersistence] Deleting doc '{}' from collection '{}'", document_id, collection_name);
                 let mut collections = self.documents.lock().await;
                if let Some(collection) = collections.get_mut(collection_name) {
                    collection.remove(document_id);
                }
                Ok(())
            }

            async fn document_exists(
                &self, collection_name: &str, document_id: &str
            ) -> Result<bool, AppError> {
                 let collections = self.documents.lock().await;
                Ok(collections.get(collection_name).map_or(false, |c| c.contains_key(document_id)))
            }
        }
        ```
    4.  创建 `SqliteOrmPersistenceService` 结构体骨架。
        ```rust
        // In a new file: src/services/infrastructure/persistence/sqlite_orm_persistence_service.rs
        use super::persistence_service::IPersistenceService;
        use crate::models::AppError;
        use async_trait::async_trait;
        use serde::{Serialize, de::DeserializeOwned};
        // Placeholder for actual DB connection (e.g., from SeaORM or Diesel)
        // use sea_orm::DatabaseConnection; 

        pub struct SqliteOrmPersistenceService {
            // db_conn: DatabaseConnection, // Example: SeaORM connection pool
            db_path: String, // For now, just the path
        }

        impl SqliteOrmPersistenceService {
            pub async fn new(db_file_path: &str) -> Result<Self, AppError> {
                // TODO: Initialize DB connection here in a later step
                // For now, just store the path
                Ok(Self { db_path: db_file_path.to_string() })
            }
        }
        
        #[async_trait]
        impl IPersistenceService for SqliteOrmPersistenceService {
            async fn save_document<T: Serialize + Send + Sync + 'static>(
                &self, collection_name: &str, document_id: &str, document: &T
            ) -> Result<(), AppError> {
                // TODO: Implement using ORM
                println!("[SqliteOrmPersistence] (TODO) Saving doc '{}' in collection '{}' to DB '{}'", document_id, collection_name, self.db_path);
                Err(AppError::InternalServiceError("Not implemented".to_string()))
            }

            async fn load_document<T: DeserializeOwned + Send + Sync + 'static>(
                &self, collection_name: &str, document_id: &str
            ) -> Result<Option<T>, AppError> {
                // TODO: Implement using ORM
                println!("[SqliteOrmPersistence] (TODO) Loading doc '{}' from collection '{}' from DB '{}'", document_id, collection_name, self.db_path);
                Err(AppError::InternalServiceError("Not implemented".to_string()))
            }
            
            async fn load_all_documents_in_collection<T: DeserializeOwned + Send + Sync + 'static>(
                &self, collection_name: &str
            ) -> Result<Vec<T>, AppError> {
                // TODO: Implement using ORM
                println!("[SqliteOrmPersistence] (TODO) Loading all docs from collection '{}' from DB '{}'", collection_name, self.db_path);
                Err(AppError::InternalServiceError("Not implemented".to_string()))
            }

            async fn delete_document(
                &self, collection_name: &str, document_id: &str
            ) -> Result<(), AppError> {
                // TODO: Implement using ORM
                println!("[SqliteOrmPersistence] (TODO) Deleting doc '{}' from collection '{}' from DB '{}'", document_id, collection_name, self.db_path);
                Err(AppError::InternalServiceError("Not implemented".to_string()))
            }

            async fn document_exists(
                &self, collection_name: &str, document_id: &str
            ) -> Result<bool, AppError> {
                // TODO: Implement using ORM
                println!("[SqliteOrmPersistence] (TODO) Checking existence of doc '{}' in collection '{}' in DB '{}'", document_id, collection_name, self.db_path);
                Err(AppError::InternalServiceError("Not implemented".to_string()))
            }

            // App config methods will use file system, not ORM/DB directly for this service example
            async fn save_app_config<T: Serialize + Send + Sync>(
                &self, config_name: &str, config_data: &T
            ) -> Result<(), AppError> {
                // This specific implementation uses JSON files for app config
                // Real implementation would use tauri::api::path::app_config_dir()
                let path = format!("{}.json", config_name); 
                println!("[SqliteOrmPersistence/File] Saving config '{}' to file '{}'", config_name, path);
                let contents = serde_json::to_string_pretty(config_data)
                    .map_err(|e| AppError::PersistenceFileError(format!("Serialization error: {}", e)))?;
                tokio::fs::write(&path, contents).await
                    .map_err(|e| AppError::PersistenceFileError(format!("File write error: {}", e)))?;
                Ok(())
            }

            async fn load_app_config<T: DeserializeOwned + Send + Sync>(
                &self, config_name: &str
            ) -> Result<Option<T>, AppError> {
                let path = format!("{}.json", config_name);
                println!("[SqliteOrmPersistence/File] Loading config '{}' from file '{}'", config_name, path);
                match tokio::fs::read_to_string(&path).await {
                    Ok(contents) => {
                        let data: T = serde_json::from_str(&contents)
                            .map_err(|e| AppError::PersistenceFileError(format!("Deserialization error: {}", e)))?;
                        Ok(Some(data))
                    },
                    Err(e) if e.kind() == std::io::ErrorKind::NotFound => Ok(None),
                    Err(e) => Err(AppError::PersistenceFileError(format!("File read error: {}", e))),
                }
            }
        }
        ```
    5.  在 `src/services/infrastructure/persistence/mod.rs` 中导出。
*   **如何测试 (How to Test)**:
    *   单元测试 `MockPersistenceService` 的基本行为 (存取是否一致)。
    *   `SqliteOrmPersistenceService` 的数据库方法测试将在ORM集成后进行。
    *   编译通过，`clippy`无警告。

### 步骤 1.5: 实现 `IChannelStateManager` 接口及核心逻辑 (领域层)

*   **原因 (Reason)**:
    *   `ChannelStateManager` 是整个测试状态管理的核心，封装了最复杂的业务规则。
    *   它的正确实现是保证测试结果准确性和流程正确性的关键。
*   **期望效果 (Expected Outcome)**:
    *   在 `src/services/domain/channel_state_manager.rs` 中定义 `IChannelStateManager` trait。
    *   实现 `ChannelStateManager` struct，包含架构文档中描述的核心方法：
        *   `initialize_channel_test_instance`
        *   `apply_raw_outcome` (这是最核心的，内部包含复杂的 `EvaluateOverallStatus` 逻辑)
        *   `mark_as_skipped`
        *   `prepare_for_wiring_confirmation`
        *   `begin_hard_point_test`
        *   `begin_manual_sub_test`
        *   `reset_for_retest`
    *   此实现应严格遵守不进行I/O操作、不直接发布事件的原则。
    *   状态转换逻辑清晰，易于理解和修改。
*   **实施描述 (Implementation Description)**:
    1.  创建 `src/services/domain/mod.rs` 和 `src/services/domain/channel_state_manager.rs`。
    2.  定义 `IChannelStateManager` trait。
    3.  实现 `ChannelStateManager` struct。此服务通常是无状态的，或者只依赖配置信息，不持有可变运行时数据。
    4.  **`initialize_channel_test_instance`**:
        *   接收 `ChannelPointDefinition` 和 `batch_id`。
        *   创建一个新的 `ChannelTestInstance`。
        *   根据 `definition.module_type` 和其他配置（如报警点位是否配置），初始化 `instance.sub_test_results` 中各项 `SubTestItem` 的状态为 `NotTested` 或 `NotApplicable`。
        *   设置 `instance.overall_status = OverallTestStatus::NotTested`。
    5.  **`apply_raw_outcome`**:
        *   接收 `&mut ChannelTestInstance` 和 `RawTestOutcome`。
        *   根据 `outcome.sub_test_item` 更新 `instance.sub_test_results` 中对应条目的状态、时间戳、详细信息等。
        *   **调用内部私有方法 `evaluate_overall_status(&mut instance)`**。
    6.  **`evaluate_overall_status` (私有方法)**:
        *   这是状态机核心。遍历 `instance.sub_test_results`。
        *   根据各项子测试的状态，以及预定义的规则（例如：所有必需项 `Passed` 则整体 `TestCompletedPassed`；任何关键项 `Failed` 则整体 `TestCompletedFailed`；硬点测试完成但有手动项未测则可能是 `HardPointTestCompleted` 等），更新 `instance.overall_status`。
        *   更新 `instance.final_test_time`, `instance.total_test_duration_ms` (如果测试完成)。
        *   构建 `instance.error_message` (如果失败)。
    7.  实现其他方法 (`mark_as_skipped` 等)，它们通常会设置特定的子测试项状态或整体状态，并调用 `evaluate_overall_status`。
*   **如何测试 (How to Test)**:
    *   **单元测试 (非常重要且详细)**:
        *   **初始化测试**:
            *   针对不同 `ModuleType` (AI, DI, AO, DO等) 的 `ChannelPointDefinition`，测试 `initialize_channel_test_instance` 后，`ChannelTestInstance` 的 `overall_status` 和 `sub_test_results` 是否符合预期（哪些是 `NotTested`，哪些是 `NotApplicable`）。
        *   **状态转换测试 (apply_raw_outcome)**:
            *   为每个 `SubTestItem` 和不同的 `RawTestOutcome` (成功/失败) 构造测试场景。
            *   例如：
                *   初始化的AI点实例 -> 应用成功的 `HardPoint` outcome -> 验证 `sub_test_results[HardPoint].status` 为 `Passed` 及 `overall_status` 的变化。
                *   AI点实例，`HardPoint` 已 `Passed` -> 应用成功的 `LowAlarm` outcome -> 验证状态。
                *   AI点实例 -> 应用失败的 `HardPoint` outcome -> 验证 `sub_test_results[HardPoint].status` 为 `Failed` 及 `overall_status` 为 `TestCompletedFailed`。
            *   覆盖所有定义的 `SubTestItem`。
            *   测试组合场景：多个子测试成功后整体通过；一个关键子测试失败导致整体失败。
        *   **`mark_as_skipped` 测试**: 验证调用后 `overall_status` 为 `Skipped`。
        *   **`reset_for_retest` 测试**: 验证调用后状态是否恢复到适合重测的初始状态。
        *   **边界条件和错误条件**: 例如，传入无效的 `RawTestOutcome` (不匹配的 `instance_id` -- 虽然这里是传 `&mut instance`，但逻辑上要考虑)。

---

## Phase 2: 后端核心业务流程实现 - 测试执行与初步应用服务

**目标：** 实现核心的测试执行逻辑，包括 `SpecificTestStepExecutor` 和 `TestExecutionEngine`，并开始搭建部分应用层服务以串联流程，为后续与前端集成做准备。

### (完成)步骤 2.1: 实现 `ISpecificTestStepExecutor` 接口及若干具体执行器 (领域层)

*   **原因 (Reason)**:
    *   `SpecificTestStepExecutor` 是实际执行与PLC交互并获取原始测试结果的单元。
    *   实现具体的执行器是 `TestExecutionEngine` 能够工作的先决条件。
*   **期望效果 (Expected Outcome)**:
    *   在 `src/services/domain/test_executors/` 目录下创建模块。
    *   定义 `ISpecificTestStepExecutor` trait。
    *   至少实现以下几个关键的执行器 (以AI点为例，其他类型类似)：
        *   `AIHardPointPercentExecutor`: 执行AI点硬接线测试中某个百分比的设定与读取（如模拟输出25%值，读取AI反馈）。
        *   `AIAlarmTestExecutor`: 执行AI点某个报警项的测试（如设置高报触发条件，验证报警是否产生）。
        *   `DIStateReadExecutor`: 读取DI点的状态。
        *   `DOSetStateExecutor`: 设置DO点的状态并验证回读（如果硬件支持）。
    *   每个执行器应能接收 `ChannelTestInstance` (只读), `ChannelPointDefinition` (只读), 以及 `IPlcCommunicationService` 的实例 (测试台架和被测系统)。
    *   每个执行器执行完毕后返回一个 `RawTestOutcome` 对象，包含执行的 `SubTestItem`、成功与否、原始读值、消息等。
*   **实施描述 (Implementation Description)**:
    1.  创建 `src/services/domain/test_executors/mod.rs` 以及各个执行器的 `ai_hardpoint_executor.rs`, `ai_alarm_executor.rs` 等文件。
    2.  在 `mod.rs` 或一个共享文件中定义 `ISpecificTestStepExecutor` trait。
    3.  **`AIHardPointPercentExecutor` 实现**: (示例逻辑)
        *   构造函数可能接收目标百分比 (e.g., 0.25, 0.50)。
        *   `item_type()` 返回 `SubTestItem::HardPoint` (可能需要更细分的 `SubTestItem` 来区分百分比点，或者 `RawTestOutcome` 中包含额外信息)。
        *   `execute()` 方法:
            *   从 `ChannelPointDefinition` 获取量程 (`range_lower_limit`, `range_upper_limit`) 和测试台架输出地址 (`test_rig_plc_address`) 以及被测AI点读取地址 (`plc_communication_address`)。
            *   计算目标百分比对应的工程单位设定值和（可能的）原始设定值。
            *   调用 `plc_service_test_rig.write_f32(test_rig_plc_address, calculated_set_value_raw)`。
            *   等待一小段时间 (可配置) 以确保信号稳定。
            *   调用 `plc_service_target.read_f32(plc_communication_address)` 获取实际读值。
            *   将实际读值转换为工程单位。
            *   比较实际读值与期望读值 (考虑容差范围)。
            *   构造并返回 `RawTestOutcome`，包含 `success` 状态，设定的百分比，设定值，实际读值，原始读值等信息 (利用 `RawTestOutcome::analog_reading_point` 字段)。
    4.  **`AIAlarmTestExecutor` 实现**: (示例逻辑)
        *   构造函数接收要测试的报警类型 (e.g., `SubTestItem::HighAlarm`)。
        *   `item_type()` 返回对应的 `SubTestItem`。
        *   `execute()` 方法:
            *   从 `ChannelPointDefinition` 获取报警设定值写入地址 (e.g., `sh_set_point_address`)、报警状态反馈地址 (e.g., `sh_feedback_address`) 和报警设定值 (e.g., `sh_set_value`)。
            *   调用 `plc_service_target.write_f32(sh_set_point_address, alarm_trigger_value)` (写入一个能触发报警的值)。
            *   等待。
            *   调用 `plc_service_target.read_bool(sh_feedback_address)` 验证报警是否有效。
            *   (重要) 测试完毕后，可能需要将设定值恢复原状或设定一个安全值。
            *   构造并返回 `RawTestOutcome`。
    5.  对DI/DO等其他类型的执行器进行类似实现。
    6.  所有与PLC的交互都应通过传入的 `IPlcCommunicationService` 实例进行。
*   **如何测试 (How to Test)**:
    *   **单元测试 (对每个具体执行器)**:
        *   **Mocking `IPlcCommunicationService`**: 这是测试的关键。为 `MockPlcCommunicationService` 设置预期的读取返回值，并验证写入操作是否符合预期 (地址、值)。
        *   **成功场景**: 模拟PLC返回预期值，验证执行器是否返回 `success: true` 的 `RawTestOutcome`，且outcome中的数据正确。
        *   **失败场景**:
            *   模拟PLC返回意外值 (超出容差范围)，验证 `success: false` 及错误信息。
            *   模拟PLC通信错误 (e.g., `read_f32` 返回 `Err(AppError::PlcCommunicationError)`)，验证执行器是否能正确处理并向上传播错误 (或包装为特定的 `RawTestOutcome` 失败)。
        *   **边界条件**: 测试量程的0%, 100%点，报警的触发与解除等。

### (完成)步骤 2.2: 实现 `ITestExecutionEngine` 接口及并发控制逻辑 (领域层)

*   **原因 (Reason)**:
    *   `TestExecutionEngine` 负责管理和并发执行由多个 `SpecificTestStepExecutor` 构成的完整测试序列。
    *   其正确实现是保证测试高效、有序进行的关键。
*   **期望效果 (Expected Outcome)**:
    *   在 `src/services/domain/test_execution_engine.rs` 中定义 `ITestExecutionEngine` trait。
    *   实现 `TestExecutionEngine` struct。
    *   `submit_test_instance` 方法应能接收 `ChannelTestInstance` 和 `ChannelPointDefinition`，并根据其类型决定需要执行的 `SpecificTestStepExecutor` 序列。
    *   使用 `tokio::spawn` 来异步执行每个测试实例的测试序列。
    *   使用 `tokio::sync::Semaphore` 来控制最大并发测试实例数。
    *   每个执行的 `SpecificTestStepExecutor` 返回的 `RawTestOutcome` 通过 `outcome_sender` (MPSC channel) 发送出去。
    *   初步实现 `pause`, `resume`, `stop` 功能 (可能通过 `CancellationToken` 或 `Arc<Mutex<bool>>` 标志位，需要仔细设计)。
*   **实施描述 (Implementation Description)**:
    1.  创建 `src/services/domain/test_execution_engine.rs`。
    2.  定义 `ITestExecutionEngine` trait。
    3.  实现 `TestExecutionEngine` struct:
        *   包含字段: `max_concurrent_tests: Arc<Semaphore>`, `plc_service_test_rig: Arc<dyn IPlcCommunicationService>`, `plc_service_target: Arc<dyn IPlcCommunicationService>` (这些应在创建引擎时注入)。
        *   (可选) `active_tasks: Arc<Mutex<HashMap<String, CancellationToken>>>` 用于管理可取消的任务。
    4.  **`submit_test_instance` 实现**: (核心逻辑)
        *   获取一个信号量许可: `let permit = self.max_concurrent_tests.clone().acquire_owned().await.unwrap();`
        *   `tokio::spawn` 一个新的异步任务，此任务负责执行该 `instance` 的完整测试序列。在任务结束时，`permit` 会被自动释放。
        *   在spawn的异步块内：
            *   根据 `definition.module_type` 和预定义的测试策略，构建一个 `Vec<Arc<dyn ISpecificTestStepExecutor>>` 序列。
                *   例如，AI点可能包含：HardPoint 0%, 25%, 50%, 75%, 100%, LL Alarm, L Alarm, H Alarm, HH Alarm, Maintenance, Trend, Report。
                *   这个构建逻辑可以封装在一个私有辅助函数 `fn determine_test_steps(definition: &ChannelPointDefinition) -> Vec<Arc<dyn ISpecificTestStepExecutor>>` 中，该函数会实例化具体的执行器。
            *   按顺序（或特定逻辑）迭代执行 `steps` 中的每个 `executor`:
                *   `let outcome = executor.execute(&instance_clone, &definition_clone, self.plc_test_rig.clone(), self.plc_target.clone()).await;`
                *   通过 `outcome_sender.send(outcome).await` 发送结果。
                *   如果某个步骤失败且需要中止后续步骤 (e.g., 硬点测试基础部分失败)，则提前 `break`。
                *   处理暂停/停止信号 (检查 `CancellationToken` 或共享标志位)。
    5.  **并发控制**: `Semaphore` 在 `submit_test_instance` 中获取许可，在 `tokio::spawn` 的任务结束时自动释放。
    6.  **任务控制 (`pause`/`resume`/`stop`)**: 这部分比较复杂。
        *   **Stop**: 可以使用 `tokio-util::sync::CancellationToken`。每个spawn的任务持有一个 `child_token`，引擎持有 `parent_token`。停止时取消 `parent_token`。
        *   **Pause/Resume**: 可能需要更复杂的机制，如每个执行器在关键点检查一个共享的 `Arc<Mutex<PauseState>>`。或者使用 `tokio::sync::watch` channel 来广播暂停/继续信号。
        *   初步实现可以先侧重 `stop`。
*   **如何测试 (How to Test)**:
    *   **单元测试/集成测试**: (这部分更偏向集成测试，因为它协调多个组件)
        *   **Mock `ISpecificTestStepExecutor`**: 创建几个Mock执行器，它们可以模拟成功、失败、或长时间运行，并返回预设的 `RawTestOutcome`。
        *   **Mock `IPlcCommunicationService`**: 仍然需要，因为执行引擎会将PLC服务传递给执行器。
        *   **测试并发控制**: 提交N个任务（N > max_concurrent），验证同时活动的任务数不超过 `max_concurrent`。
        *   **测试结果传递**: 验证所有 `RawTestOutcome` 都通过 `outcome_sender` 正确发送出来，并且顺序基本符合预期 (对于同一实例内的步骤)。
        *   **测试错误处理**: 如果一个 `executor.execute` 返回 `Err`, 或者 `outcome_sender.send` 失败，引擎应如何处理（记录日志，可能中止该实例的后续步骤）。
        *   **测试 Stop 功能**: 提交多个任务，中途调用 `stop_instance_execution` (或全局停止)，验证正在运行和等待的任务是否能被取消，并且 `outcome_sender` 不再收到它们的结果。

### (完成)步骤 2.3: 实现 `ITestRecordService` 接口及基本实现 (领域层)

*   **原因 (Reason)**:
    *   测试记录的保存和查询是系统的基本需求。
    *   `TestOrchestrationService` 等上层服务会依赖此服务来管理测试数据。
*   **期望效果 (Expected Outcome)**:
    *   在 `src/services/domain/test_record_service.rs` 中定义 `ITestRecordService` trait (参考架构文档 4.2.5 节)。
    *   实现 `TestRecordService` struct，该 struct 依赖 `Arc<dyn IPersistenceService>`。
    *   `save_test_batch_info`, `get_test_batch_info`, `save_channel_test_instance`, `get_channel_test_instances_for_batch` 等核心方法能够通过调用 `IPersistenceService` 的方法，将数据（逻辑上）保存到/加载自持久化存储 (当前是Mock，后续是DB)。
    *   **此服务 (`TestRecordService`) 自身不决定何时持久化 `ChannelTestInstance` 的运行时状态。它提供持久化能力，但实际的调用时机由更上层的服务 (主要是 `TestOrchestrationService`) 根据业务流程中的特定节点（例如测试阶段完成、用户请求保存、批次结束等关键时间点）来决定。`ChannelTestInstance` 的状态主要在内存中实时更新和管理，此服务负责按需将这些内存中的状态快照进行持久化或加载。**
*   **实施描述 (Implementation Description)**:
    1.  创建 `src/services/domain/mod.rs` (如果尚不存在) 和 `test_record_service.rs`。
    2.  定义 `ITestRecordService` trait:
        ```rust
        // src/services/domain/test_record_service.rs
        use crate::models::{TestBatchInfo, ChannelTestInstance, AppError};
        use async_trait::async_trait;

        #[async_trait]
        pub trait ITestRecordService: Send + Sync {
            async fn save_test_batch_info(&self, batch_info: &TestBatchInfo) -> Result<(), AppError>;
            async fn get_test_batch_info(&self, batch_id: &str) -> Result<Option<TestBatchInfo>, AppError>;
            async fn get_all_test_batch_infos(&self) -> Result<Vec<TestBatchInfo>, AppError>;
            async fn delete_test_batch_info(&self, batch_id: &str) -> Result<(), AppError>;

            async fn save_channel_test_instance(&self, instance: &ChannelTestInstance) -> Result<(), AppError>;
            async fn save_channel_test_instances(&self, instances: &[ChannelTestInstance]) -> Result<(), AppError>;
            async fn get_channel_test_instances_for_batch(&self, batch_id: &str) -> Result<Vec<ChannelTestInstance>, AppError>;
            async fn get_channel_test_instance(&self, instance_id: &str) -> Result<Option<ChannelTestInstance>, AppError>;
        }
        ```
    3.  实现 `TestRecordService` struct:
        ```rust
        use crate::services::infrastructure::persistence::IPersistenceService;
        use std::sync::Arc;

        const BATCH_INFO_COLLECTION: &str = "test_batch_infos";
        const INSTANCE_COLLECTION_PREFIX: &str = "channel_instances_batch_"; // e.g., channel_instances_batch_XYZ

        pub struct TestRecordService {
            persistence: Arc<dyn IPersistenceService>,
        }

        impl TestRecordService {
            pub fn new(persistence: Arc<dyn IPersistenceService>) -> Self {
                Self { persistence }
            }

            fn get_instance_collection_name(batch_id: &str) -> String {
                format!("{}{}", INSTANCE_COLLECTION_PREFIX, batch_id)
            }
        }

        #[async_trait]
        impl ITestRecordService for TestRecordService {
            async fn save_test_batch_info(&self, batch_info: &TestBatchInfo) -> Result<(), AppError> {
                self.persistence.save_document(BATCH_INFO_COLLECTION, &batch_info.batch_id, batch_info).await
            }

            async fn get_test_batch_info(&self, batch_id: &str) -> Result<Option<TestBatchInfo>, AppError> {
                self.persistence.load_document(BATCH_INFO_COLLECTION, batch_id).await
            }

            async fn get_all_test_batch_infos(&self) -> Result<Vec<TestBatchInfo>, AppError> {
                self.persistence.load_all_documents_in_collection(BATCH_INFO_COLLECTION).await
            }
            
            async fn delete_test_batch_info(&self, batch_id: &str) -> Result<(), AppError> {
                // Also consider deleting associated instances or handling orphaned data
                self.persistence.delete_document(BATCH_INFO_COLLECTION, batch_id).await?;
                // Potentially loop and delete all from get_instance_collection_name(batch_id) if DB doesn't cascade
                Ok(())
            }

            async fn save_channel_test_instance(&self, instance: &ChannelTestInstance) -> Result<(), AppError> {
                let collection_name = Self::get_instance_collection_name(&instance.test_batch_id);
                self.persistence.save_document(&collection_name, &instance.instance_id, instance).await
            }
            
            async fn save_channel_test_instances(&self, instances: &[ChannelTestInstance]) -> Result<(), AppError> {
                if instances.is_empty() {
                    return Ok(());
                }
                // Assuming all instances belong to the same batch for this bulk save
                let batch_id = &instances[0].test_batch_id; 
                let collection_name = Self::get_instance_collection_name(batch_id);
                for instance in instances {
                    // Could be parallelized if persistence service supports it and order doesn't matter for individual saves
                    self.persistence.save_document(&collection_name, &instance.instance_id, instance).await?;
                }
                Ok(())
            }

            async fn get_channel_test_instances_for_batch(&self, batch_id: &str) -> Result<Vec<ChannelTestInstance>, AppError> {
                let collection_name = Self::get_instance_collection_name(batch_id);
                self.persistence.load_all_documents_in_collection(&collection_name).await
            }

            async fn get_channel_test_instance(&self, instance_id: &str) -> Result<Option<ChannelTestInstance>, AppError> {
                // This is tricky without knowing the batch_id. 
                // For a simple key-value store mock, this is hard.
                // A real DB could query across collections or have a global instance_id index.
                // For now, this might require iterating all batch instance collections if not found, which is inefficient.
                // Or, TestOrchestrationService should hold batch_id when calling this.
                // Let's assume for now this method might be less used or TestOrchestrationService provides batch_id context.
                println!("[TestRecordService] get_channel_test_instance by instance_id only is potentially inefficient with current mock.");
                // A simplified (and possibly incorrect for mock) approach: try to find it in *any* batch
                // This is illustrative and would need a proper DB query in a real system.
                let all_batches = self.get_all_test_batch_infos().await?;
                for batch in all_batches {
                    let collection_name = Self::get_instance_collection_name(&batch.batch_id);
                    if let Ok(Some(instance)) = self.persistence.load_document::<ChannelTestInstance>(&collection_name, instance_id).await {
                        return Ok(Some(instance));
                    }
                }
                Ok(None)
            }
        }

        ```
    4.  编写单元测试，注入 `MockPersistenceService`，验证 `TestRecordService` 是否正确调用了 `IPersistenceService` 的方法，并能处理基本的存取逻辑。
        *   测试 `save_test_batch_info` 后能否通过 `get_test_batch_info` 获取。
        *   测试 `save_channel_test_instance` 后能否通过 `get_channel_test_instances_for_batch` 和 `get_channel_test_instance` (考虑其局限性) 获取。
*   **如何测试 (How to Test)**:
    *   单元测试：
        *   `TestRecordService` 方法使用 `MockPersistenceService` 进行测试。
        *   验证 `save_X` 后，`get_X` 能返回正确数据。
        *   验证集合名称 (`collection_name`) 是否按预期生成和使用。
    *   编译通过，`clippy` 无警告。

### (完成)步骤 2.4: 实现 `IDataManagementService` 接口及初步Excel导入与配置管理逻辑 (应用层)

*   **原因 (Reason)**:
    *   数据导入是启动测试流程的第一步。通道配置的保存和加载也是核心功能。
    *   实现此服务可以初步打通"外部数据 -> 内部模型 -> 数据库"以及"数据库/配置文件 -> 内部模型"的路径。
*   **期望效果 (Expected Outcome)**:
    *   在 `src/services/application/data_management_service.rs` 中定义 `IDataManagementService` trait。
    *   实现 `DataManagementService` struct。
    *   `import_channel_definitions_from_excel` 方法能读取指定Excel文件 (使用如 `calamine` crate)，将行数据转换为 `ChannelPointDefinition` 列表。这些定义后续将由 `ChannelConfigurationService` 或 `TestOrchestrationService` 负责通过 `IPersistenceService` 存入数据库。
    *   实现 `save_channel_definitions` 和 `load_channel_definitions` (针对 `ChannelPointDefinition` 集合的配置管理)：
        *   `save_channel_definitions`: 将 `Vec<ChannelPointDefinition>` 通过 `IPersistenceService` (ORM层) 保存到数据库中，可能作为一个命名的配置集。
        *   `load_channel_definitions`: 从数据库中加载指定名称的 `ChannelPointDefinition` 配置集。
*   **实施描述 (Implementation Description)**:
    1.  创建 `src/services/application/mod.rs` 和 `src/services/application/data_management_service.rs`。
    2.  定义 `IDataManagementService` trait。
    3.  实现 `DataManagementService` struct，它可能依赖 `Arc<dyn IPersistenceService>` 和 `Arc<dyn IChannelStateManager>` (如果初始化逻辑部分放在这里或需要调用)。通常，应用服务不直接调用 `ChannelStateManager` 进行初始化，而是 `OrchestrationService` 在准备实例时调用。
    4.  **`import_channel_definitions_from_excel` 实现**: (核心)
        *   添加 `calamine = "0.22.0"` (或最新版) 到 `Cargo.toml`。
        *   方法接收 `file_path: PathBuf`。
        *   使用 `calamine::open_workbook_auto(file_path)` 打开Excel。
        *   选择合适的sheet，遍历行和单元格。
        *   将每行数据映射到 `ChannelPointDefinition` 的字段。注意数据类型转换和错误处理（如单元格为空、格式不正确）。
        *   为每个成功转换的 `ChannelPointDefinition` 生成一个唯一 `id` (e.g., `uuid::Uuid::new_v4().to_string()`)。
        *   返回 `Result<(Vec<ChannelPointDefinition>, Option<TestBatchInfo>), AppError>`。这些 `ChannelPointDefinition` 对象是临时的，等待被其他服务持久化。
    5.  **`save_channel_definitions(config_name: &str, definitions: &[ChannelPointDefinition])`**: 
        *   此方法可能需要先清除数据库中同名 `config_name` 的旧定义 (如果适用)。
        *   遍历 `definitions`，为每个 `definition` 调用 `persistence_service.save_document("channel_definitions_config", config_name_plus_def_id, definition)`。这里的 `collection_name` 和 `document_id` 设计需要仔细考虑如何将一组 `definitions` 与 `config_name` 关联并存储。
        *   或者，如果 `definitions` 整体作为一个文档存储 (例如，一个包含 `Vec<ChannelPointDefinition>` 的结构体)，则调用 `persistence_service.save_document("channel_definition_sets", config_name, &wrapper_struct)`。
    6.  **`load_channel_definitions(config_name: &str)`**: 
        *   根据 `save_channel_definitions` 的存储方式，从数据库中查询并重构 `Vec<ChannelPointDefinition>`。
*   **如何测试 (How to Test)**:
    *   **单元测试**: (针对Excel解析逻辑)
        *   准备几个小型的测试用Excel文件：
            *   包含有效数据的标准文件。
            *   包含部分空单元格的文件。
            *   包含错误数据类型的文件（如量程列填了文本）。
            *   不同模块类型 (AI, DI, AO, DO) 的行。
        *   测试 `import_channel_definitions_from_excel`:
            *   验证返回的 `Vec<ChannelPointDefinition>` 数量和内容是否与Excel文件匹配。
            *   验证字段映射是否正确 (e.g., Excel的"位号"列是否正确赋给了 `ChannelPointDefinition::tag`)。
            *   验证数据类型转换是否正确（字符串到 `Option<f32>`，字符串到 `ModuleType` enum）。
            *   验证错误处理：对于包含错误数据的Excel，服务应如何反应（跳过错误行并记录日志？返回 `Err`？）。
        *   测试配置保存/加载 (如果实现): 使用 `MockPersistenceService` 验证交互。

### (完成)步骤 2.5: 实现 `ITestOrchestrationService` 接口骨架及核心流程的初步串联 (应用层)

*   **原因 (Reason)**:
    *   `TestOrchestrationService` 是后端的核心协调者，负责将各个领域服务串联起来完成业务流程。
    *   早期搭建其骨架并实现一两个核心流程，有助于验证整体架构的连通性。
*   **期望效果 (Expected Outcome)**:
    *   在 `src/services/application/test_orchestration_service.rs` 定义 `ITestOrchestrationService` trait。
    *   实现 `TestOrchestrationService` struct，注入所有必要的依赖 (如 `IDataManagementService`, `ITestExecutionEngine`, `IChannelStateManager`, `ITestRecordService`, `IChannelConfigurationService` (如果使用)，以及 `tauri::AppHandle` 用于事件通知等)。
    *   **核心数据管理**: `TestOrchestrationService` 将负责在其内部维护当前活动的 `TestBatchInfo` 和相关的 `ChannelTestInstance` 列表。这些 `ChannelTestInstance` **主要在内存中管理** (例如使用 `Arc<Mutex<HashMap<BatchId, BatchRuntimeState>>>`，其中 `BatchRuntimeState` 包含 `TestBatchInfo` 和 `HashMap<InstanceId, ChannelTestInstance>`)，以支持快速的状态更新和读取。
    *   **`create_test_batch`**: 创建 `TestBatchInfo`，在内存中记录，并调用 `ITestRecordService.save_test_batch_info` 持久化批次本身的信息（但不持久化空的实例列表）。
    *   **`prepare_test_instances_for_batch`**: 根据提供的 `ChannelPointDefinition` 列表，调用 `IChannelStateManager.initialize_channel_test_instance` 创建 `ChannelTestInstance` 对象。这些新创建的实例**仅在内存中管理**，不在此阶段立即持久化到数据库。
    *   **`start_tests_for_batch` (核心流程)**: 
        *   获取指定批次的内存中的 `ChannelTestInstance` 列表。
        *   为该批次的测试执行创建一个 MPSC channel (`outcome_tx`, `outcome_rx`) 用于从 `TestExecutionEngine` 接收 `RawTestOutcome`。
        *   启动一个异步的 "Outcome Processing Task" 来消费 `outcome_rx`:
            *   对于每个从 `outcome_rx` 收到的 `RawTestOutcome`:
                *   从内存中获取对应 `ChannelTestInstance` 的可变引用。
                *   调用 `IChannelStateManager.apply_raw_outcome` 来更新该实例在其内存中的状态。
                *   **持久化决策点**: 根据 `TestOrchestrationService` 的内部逻辑（例如，某个 `ChannelTestInstance` 的 `overall_status` 达到了一个重要的阶段性终态如 `HardPointTestCompleted`, `TestCompletedPassed`, `TestCompletedFailed`，或者一个关键子测试如 `SubTestItem::HardPoint` 完成），判断当前是否为一个合适的持久化节点。如果确定是，则调用 `ITestRecordService.save_channel_test_instance` 将当前内存中该实例的快照保存到数据库。
                *   通过 `tauri::AppHandle` (或封装的 `INotificationService`) 发送 `ChannelStateChanged` 事件，携带从内存中获取的、已更新的实例数据。
        *   对于批次中的每个（准备好的）`ChannelTestInstance`，连同其对应的 `ChannelPointDefinition`，调用 `ITestExecutionEngine.submit_test_instance`，并将 `outcome_tx` 克隆一份传递给它。
    *   **其他操作如 `pause_tests_for_batch`, `resume_tests_for_batch`, `stop_tests_for_batch`, `retest_channel_instance`, `skip_channel_instance`**: 这些方法主要操作内存中 `ChannelTestInstance` 的状态。在执行这些操作后，特别是在达到明确的业务流程节点时（例如，用户请求"停止并保存进度"），`TestOrchestrationService` 会调用 `ITestRecordService` 来持久化受影响实例的当前状态。
    *   **`get_batch_status_and_instances`**: 此方法应主要从内存中聚合和返回 `TestBatchInfo` 和 `Vec<ChannelTestInstance>`，以确保前端总是获取到最新的实时状态。如果需要从数据库加载（例如，应用重启后恢复批次），则应有单独的逻辑处理。
*   **实施描述 (Implementation Description)**:
    1.  创建 `src/services/application/test_orchestration_service.rs`。
    2.  定义 `ITestOrchestrationService` trait。
    3.  实现 `TestOrchestrationService` struct。字段包括：
        *   `data_management_service: Arc<dyn IDataManagementService>`
        *   `test_execution_engine: Arc<dyn ITestExecutionEngine>`
        *   `channel_state_manager: Arc<dyn IChannelStateManager>`
        *   `test_record_service: Arc<dyn ITestRecordService>`
        *   (可选) `channel_config_service: Arc<dyn IChannelConfigurationService>`
        *   (可选) `active_batches: Arc<Mutex<HashMap<String, BatchRuntimeState>>>`，其中 `BatchRuntimeState` 包含 `TestBatchInfo` 和 `HashMap<String, ChannelTestInstance>` (实例ID -> 实例数据)。
        *   (可选) `app_handle: tauri::AppHandle` (如果需要发送Tauri事件)。
    4.  **`create_test_batch` 实现**: 创建 `TestBatchInfo`，（可选）存入 `active_batches` 和 `ITestRecordService`。
    5.  **`prepare_test_instances_for_batch` 实现**:
        *   (如果使用 `IChannelConfigurationService`) 根据 `definition_ids` 从 `channel_config_service` 加载 `ChannelPointDefinition`。
        *   (如果直接从导入获取) `definition_ids` 可能是 `ChannelPointDefinition` 本身。
        *   遍历 `definitions`，为每个调用 `channel_state_manager.initialize_channel_test_instance`。
        *   将初始化的 `ChannelTestInstance` 存入 `active_batches` (如果使用) 并返回。
    6.  **`start_tests_for_batch` 实现**: (核心)
        *   从 `active_batches` (或参数) 获取要测试的 `ChannelTestInstance` 及其对应的 `ChannelPointDefinition`。
        *   创建 `tokio::sync::mpsc::channel` (e.g., `(outcome_tx, mut outcome_rx)` )。
        *   `let batch_instances_clone = self.active_batches.clone();`
        *   `let state_manager_clone = self.channel_state_manager.clone();`
        *   `let record_service_clone = self.test_record_service.clone();`
        *   `tokio::spawn(async move { while let Some(outcome_result) = outcome_rx.recv().await { ... } });` // Outcome processing loop
            *   在循环内部：
                *   `if let Ok(raw_outcome) = outcome_result { ... }`
                *   `let mut batches = batch_instances_clone.lock().await;`
                *   `if let Some(batch_state) = batches.get_mut(batch_id_from_outcome_or_context) { ... }`
                *   `if let Some(instance_to_update) = batch_state.instances.get_mut(&raw_outcome.channel_instance_id) { ... }`
                *   `state_manager_clone.apply_raw_outcome(instance_to_update, raw_outcome).await.unwrap_or_else(|e| error!("Failed to apply outcome: {}", e));`
                *   `record_service_clone.save_channel_test_instance(instance_to_update).await.unwrap_or_else(|e| error!("Failed to save instance: {}", e));`
                *   (TODO: 发送Tauri事件 `ChannelStateChanged`)
        *   遍历要测试的 `(instance, definition)`:
            *   `self.test_execution_engine.submit_test_instance(instance.clone(), definition.clone(), outcome_tx.clone()).await...`
*   **如何测试 (How to Test)**:
    *   **集成测试**: (这是本阶段最重要的测试)
        *   **Mock所有依赖**: `MockDataManagementService`, `MockTestExecutionEngine`, `MockChannelStateManager`, `MockTestRecordService`。
        *   **`MockTestExecutionEngine` 的行为**: 当调用 `submit_test_instance` 时，它应能模拟发送一个或多个预设的 `RawTestOutcome` 到传入的 `outcome_sender`。
        *   **测试 `start_tests_for_batch` 流程**:
            1.  调用 `create_test_batch`。
            2.  调用 `prepare_test_instances_for_batch` (使用mock的 `ChannelPointDefinition`，`MockChannelStateManager` 返回预期的初始 `ChannelTestInstance`)。
            3.  调用 `start_tests_for_batch`。
            4.  验证 `MockTestExecutionEngine.submit_test_instance` 是否被正确调用。
            5.  验证 `TestOrchestrationService` 中的 outcome processing loop 是否能接收到 `MockTestExecutionEngine` 发送的 `RawTestOutcome`。
            6.  验证对于每个收到的 `RawTestOutcome`，`MockChannelStateManager.apply_raw_outcome` 是否被以正确的参数调用。
            7.  验证 `MockTestRecordService.save_channel_test_instance` 是否被调用。
        *   测试错误场景：如 `submit_test_instance` 失败，`apply_raw_outcome` 失败等。

---

## Phase 3: 后端服务完善与 Tauri 集成

**目标：** 完善所有后端服务的接口和主要功能实现，搭建Tauri应用，并通过Tauri Command将后端服务暴露给未来的前端，实现初步的前后端通信。

### (完成)步骤 3.1: 完善所有后端服务接口的其余方法实现

*   **原因 (Reason)**:
    *   在与前端集成之前，后端应具备相对完整的功能集，以支持核心业务流程的闭环。
*   **期望效果 (Expected Outcome)**:
    *   **`ITestOrchestrationService`**: 实现 `confirm_wiring_for_batch`, `pause/resume/stop_tests_for_batch`, `retest_channel_instance`, `skip_channel_instance`, `get_batch_status_and_instances`, `get_channel_instance_details` 等方法。
        *   **关键的持久化策略**：在实现这些方法时，严格遵循"内存优先，特定节点持久化"的原则。例如，`pause_tests_for_batch` 或 `stop_tests_for_batch` 可能会成为一个"保存点"，此时应调用 `ITestRecordService` 将当前内存中所有相关 `ChannelTestInstance` 的状态持久化。`retest_channel_instance` 在重置内存状态后，新的测试结果也应在合适的节点（如测试完成时）持久化。
        *   **新增/相关数据模型 (Rust, in `models.rs` or a new `payloads.rs`):**
            ```rust
            use crate::models::{TestBatchInfo, ChannelTestInstance, ChannelPointDefinition}; // Assuming models are in crate::models
            use serde::{Serialize, Deserialize};

            #[derive(Debug, Clone, Serialize, Deserialize)]
            pub struct BatchDetailsPayload {
                pub batch_info: TestBatchInfo,
                pub instances: Vec<ChannelTestInstance>,
            }

            #[derive(Debug, Clone, Serialize, Deserialize)]
            pub struct ChannelInstanceDetailsPayload {
                pub instance: ChannelTestInstance,
                pub definition: ChannelPointDefinition,
            }
            ```
    *   **`IDataManagementService`**: 完善 `export_test_results_to_excel` (可能使用 `rust_xlsxwriter` crate) 和其他数据管理功能。
    *   **`IManualTestService`**: 实现 `execute_manual_sub_test`, `read_current_value`, `write_value_manual`。
        *   **相关数据模型 (Rust):**
            *   `execute_manual_sub_test` 参数可能需要: `instance_id: String`, `sub_test_item: SubTestItem`, `params: Option<HashMap<String, serde_json::Value>>` (用于传递如手动设定的值)。
    *   **`IChannelConfigurationService`**: (如果需要) 实现完整的CRUD操作。
    *   **`IStatisticsService`**: 实现 `calculate_batch_statistics`。
    *   所有实现都应包含完整的错误处理和日志记录。
*   **实施描述 (Implementation Description)**:
    1.  **`ITestOrchestrationService` 方法实现**:
        *   `confirm_wiring_for_batch`: 遍历实例，调用 `IChannelStateManager.prepare_for_wiring_confirmation`。
        *   `pause/resume/stop`: 调用 `ITestExecutionEngine` 对应的方法，并管理 `active_batches` 中的状态。
        *   `retest_channel_instance`: 调用 `IChannelStateManager.reset_for_retest`，然后重新将实例提交给 `ITestExecutionEngine`。
        *   `skip_channel_instance`: 调用 `IChannelStateManager.mark_as_skipped`。
        *   Getter方法: 从 `active_batches` (或 `ITestRecordService`) 读取数据并返回。
    2.  **`IDataManagementService.export_test_results_to_excel`**: 使用 `rust_xlsxwriter` crate 创建和写入Excel。遍历 `ChannelTestInstance` 数据，将其格式化到工作表中。
    3.  **`IManualTestService` 方法实现**:
        *   `execute_manual_sub_test`: 获取 `ChannelTestInstance` 和 `ChannelPointDefinition`。创建对应的 `ISpecificTestStepExecutor`，调用其 `execute` 方法。获取 `RawTestOutcome`，然后调用 `IChannelStateManager.apply_raw_outcome`。返回 `RawTestOutcome`。
        *   `read_current_value`/`write_value_manual`: 可能需要特定的 `ISpecificTestStepExecutor` (如 `GenericReadExecutor`, `GenericWriteExecutor`) 或直接调用 `IPlcCommunicationService`。
    4.  **`IStatisticsService.calculate_batch_statistics`**: 遍历 `ChannelTestInstance` 列表，根据其 `overall_status` 统计总数、通过数、失败数等，并更新传入的 `TestBatchInfo`。
    5.  为所有新实现的方法编写单元测试和集成测试，重点测试服务间的交互和业务逻辑的正确性。
*   **如何测试 (How to Test)**:
    *   **单元测试**: 针对每个服务新增的方法，mock其依赖项，验证方法逻辑。
        *   例如，测试 `ITestOrchestrationService.retest_channel_instance` 时，验证 `MockChannelStateManager.reset_for_retest` 和 `MockTestExecutionEngine.submit_test_instance` 是否被正确调用。
        *   测试 `IDataManagementService.export_test_results_to_excel`，可以不实际写文件，而是验证传递给 `rust_xlsxwriter` mock 包装器的数据是否正确。
    *   **集成测试**: 扩展 Phase 2 的集成测试，覆盖更完整的业务流程，如"导入->接线->开始测试->部分失败->重测失败点->跳过某个点->导出结果"。

### (完成)步骤 3.2: 搭建 Tauri 应用骨架

*   **原因 (Reason)**:
    *   Tauri 是连接 Rust 后端和 Angular 前端的桥梁。
    *   尽早搭建Tauri应用，可以验证基本的项目配置和构建流程。
*   **期望效果 (Expected Outcome)**:
    *   使用 Tauri CLI 创建一个新的 Tauri 项目 (其中包含一个简单的 Rust 后端和一个Web前端的占位符)。
    *   能够成功构建并运行一个空白的 Tauri 应用窗口。
    *   Rust 后端核心逻辑 (在 Phase 1 & 2 开发的 services, models 等) 能够被Tauri主项目的 `main.rs` (或其模块) 引用和访问。
*   **实施描述 (Implementation Description)**:
    1.  确保已安装 Tauri 开发环境 (`Node.js`, `Rust`, `WebView2` (Windows), `webkit2gtk` (Linux), `Xcode Command Line Tools` (macOS))。
    2.  在项目根目录下 (与 `fat_test_backend` 平级或将其作为 `src-tauri` 的一部分) 执行 `npm create tauri-app@latest` (或 `yarn create tauri-app`, `pnpm create tauri-app`)。
    3.  按照提示选择项目名称 (e.g., `fat_test_desktop_app`)，选择前端模板 (可以选择 Vanilla JS 或一个简单的 HTML 页面作为初始占位，后续替换为 Angular)。
    4.  确保 `src-tauri/Cargo.toml` 包含了必要的依赖，如 `serde`, `serde_json`, `tokio`, `thiserror` 以及后续会用到的 ORM 和 PLC 通信库等。如果后端核心逻辑（如 `models`, `services`）是作为 `src-tauri` crate 的一部分直接在 `src-tauri/src/` 目录下组织，则不需要额外的 path dependency 来引用它们。`src-tauri/src/main.rs` (或 `lib.rs` 如果有) 将直接引用这些内部模块。
    5.  在 `src-tauri/src/main.rs` 中，尝试引入并实例化在 `src-tauri/src/services` 等模块中定义的后端服务 (此时服务实例可能还未通过Tauri state管理)。
    6.  运行 `npm run tauri dev` (或 `yarn tauri dev`)，确保能看到一个Tauri窗口。
*   **如何测试 (How to Test)**:
    *   **成功构建和运行**: `npm run tauri dev` 命令成功执行，没有编译错误，并弹出一个桌面窗口。
    *   **日志输出**: 在 `src-tauri/src/main.rs` 的 `setup` 钩子中尝试调用后端服务的一个简单方法（例如，一个返回版本号的mock方法），并打印日志，确认后端代码被执行。

### (完成)步骤 3.3: 在 Tauri `main.rs` 中设置应用状态，实例化并注入服务依赖

*   **原因 (Reason)**:
    *   Tauri `commands` 需要访问后端服务实例来执行业务逻辑。
    *   通过 Tauri 的状态管理机制，可以将服务实例安全地共享给所有 `command` 函数。
*   **期望效果 (Expected Outcome)**:
    *   定义 `AppState` 结构体，包含所有后端服务的实例 (通常是 `Arc<dyn ITrait>` 或 `Arc<Mutex<ConcreteService>>`)。
    *   在 `main` 函数中初始化所有服务，特别是 `IPersistenceService` 的实现应为 `SqliteOrmPersistenceService`（确保数据库连接和迁移已处理），并将它们存入 `AppState`。
    *   使用 `tauri::Builder::default().manage(app_state).invoke_handler(...)` 将状态化的服务提供给Tauri。
*   **实施描述 (Implementation Description)**:
    1.  在 `src/state/app_state.rs` (或类似位置) 定义 `AppState`。
        ```rust
        // Example in src/state/app_state.rs
        use std::sync::Arc;
        use crate::services::application::{
            ITestOrchestrationService, TestOrchestrationService,
            IDataManagementService, DataManagementService,
            // ... other application services
        };
        use crate::services::domain::{
            ITestExecutionEngine, TestExecutionEngine,
            IChannelStateManager, ChannelStateManager,
            ITestRecordService, TestRecordService,
            // ... other domain services
        };
        use crate::services::infrastructure::persistence::{
            IPersistenceService, SqliteOrmPersistenceService, // 主要的ORM实现
            MockPersistenceService, // 可能用于特定测试配置
        };
        use crate::services::infrastructure::plc::{
            IPlcCommunicationService, ModbusPlcService, // 示例PLC服务
            MockPlcCommunicationService,
        };

        pub struct AppState {
            pub persistence_service: Arc<dyn IPersistenceService>,
            pub test_record_service: Arc<dyn ITestRecordService>,
            pub data_management_service: Arc<dyn IDataManagementService>,
            // ... other service fields
        }

        impl AppState {
            pub async fn new() -> Self { // 改为异步以支持异步初始化，如数据库连接
                // 1. 初始化持久化服务 (ORM + SQLite)
                // 路径应从配置或Tauri API获取
                let db_path = "fat_test_app.sqlite"; // 示例数据库文件名
                let persistence_service = Arc::new(
                    SqliteOrmPersistenceService::new(db_path).await.expect("Failed to initialize DB")
                );

                // 2. 初始化依赖持久化服务的其他服务
                let test_record_service = Arc::new(TestRecordService::new(persistence_service.clone()));
                let data_management_service = Arc::new(DataManagementService::new(persistence_service.clone()));
                
                // ... 初始化其他服务，按依赖顺序

                Self {
                    persistence_service,
                    test_record_service,
                    data_management_service,
                    // ...
                }
            }
        }
        ```
    2.  在 `src/main.rs` 中，异步创建 `AppState` 实例并在 `tauri::Builder` 中 `manage` 它。
        ```rust
        // Example in src/main.rs
        // #[cfg_attr(not(debug_assertions), windows_subsystem = "windows")] // Release build: hide console

        mod models;
        mod services;
        mod state;
        mod commands;
        mod utils; // for AppError

        use state::app_state::AppState;

        #[tokio::main] // 如果AppState::new是异步的
        async fn main() {
            // 初始化日志等

            let app_state = AppState::new().await; // 异步创建

            tauri::Builder::default()
                .manage(app_state) // 注入 AppState
                .invoke_handler(tauri::generate_handler![
                    // 列出所有Tauri commands
                    // commands::core_commands::example_command,
                    // commands::data_management_commands::import_definitions_cmd,
                    // ...
                ])
                .setup(|app| {
                    // 可在此处获取 AppHandle 以便服务内部发送事件
                    // let handle = app.handle();
                    // app_state.notification_service.set_app_handle(handle); // 假设有这样的方法
                    Ok(())
                })
                .run(tauri::generate_context!())
                .expect("error while running tauri application");
        }
        ```
    3.  确保所有需要访问服务的 `command` 函数都通过 `tauri::State<AppState>` 参数获取服务实例。
*   **如何测试 (How to Test)**:
    *   **编写简单的Tauri Command**: 创建一个测试用的Tauri command，它接收 `tauri::State<AppState>`，并尝试调用 `AppState` 中某个服务的一个简单方法。从前端（或使用 `curl` 如果Tauri HTTP API暴露）调用此command，验证是否成功执行并返回预期结果。
    *   **日志确认**: 在command和服务方法中添加日志，确认服务实例被正确访问。

### 步骤 3.4: 实现核心业务流程的 Tauri Commands

*   **原因 (Reason)**:
    *   将后端核心业务流程通过Tauri Command暴露出来，是前端能够调用这些功能的前提。
*   **期望效果 (Expected Outcome)**:
    *   为架构文档和本实施计划中涉及的关键业务流程（导入、准备批次、开始测试、获取状态、手动测试等）创建对应的Tauri command函数。
    *   每个command函数应:
        *   接收来自前端的参数 (如文件路径、批次ID、实例ID、用户输入等)。
        *   通过 `tauri::State<AppState>` 获取相应的应用服务实例。
        *   调用服务实例的方法来执行业务逻辑。
        *   将服务方法返回的 `Result<T, AppError>` 转换为前端期望的 `Result<T_Serializable, String>`。
    *   在 `tauri::Builder::invoke_handler` 中注册所有这些commands。
    *   **相关数据模型 (Rust, for Command Payloads/Responses, in `commands.rs` or `payloads.rs`):**
        ```rust
        use crate::models::enums::SubTestItem;
        use crate::models::structs::{TestBatchInfo, ChannelTestInstance, RawTestOutcome};
        use crate::models::payloads::BatchDetailsPayload; // Assuming BatchDetailsPayload is defined elsewhere
        use serde::{Serialize, Deserialize};
        use std::collections::HashMap;

        #[derive(Debug, Clone, Serialize, Deserialize)]
        pub struct ImportExcelAndPrepareBatchCmdArgs {
            pub file_path_str: String, 
            pub product_model: Option<String>,
            pub serial_number: Option<String>,
        }
        // 返回值使用 BatchDetailsPayload or a specific response struct
        // Example of specific response struct:
        #[derive(Debug, Clone, Serialize, Deserialize)]
        pub struct ImportAndPrepareBatchResponse {
             pub batch_info: TestBatchInfo,
             pub instances: Vec<ChannelTestInstance>,
        }
        // Command: Result<ImportAndPrepareBatchResponse, String>

        #[derive(Debug, Clone, Serialize, Deserialize)]
        pub struct StartTestsForBatchCmdArgs {
            pub batch_id: String,
        }
        // Command: Result<(), String>

        #[derive(Debug, Clone, Serialize, Deserialize)]
        pub struct GetBatchStatusCmdArgs {
            pub batch_id: String,
        }
        // Command: Result<BatchDetailsPayload, String>

        #[derive(Debug, Clone, Serialize, Deserialize)]
        pub struct ExecuteManualSubTestCmdArgs {
            pub instance_id: String, 
            pub sub_test_item: SubTestItem,
            pub params: Option<HashMap<String, serde_json::Value>>
        }
        // Command: Result<RawTestOutcome, String>
        
        #[derive(Debug, Clone, Serialize, Deserialize)]
        pub struct ReadChannelValueCmdArgs { // For manual read
            pub instance_id: String,
            //pub definition_id: String, // Or pass enough context to find the address
            pub plc_address: String, // Specific address to read
            pub data_type: crate::models::enums::PointDataType, // Expected data type
        }
        // Command: Result<serde_json::Value, String>

        #[derive(Debug, Clone, Serialize, Deserialize)]
        pub struct WriteChannelValueCmdArgs { // For manual write
            pub instance_id: String, 
            //pub definition_id: String,
            pub plc_address: String, // Specific address to write
            pub data_type: crate::models::enums::PointDataType,
            pub value_to_write: serde_json::Value,
        }
        // Command: Result<(), String>
        ```
*   **实施描述 (Implementation Description)**:
    1.  创建一个 `src-tauri/src/commands.rs` (或多个) 文件来组织command函数。
    2.  **示例 Command (`import_excel_and_prepare_batch_cmd`)**:
        ```rust
        // src-tauri/src/commands.rs
        use crate::AppState;
        // Assuming command-specific arg/response structs are defined (e.g., in a sub-module or payloads.rs)
        use crate::models::payloads::{ImportExcelAndPrepareBatchCmdArgs, ImportAndPrepareBatchResponse, BatchDetailsPayload, /* other command args/responses */ }; 
        use crate::models::{TestBatchInfo, ChannelTestInstance, ChannelPointDefinition}; // Core models from within the crate
        use crate::utils::error::AppError; // Assuming AppError is in utils::error module
        use std::path::PathBuf;

        #[tauri::command]
        pub async fn import_excel_and_prepare_batch_cmd(
            args: ImportExcelAndPrepareBatchCmdArgs, 
            state: tauri::State<'_, AppState>
        ) -> Result<ImportAndPrepareBatchResponse, String> { // Using specific response struct
            let file_path = PathBuf::from(args.file_path_str);
            
            let (definitions, extracted_batch_info) = state.data_management_service
                .import_channel_definitions_from_excel(file_path).await
                .map_err(|e| e.to_string())?;

            let batch_to_create = extracted_batch_info.unwrap_or_else(|| TestBatchInfo {
                batch_id: uuid::Uuid::new_v4().to_string(),
                product_model: args.product_model,
                serial_number: args.serial_number,
                ..Default::default()
            });

            let test_batch_info = state.test_orchestration_service
                .create_test_batch(batch_to_create.product_model, batch_to_create.serial_number).await
                .map_err(|e| e.to_string())?;

            let definition_ids: Vec<String> = definitions.iter().map(|d| d.id.clone()).collect();
            // Assuming prepare_test_instances_for_batch is modified or a new method prepares based on full definitions
            let instances = state.test_orchestration_service
                .prepare_test_instances_for_batch_from_defs(&test_batch_info.batch_id, definitions).await // Hypothetical method
                .map_err(|e| e.to_string())?;
            
            Ok(ImportAndPrepareBatchResponse { batch_info: test_batch_info, instances })
        }
        
        // Implement other commands similarly using their respective Arg and Response structs
        #[tauri::command]
        pub async fn start_tests_for_batch_cmd(
            args: StartTestsForBatchCmdArgs,
            state: tauri::State<'_, AppState>
        ) -> Result<(), String> {
            state.test_orchestration_service.start_tests_for_batch(&args.batch_id).await.map_err(|e| e.to_string())
        }

        #[tauri::command]
        pub async fn get_batch_status_cmd(
            args: GetBatchStatusCmdArgs,
            state: tauri::State<'_, AppState>
        ) -> Result<BatchDetailsPayload, String> { // Using BatchDetailsPayload directly
            state.test_orchestration_service.get_batch_status_and_instances(&args.batch_id).await.map_err(|e| e.to_string())
        }

        // ... other commands: execute_manual_sub_test_cmd, etc.
        ```
    3.  实现其他核心流程的Tauri Commands，如 `execute_manual_sub_test_cmd` 等，它们分别调用 `ITestOrchestrationService` 和 `IManualTestService` 的方法。
    4.  在 `src-tauri/src/main.rs` 中注册这些commands:
        ` .invoke_handler(tauri::generate_handler![import_excel_and_prepare_batch_cmd, start_tests_for_batch_cmd, get_batch_status_cmd, /* more commands */])`
*   **如何测试 (How to Test)**:
    *   **Tauri DevTools + 前端占位符**: (如果前端还是简单页面)
        *   在Tauri应用的Webview中打开开发者工具。
        *   在控制台使用 `window.__TAURI__.invoke('command_name', { param1: value1 })` 来手动调用Tauri commands。
        *   检查控制台输出的 `Promise` 解析结果是否符合预期（成功时的数据，失败时的错误字符串）。
        *   检查后端Rust控制台的日志输出，确认服务方法被调用，逻辑按预期执行。
    *   **自动化API测试工具 (如果可能)**: 如果Tauri的HTTP Server被启用（默认不用于IPC），可以使用Postman或类似工具测试。但通常IPC测试更依赖前端交互或特定测试脚本。
    *   **端到端流程模拟**: 通过手动调用一系列Tauri commands来模拟一个完整的业务流程，例如：
        1.  `import_excel_and_prepare_batch_cmd` (使用一个测试Excel文件)。
        2.  `confirm_wiring_cmd` (使用上一步返回的 `batch_id`)。
        3.  `start_tests_for_batch_cmd`。
        4.  多次调用 `get_batch_status_cmd` 观察状态变化 (此时需要 `MockTestExecutionEngine` 模拟发送 `RawTestOutcome` 给 `TestOrchestrationService` 的内部循环，这个循环再通过 `MockChannelStateManager` 更新状态)。
        *   这一步的测试会比较复杂，因为它依赖于Phase 2中 `TestOrchestrationService` 内部事件循环和状态更新的正确性，以及所有Mock服务的协同工作。

### (完成)步骤 3.5: 实现后端到前端的事件通知机制 (Tauri Events)

*   **原因 (Reason)**:
    *   许多操作（如测试进度、单点状态更新）需要从后端实时通知前端，而不是前端轮询。
*   **期望效果 (Expected Outcome)**:
    *   在 `TestOrchestrationService` (或其他需要发事件的服务) 中，当关键状态变化时（如 `ChannelTestInstance` 状态更新，批次进度更新），能够通过 `tauri::AppHandle.emit_all` 发送事件给前端。
    *   定义清晰的事件名称 (e.g., `"channel_state_changed"`, `"batch_progress_update"`, `"log_message_event"`) 和对应的Payload结构体 (需 `Serialize`)。
    *   **事件Payload定义 (Rust, in `models/payloads.rs` or a dedicated `events.rs`):**
        ```rust
        use crate::models::structs::{ChannelTestInstance, TestBatchInfo}; // Or specific fields from them
        use crate::models::enums::OverallTestStatus;
        use serde::{Serialize, Deserialize};
        use chrono::{DateTime, Utc};

        #[derive(Debug, Clone, Serialize, Deserialize)]
        pub struct ChannelStateChangedEventPayload {
            pub batch_id: String,
            pub instance_id: String,
            // 可以只发送更新后的实例，或者更细粒度的变更信息
            pub updated_instance: ChannelTestInstance, 
        }

        #[derive(Debug, Clone, Serialize, Deserialize)]
        pub struct BatchProgressEventPayload {
            pub batch_id: String,
            pub tested_points: u32,
            pub total_points: u32,
            pub passed_points: u32,
            pub failed_points: u32,
            pub skipped_points: u32,
            pub overall_batch_status: OverallTestStatus,
            pub status_summary: Option<String>, // Optional: A human-readable summary string
        }

        #[derive(Debug, Clone, Serialize, Deserialize)]
        pub enum LogLevelEvent {
            Info,
            Warn,
            Error,
            Debug,
        }

        #[derive(Debug, Clone, Serialize, Deserialize)]
        pub struct LogMessageEventPayload {
            pub timestamp: DateTime<Utc>,
            pub level: LogLevelEvent,
            pub message: String,
            pub module_path: Option<String>, // e.g., "crate::services::application::test_orchestration_service"
        }
        ```
    *   前端 (即使是占位符页面) 能够通过 `tauri-apps/api/event.listen` 接收到这些事件并打印其Payload。
*   **实施描述 (Implementation Description)**:
    1.  确保 `TestOrchestrationService` (或其他发事件的服务) 能够访问 `tauri::AppHandle`。
        *   可以在 `main` 函数中 `tauri::Builder::default().setup(|app| { ... })` 钩子中获取 `app.handle()`，并将其传递/设置到服务实例中（需要服务设计为可接收 `AppHandle`，可能通过 `Option<AppHandle>` 字段和初始化方法）。
    2.  在 `TestOrchestrationService` 中处理 `RawTestOutcome` 的循环内部，当 `ChannelTestInstance` 状态被 `ChannelStateManager` 更新后，或批次统计更新后:
        ```rust
        // In TestOrchestrationService, after instance state is updated
        // Assuming payloads are defined in e.g. crate::models::events::* 
        use crate::models::events::{ChannelStateChangedEventPayload, BatchProgressEventPayload};

        if let Some(handle) = &self.app_handle { // Assuming self.app_handle: Option<tauri::AppHandle>
            let event_payload = ChannelStateChangedEventPayload {
                batch_id: updated_instance.batch_id.clone(),
                instance_id: updated_instance.instance_id.clone(),
                updated_instance: updated_instance.clone(),
            };
            if let Err(e) = handle.emit_all("fat://channel_state_changed", event_payload) { // Using custom event name
                error!("Failed to emit channel_state_changed event: {}", e);
            }

            // After batch statistics are updated (e.g., in TestBatchInfo)
            let batch_progress_payload = BatchProgressEventPayload {
                batch_id: current_batch_info.batch_id.clone(),
                tested_points: current_batch_info.tested_points,
                total_points: current_batch_info.total_points,
                passed_points: current_batch_info.passed_points,
                failed_points: current_batch_info.failed_points,
                skipped_points: current_batch_info.skipped_points,
                overall_batch_status: current_batch_info.overall_status, // Assuming TestBatchInfo now has this
                status_summary: current_batch_info.status_summary.clone(),
            };
            if let Err(e) = handle.emit_all("fat://batch_progress_update", batch_progress_payload) {
                error!("Failed to emit batch_progress_update event: {}", e);
            }
        }
        ```
    3.  (如果实现全局日志推送) 在日志系统的实现中，当捕获到日志条目时，构建 `LogMessageEventPayload` 并通过 `AppHandle` 发送 `"fat://log_message"` 事件。
    4.  在前端的简单JS中 (Tauri模板自带的 `main.js` 或一个简单HTML的 `<script>` 标签内):
        ```javascript
        // Using global tauri functions if in simple HTML/JS page
        const { listen } = window.__TAURI__.event;

        async function setupEventListeners() {
            await listen('fat://channel_state_changed', (event) => {
                console.log('Event: channel_state_changed', event.payload);
            });
            await listen('fat://batch_progress_update', (event) => {
                console.log('Event: batch_progress_update', event.payload);
            });
            await listen('fat://log_message', (event) => {
                console.log('Log [' + event.payload.level + ']: ' + event.payload.message, event.payload);
            });
            console.log('Tauri event listeners set up.');
        }
        setupEventListeners();
        ```
*   **如何测试 (How to Test)**:
    *   **前端控制台日志**: 运行Tauri应用。通过调用Tauri Command触发后端逻辑（如 `start_tests_for_batch_cmd`，它内部会更新状态并应发送事件）。
    *   观察前端Webview开发者工具的控制台，确认是否收到了 `channel_state_changed` 等事件，并且Payload内容正确。
    *   **后端日志**: 确认后端服务中 `emit_all` 调用成功，没有错误日志。
    *   测试不同类型的事件和Payload。

---

## Phase 4: 前端 (Angular) 基础搭建与初步集成

**目标：** 搭建 Angular 前端项目，实现与 Tauri 后端的基本通信（调用Commands，监听Events），并构建核心页面和组件的骨架，为实现完整功能做准备。

### (完成)步骤 4.1: 初始化 Angular 项目并集成到 Tauri

*   **原因 (Reason)**:
    *   Angular 将作为前端 UI 框架。
    *   需要将 Angular 项目正确配置为 Tauri 应用的前端部分。
*   **期望效果 (Expected Outcome)**:
    *   在 Tauri 项目的根目录下 (与 `src-tauri` 同级) 创建一个新的 Angular 项目 (e.g., `fat_test_frontend`)。
    *   配置 `tauri.conf.json` 中的 `build.devPath` 和 `build.distDir` 以指向 Angular 开发服务器和构建输出目录。
    *   能够通过 `npm run tauri dev` 同时启动 Rust 后端和 Angular 开发服务器，并在 Tauri 窗口中看到 Angular 应用的默认页面。
    *   Angular 项目中安装 `@tauri-apps/api`。
*   **实施描述 (Implementation Description)**:
    1.  在 Tauri 项目的根目录下，使用 Angular CLI 创建新项目: `ng new fat_test_frontend --routing --style=scss` (或根据喜好选择)。
    2.  进入 `fat_test_frontend` 目录，安装 Tauri API: `npm install @tauri-apps/api`。
    3.  **配置 `tauri.conf.json`** (位于 `src-tauri/tauri.conf.json`):
        *   `build.devPath`: 通常是 Angular 开发服务器的地址，默认为 `http://localhost:4200`。检查 `fat_test_frontend/angular.json` 中 `serve.options.port` 的设置。
        *   `build.distDir`: Angular 构建输出的目录，相对于 `tauri.conf.json` 的路径。通常是 `../fat_test_frontend/dist/fat_test_frontend` (具体路径取决于 Angular 项目名和 `angular.json` 中的 `outputPath` 配置)。
        *   `build.beforeDevCommand`: 设置为 `"npm run --prefix ../fat_test_frontend start"` (或 `yarn --cwd ../fat_test_frontend start`)，以便 `tauri dev` 自动启动 Angular 开发服务器。
        *   `build.beforeBuildCommand`: 设置为 `"npm run --prefix ../fat_test_frontend build"` (或 `yarn --cwd ../fat_test_frontend build`)，以便 `tauri build` 自动构建 Angular 应用。
    4.  **修改 Angular `package.json`** (`fat_test_frontend/package.json`):
        *   修改 `scripts.start` 为 `ng serve` (如果原来是 `ng serve --open`，去掉 `--open`)。
        *   修改 `scripts.build` 为 `ng build` (确保生成到正确的 `distDir`)。
    5.  运行 `npm run tauri dev` 从项目根目录启动，验证 Tauri 窗口加载了 Angular 应用。
*   **如何测试 (How to Test)**:
    *   **成功运行**: `npm run tauri dev` 启动后，Tauri 窗口显示 Angular 的欢迎页面。
    *   **热重载**: 修改 Angular 组件的 HTML 或 TS 文件，Tauri 窗口中的内容应自动更新。
    *   **控制台无错误**: Rust 控制台和浏览器控制台都没有与Tauri或Angular集成相关的明显错误。

### (完成)步骤 4.2: 创建 Angular 核心服务以封装 Tauri 通信

*   **原因 (Reason)**:
    *   将与 Tauri 后端的直接交互 (invoke commands, listen to events) 封装在 Angular 服务中，可以使组件代码更简洁、更易于测试，并提供一个统一的 API 供其他组件使用。
*   **期望效果 (Expected Outcome)**:
    *   创建 Angular 服务，如 `BackendCommsService` (或更具体的如 `TestOrchestrationApiService`, `DataManagementApiService`)。
    *   这些服务将使用 `@tauri-apps/api/tauri` 的 `invoke` 函数来调用后端 Tauri Commands。
    *   这些服务将使用 `@tauri-apps/api/event` 的 `listen` 和 `emit` 函数来处理后端事件。
    *   服务方法应返回 `Promise<T>` 或 `Observable<T>`，并处理来自后端的错误。
    *   **前端数据模型 (TypeScript Interfaces, in `src/app/models/` or similar):**
        *   需要为所有通过Tauri Commands参数传递、或作为返回值接收、或通过Tauri Events的Payload接收的Rust数据结构，在Angular前端创建对应的TypeScript接口。
        *   这些TS接口的结构（字段名、类型）必须与Rust结构体经过`serde`序列化后的JSON格式完全对应。
        *   **主要包括 (但不限于):**
            *   Enums: `OverallTestStatus`, `SubTestStatus`, `ModuleType`, `PointDataType`, `SubTestItem`, `LogLevelEvent` (TS中通常用字符串字面量联合类型或数字枚举实现)。
            *   Structs: `ChannelPointDefinition`, `ChannelTestInstance`, `SubTestExecutionResult`, `AnalogReadingPoint`, `TestBatchInfo`, `RawTestOutcome`.
            *   Command Args/Response Payloads: `ImportExcelAndPrepareBatchCmdArgs`, `ImportAndPrepareBatchResponse`, `StartTestsForBatchCmdArgs`, `GetBatchStatusCmdArgs`, `BatchDetailsPayload`, `ExecuteManualSubTestCmdArgs`, `ReadChannelValueCmdArgs`, `WriteChannelValueCmdArgs`.
            *   Event Payloads: `ChannelStateChangedEventPayload`, `BatchProgressEventPayload`, `LogMessageEventPayload`.
        *   **建议**: 可以考虑使用工具如 `ts-rs` (Rust crate) 自动从Rust数据结构生成TypeScript定义，以确保一致性并减少手动编写错误。如果手动编写，务必仔细核对。
*   **实施描述 (Implementation Description)**:
    1.  使用 Angular CLI 生成服务：
        `ng generate service services/backend-comms` (或按功能划分，如 `services/test-orchestration-api`)
    2.  **创建TypeScript接口文件 (e.g., `src/app/models/backend-models.ts`)**:
        ```typescript
        // src/app/models/backend-models.ts

        // --- Enums (example using string literal union types) ---
        export type OverallTestStatus = 
            | 'NotTested' | 'Testing' | 'Paused' | 'TestCompletedPassed' 
            | 'TestCompletedFailed' | 'Skipped' | 'WiringConfirmationPending' 
            | 'HardPointTestCompleted' | 'Aborted';

        export type SubTestStatus =
            | 'NotTested' | 'Testing' | 'Passed' | 'Failed' 
            | 'Skipped' | 'NotApplicable' | 'Aborted';

        export type ModuleType = 'AI' | 'AO' | 'DI' | 'DO' | 'Custom';
        
        export type PointDataType = 'Bool' | 'Real' | 'Int' | 'DInt' | 'Word' | 'DWord';

        // SubTestItem can be extensive, map carefully or use string
        export type SubTestItem = 
            | 'Communication' | 'WiringConfirmation' | 'HardPoint' // ... and so on
            | string; // Or list all explicitly
        
        export type LogLevelEvent = 'Info' | 'Warn' | 'Error' | 'Debug';

        // --- Structs & Payloads ---
        export interface AnalogReadingPoint {
            timestamp: string; // ISO DateTime string
            set_value_eng?: number | null;
            read_value_eng?: number | null;
            set_value_raw?: any | null;
            read_value_raw?: any | null;
            success: boolean;
            message?: string | null;
        }

        export interface SubTestExecutionResult {
            item: SubTestItem;
            status: SubTestStatus;
            start_time?: string | null; // ISO DateTime string
            end_time?: string | null;   // ISO DateTime string
            duration_ms?: number | null;
            message?: string | null;
            readings: AnalogReadingPoint[];
            details?: { [key: string]: any };
        }

        export interface ChannelPointDefinition {
            id: string;
            tag_name: string;
            description: string;
            module_type: ModuleType;
            plc_node_name_primary?: string | null;
            primary_address_read?: string | null;
            primary_address_write?: string | null;
            primary_data_type?: PointDataType | null;
            // ... other fields from Rust struct, ensure casing (snake_case from Rust -> camelCase in TS by serde default, or match as is)
            // For example, if serde doesn't rename, then: range_low, range_high etc.
            // If serde renames to camelCase: rangeLow, rangeHigh.
            // It's CRUCIAL to match the JSON structure produced by Rust's serde.
            // Assuming no field renaming for simplicity here, matching Rust fields directly.
            eng_unit?: string | null;
            range_low?: number | null;
            range_high?: number | null;
            // ... all other fields
            applicable_sub_tests: SubTestItem[];
            custom_fields: { [key: string]: string };
        }

        export interface ChannelTestInstance {
            instance_id: string;
            channel_definition_id: string;
            batch_id: string;
            overall_status: OverallTestStatus;
            error_message?: string | null;
            creation_time: string; // ISO DateTime string
            last_updated_time: string; // ISO DateTime string
            start_test_time?: string | null;
            final_test_time?: string | null;
            total_test_duration_ms?: number | null;
            sub_test_results: { [key: string /* SubTestItem as string */]: SubTestExecutionResult };
            current_operator?: string | null;
            retries_count: number;
            transient_data?: { [key: string]: any };
        }

        export interface TestBatchInfo {
            batch_id: string;
            product_model?: string | null;
            serial_number?: string | null;
            creation_time: string; // ISO DateTime string
            // ... all other fields, carefully matching Rust TestBatchInfo
            total_points: number;
            tested_points: number;
            passed_points: number;
            failed_points: number;
            skipped_points: number;
            status_summary?: string | null;
            custom_data: { [key: string]: string };
        }

        export interface RawTestOutcome {
            channel_instance_id: string;
            sub_test_item: SubTestItem;
            success: boolean;
            message?: string | null;
            start_time: string; // ISO DateTime string
            end_time: string;   // ISO DateTime string
            readings: AnalogReadingPoint[];
            details?: { [key: string]: any };
        }

        // Command Specific Payloads (Args & Responses)
        export interface ImportExcelAndPrepareBatchCmdArgs {
            file_path_str: string;
            product_model?: string | null;
            serial_number?: string | null;
        }
        export interface ImportAndPrepareBatchResponse {
            batch_info: TestBatchInfo;
            instances: ChannelTestInstance[];
        }

        export interface StartTestsForBatchCmdArgs { batch_id: string; }
        export interface GetBatchStatusCmdArgs { batch_id: string; }
        // Assuming BatchDetailsPayload is defined based on Rust: 
        export interface BatchDetailsPayload {
            batch_info: TestBatchInfo;
            instances: ChannelTestInstance[];
        }

        export interface ExecuteManualSubTestCmdArgs {
            instance_id: string;
            sub_test_item: SubTestItem;
            params?: { [key: string]: any } | null;
        }
        // ReadChannelValueCmdArgs, WriteChannelValueCmdArgs similarly...

        // Event Payloads
        export interface ChannelStateChangedEventPayload {
            batch_id: string;
            instance_id: string;
            updated_instance: ChannelTestInstance;
        }

        export interface BatchProgressEventPayload {
            batch_id: string;
            tested_points: number;
            total_points: number;
            passed_points: number;
            failed_points: number;
            skipped_points: number;
            overall_batch_status: OverallTestStatus;
            status_summary?: string | null;
        }

        export interface LogMessageEventPayload {
            timestamp: string; // ISO DateTime string
            level: LogLevelEvent;
            message: string;
            module_path?: string | null;
        }
        ```
    3.  **`BackendCommsService` (示例 - updated with more specific types)**:
        ```typescript
        // src/app/services/backend-comms.service.ts
        import { Injectable, OnDestroy } from '@angular/core';
        import { invoke } from '@tauri-apps/api/tauri';
        import { listen, Event as TauriEvent, UnlistenFn } from '@tauri-apps/api/event';
        import { Observable, Subject } from 'rxjs';
        import { 
            TestBatchInfo, ChannelTestInstance, ChannelStateChangedEventPayload, 
            ImportExcelAndPrepareBatchCmdArgs, ImportAndPrepareBatchResponse,
            StartTestsForBatchCmdArgs, GetBatchStatusCmdArgs, BatchDetailsPayload,
            ExecuteManualSubTestCmdArgs, RawTestOutcome 
            // ... import other TS models as needed
        } from '../models/backend-models'; // Adjust path as needed

        @Injectable({
            providedIn: 'root'
        })
        export class BackendCommsService implements OnDestroy {
            private channelStateChangedSubject = new Subject<ChannelStateChangedEventPayload>();
            public channelStateChanged$: Observable<ChannelStateChangedEventPayload> = this.channelStateChangedSubject.asObservable();
            // Other event subjects and observables...

            private unlistenFns: UnlistenFn[] = [];

            constructor() {
                this.listenToAllEvents();
            }

            async importExcelAndPrepareBatch(args: ImportExcelAndPrepareBatchCmdArgs):
                Promise<ImportAndPrepareBatchResponse> {
                try {
                    // Note: Rust command might return a tuple [TestBatchInfo, ChannelTestInstance[]]
                    // which needs to be mapped to ImportAndPrepareBatchResponse if not directly returned as such.
                    // The example Rust command for import_excel_and_prepare_batch_cmd was updated to return ImportAndPrepareBatchResponse.
                    return await invoke<ImportAndPrepareBatchResponse>('import_excel_and_prepare_batch_cmd', args);
                } catch (error) {
                    console.error('Error invoking import_excel_and_prepare_batch_cmd:', error);
                    throw error; // Or handle more gracefully
                }
            }

            async startTestsForBatch(args: StartTestsForBatchCmdArgs): Promise<void> {
                try {
                    await invoke<void>('start_tests_for_batch_cmd', args);
                } catch (error) {
                    console.error('Error invoking start_tests_for_batch_cmd:', error);
                    throw error;
                }
            }
            
            async getBatchDetails(args: GetBatchStatusCmdArgs): Promise<BatchDetailsPayload> {
                try {
                    return await invoke<BatchDetailsPayload>('get_batch_status_cmd', args);
                } catch (error) {
                    console.error('Error invoking get_batch_status_cmd:', error);
                    throw error;
                }
            }

            async executeManualSubTest(args: ExecuteManualSubTestCmdArgs): Promise<RawTestOutcome> {
                try {
                    return await invoke<RawTestOutcome>('execute_manual_sub_test_cmd', args);
                } catch (error) {
                    console.error('Error invoking execute_manual_sub_test_cmd:', error);
                    throw error;
                }
            }

            // ... Other Command-calling methods

            private async listenToAllEvents(): Promise<void> {
                const unlistenChannelState = await listen<ChannelStateChangedEventPayload>('fat://channel_state_changed', (event) => {
                    console.log('FE: Received channel_state_changed', event.payload);
                    this.channelStateChangedSubject.next(event.payload);
                });
                this.unlistenFns.push(unlistenChannelState);
                
                // Add listeners for BatchProgressEventPayload, LogMessageEventPayload etc.
            }

            ngOnDestroy() {
                this.unlistenFns.forEach(fn => fn());
            }
        }
        ```
*   **如何测试 (How to Test)**:
    *   **Angular 单元测试 (Jasmine/Karma)**:
        *   Mock `@tauri-apps/api/tauri` 的 `invoke` 函数和 `@tauri-apps/api/event` 的 `listen` 函数。
        *   测试服务方法调用 `invoke` 时是否使用了正确的 command 名称和参数 (matching the TS Args interfaces)。
        *   测试服务方法是否能正确处理 `invoke` 成功 (matching TS Response interfaces) 和失败的 `Promise`。
        *   测试事件监听是否被设置，并在 `ngOnDestroy` 中被清理。
        *   测试事件触发时，服务内部的 `Subject` 是否正确发出值 (matching TS Event Payload interfaces)。
    *   **组件集成测试**: 创建一个简单的测试组件，注入这些服务，调用服务方法并订阅事件，验证组件是否能正确接收数据和更新。

### (完成)步骤 4.3: 创建核心页面组件骨架

*   **原因 (Reason)**:
    *   核心页面是用户与系统交互的主要界面。
    *   尽早创建页面骨架有助于理解前端架构和数据流。
*   **期望效果 (Expected Outcome)**:
    *   使用 Angular CLI 生成核心页面组件：
        *   `BatchManagementComponent`: 批次管理页面，用于创建新批次、导入Excel、查看历史批次等。
        *   `TestExecutionComponent`: 测试执行页面，显示当前批次的通道列表、测试进度、实时状态更新等。
        *   `ManualTestComponent`: 手动测试页面，用于单点测试、手动读写等。
    *   配置 Angular 路由，使这些页面可以通过导航访问。
    *   每个组件都有基本的 HTML 模板和 TypeScript 逻辑，能够注入并使用 `BackendCommsService`。

### (完成)步骤 4.4: 初步实现核心页面的数据绑定和交互

*   **原因 (Reason)**:
    *   使前端页面能够通过调用 `BackendCommsService` 来获取数据、发送命令，并通过订阅其 `Observable` 来响应后端事件，从而实现基本的功能交互。
*   **期望效果 (Expected Outcome)**:
    *   `BatchManagementComponent`: 实现文件选择 (`<input type="file">`)，调用 `BackendCommsService.importExcelAndPrepareBatch`，显示返回的批次信息和实例列表的摘要，并导航到测试执行页面。
    *   `TestExecutionComponent`: 接收 `batchId` 路由参数，调用服务获取批次详情和实例列表，展示通道列表。当用户点击"开始测试"按钮时，调用 `BackendCommsService.startTestsForBatch`。订阅 `BackendCommsService.channelStateChanged$` 以实时更新通道状态。
    *   组件能够处理加载状态 (loading indicators) 和错误显示。

---

## Phase 5: UI/UX 细化与功能完善

**目标：** 基于骨架，细化 Angular 组件的 UI 设计和用户体验，实现更完整的前端功能，包括数据显示、用户交互、表单验证、错误提示、国际化等，并对现有功能进行迭代和优化。

### 步骤 5.1: UI 组件库集成与全局样式定义

*   **原因 (Reason)**:
    *   使用成熟的 UI 组件库可以快速构建美观且一致的用户界面，提高开发效率。
    *   定义全局样式和主题有助于保持应用的视觉统一性。
*   **期望效果 (Expected Outcome)**:
    *   选择并集成一个 Angular UI 组件库 (如 Angular Material, NG-ZORRO, PrimeNG 等)。
    *   定义应用的全局 CSS 变量、主题色、基本布局样式等。
    *   核心页面 (`BatchManagement`, `TestExecution`, `ManualTest`) 开始使用所选 UI 组件库的组件替换原生 HTML 元素，以改善外观和交互。
*   **实施描述 (Implementation Description)**:
    1.  **选择 UI 组件库**: 评估各组件库的特性、文档、社区支持和设计风格，选择一个适合项目的。
        *   例如，若选择 Angular Material: `ng add @angular/material`。
        *   若选择 NG-ZORRO: `ng add ng-zorro-antd`。
    2.  **导入所需模块**: 在 `app.module.ts` (或共享模块) 中导入所选 UI 组件库提供的模块。
        ```typescript
        // Example for Angular Material
        import { MatButtonModule } from '@angular/material/button';
        import { MatInputModule } from '@angular/material/input';
        import { MatTableModule } from '@angular/material/table';
        // ... other modules

        @NgModule({
          imports: [
            // ..., MatButtonModule, MatInputModule, MatTableModule
          ]
        })
        export class AppModule { }
        ```
    3.  **全局样式**: 在 `src/styles.scss` (或相应的主题文件) 中定义全局样式、CSS 变量，或配置组件库的主题。
        ```scss
        // src/styles.scss
        // @use '@angular/material' as mat;
        // @include mat.core();
        // $my-primary: mat.define-palette(mat.$indigo-palette, 500);
        // $my-accent: mat.define-palette(mat.$pink-palette, A200, A100, A400);
        // $my-theme: mat.define-light-theme((
        //   color: (
        //     primary: $my-primary,
        //     accent: $my-accent,
        //   )
        // ));
        // @include mat.all-component-themes($my-theme);

        body { margin: 0; font-family: Roboto, "Helvetica Neue", sans-serif; }
        .container { padding: 20px; }
        // ... other global styles
        ```
    4.  **替换组件**: 逐步修改现有组件的 HTML 模板，使用 UI 组件库提供的组件。例如，用 `<button mat-raised-button color="primary">Import</button>` 替换 `<button>`。
*   **如何测试 (How to Test)**:
    *   **视觉检查**: 运行 `npm run tauri dev`，检查各页面组件是否正确渲染了新 UI 库的样式。
    *   **交互测试**: 测试新组件的交互行为 (如按钮点击、表单输入、表格排序等) 是否符合预期。
    *   **响应式检查**: 如果 UI 库支持响应式设计，检查在不同窗口大小下的布局表现。

### 步骤 5.2: 完善 `BatchManagementComponent` 功能与UI

*   **原因 (Reason)**:
    *   批次管理是应用的入口，需要清晰的用户引导和完整的操作流程。
*   **期望效果 (Expected Outcome)**:
    *   使用 UI 组件库美化文件选择按钮和显示区域。
    *   显示导入的 `ChannelPointDefinition` 列表的摘要 (例如，总数，各类型模块数量)。
    *   允许用户输入或确认批次信息 (产品型号、序列号) - 可以从Excel提取或用户手动输入。
    *   提供清晰的加载状态和错误反馈 (例如，使用进度条、消息框/Toast)。
    *   成功导入并准备好批次后，界面引导用户进入接线确认或直接开始测试的步骤。
*   **实施描述 (Implementation Description)**:
    1.  **UI 改进**: 使用如 `<mat-form-field>`, `<mat-progress-bar>`, `NzUpload`, `NzInput`, `NzModal` 等组件。
    2.  **批次信息表单**: 添加表单让用户可以编辑从Excel提取或新输入的批次信息。
    3.  **点位定义预览**: (可选) 显示一个可滚动的表格，简要列出导入的点位定义。
    4.  **错误处理**: 当 `BackendCommsService.importExcelAndPrepareBatch` 抛出错误时，使用对话框或Toast组件显示友好的错误消息。
    5.  **流程引导**: 成功后，按钮状态改变，例如"下一步：接线确认"或"开始测试"。
*   **如何测试 (How to Test)**:
    *   **手动测试所有交互**: 文件选择、批次信息输入、不同导入结果（成功、失败、部分成功）的UI反馈。
    *   **表单验证测试**: 如果有表单，测试其验证逻辑。

### 步骤 5.3: 完善 `TestExecutionComponent` 功能与UI

*   **原因 (Reason)**:
    *   测试执行是应用的核心监控界面，需要清晰地展示大量动态信息。
*   **期望效果 (Expected Outcome)**:
    *   使用表格组件 (如 `MatTable`, `NzTable`) 显示 `ChannelTestInstance` 列表，包含关键列：位号、描述、模块类型、当前状态、测试结果、进度等。
    *   表格应支持排序、筛选（按状态、模块类型等）。
    *   实时更新表格中通道的状态和测试结果 (基于从 `BackendCommsService` 订阅的事件)。
    *   实现测试控制按钮 (开始批次测试、暂停、继续、停止) 并调用相应的后端服务方法。
    *   提供批次整体进度的可视化 (如进度条、统计数据：总数/已测/通过/失败)。
    *   点击列表中的某个通道，可以导航到/显示一个 `ChannelDetailComponent`，展示该通道更详细的测试信息和子测试项状态。
*   **实施描述 (Implementation Description)**:
    1.  **表格实现**: 使用 UI 库的表格组件配置列定义、数据源 (`this.instances`)。
    2.  **实时更新**: 在 `updateInstanceInList` 方法中，确保 Angular 的变更检测能够捕获到数据的变化并刷新表格。对于大型列表，考虑使用 `trackBy` 函数优化性能。
    3.  **控制按钮**: 添加按钮并绑定到 `TestExecutionComponent` 的方法，这些方法再调用 `BackendCommsService` 中对应的方法 (如 `pauseTestsForBatch`, `stopTestsForBatch`)。
    4.  **进度显示**: 根据 `this.instances` 数组计算统计数据，并绑定到模板。
    5.  **通道详情**: 实现 `ChannelDetailComponent` 并设置路由，或者使用模态框/侧边栏显示通道详情。
*   **如何测试 (How to Test)**:
    *   **动态数据显示**: 模拟后端发送大量通道状态更新事件，验证表格数据是否实时、正确地刷新，并且没有性能问题。
    *   **交互控制**: 测试开始、暂停、停止等控制按钮的功能，并观察UI状态和后端日志。
    *   **排序与筛选**: 测试表格的排序和筛选功能。
    *   **导航/详情显示**: 测试点击通道后是否能正确显示详细信息。

### 步骤 5.4: 实现 `ChannelDetailComponent` 和 `ManualTestComponent`

*   **原因 (Reason)**:
    *   提供对单个通道的详细视图和手动干预能力。
*   **期望效果 (Expected Outcome)**:
    *   **`ChannelDetailComponent`**: 显示选定 `ChannelTestInstance` 的所有配置信息 (`ChannelPointDefinition`) 和所有子测试项 (`SubTestItem`) 的当前状态、结果、时间戳、详细读值/消息。
    *   **`ManualTestComponent`**: (可能与 `ChannelDetailComponent` 集成或独立)
        *   允许用户选择一个通道和该通道的一个具体子测试项 (如 AI高报、DO置ON)。
        *   调用 `BackendCommsService` 中的手动测试方法 (`executeManualSubTestCmd`, `readCurrentValueCmd`, `writeValueManualCmd`)。
        *   显示手动操作的结果和反馈。
    *   UI清晰，操作直观。
*   **实施描述 (Implementation Description)**:
    1.  **`ChannelDetailComponent`**: 接收 `instanceId` (可能还有 `batchId`)，从服务获取完整的 `ChannelTestInstance` 和 `ChannelPointDefinition` 数据。使用描述列表或卡片布局来展示信息。子测试项可以用一个表格或列表显示。
    2.  **`ManualTestComponent`**: 
        *   提供下拉框或搜索框让用户选择通道和子测试项。
        *   根据选择的子测试项，动态显示相应的输入字段 (如模拟输出值、DO开关状态)。
        *   按钮触发对 `BackendCommsService` 相应方法的调用。
        *   使用UI组件显示操作结果 (成功/失败消息，读取到的值)。
*   **如何测试 (How to Test)**:
    *   **数据显示准确性**: 验证 `ChannelDetailComponent` 显示的所有信息是否与后端数据一致。
    *   **手动测试流程**: 对不同类型的点 (AI, DI, AO, DO) 和不同的子测试项，完整测试手动执行、读值、写值流程，验证UI反馈和后端实际执行情况（通过mock的PLC服务日志）。

### 步骤 5.5: 实现应用配置的持久化与加载 (`AppSettings`)

*   **原因 (Reason)**:
    *   应用需要保存用户偏好设置、默认PLC连接参数、上次使用的配置名称等信息。
    *   这些配置需要在应用启动时加载，并在用户修改后持久化，以便下次启动时恢复。
    *   使用专门的 `AppSettingsService` 和 JSON 文件存储应用配置是一种轻量级且职责清晰的做法，与业务数据的持久化分离。
*   **期望效果 (Expected Outcome)**:
    *   定义 `AppSettings` 结构体 (在 `src/models/settings.rs`)，包含所有需要持久化的应用级配置项。
    *   实现专门的 `IAppSettingsService` trait 和 `JsonAppSettingsService` 实现类，负责应用配置的加载和保存。
        *   加载逻辑：应用启动时，尝试从用户应用配置目录下的特定 JSON 文件 (e.g., `app_settings.json`) 加载 `AppSettings`。如果文件不存在或解析失败，则使用默认值。
        *   保存逻辑：当用户修改设置后，将 `AppSettings` 对象序列化为 JSON 并保存到上述文件中。
    *   使用专门的 `AppSettingsService` 而不是通用的 `IPersistenceService` 来处理应用配置，实现职责分离。
    *   Tauri command (`save_app_settings_cmd`, `load_app_settings_cmd`) 调用这些服务方法。
    *   前端 UI 提供界面供用户修改这些设置，并能正确反映当前加载的配置。
*   **实施描述 (Implementation Description)**:
    1.  **定义 `AppSettings` struct** (在 `src/models/settings.rs` 或类似位置):
        *   派生 `Serialize`, `Deserialize`, `Debug`, `Clone`。
        *   包含字段如：`last_opened_batch_id: Option<String>`, `default_plc_ip: String`, `theme: String`, `auto_load_last_config: bool` 等。
        *   提供一个 `Default` 实现 (`impl Default for AppSettings`) 返回一套安全可靠的默认设置。
    2.  **实现 `IAppSettingsService` trait 和 `JsonAppSettingsService** (在 `src/services/infrastructure/app_settings_service.rs`):
        *   定义 `IAppSettingsService` trait，包含 `load_settings()`, `save_settings()`, `reset_to_defaults()`, `validate_settings()` 等方法。
        *   实现 `JsonAppSettingsService` struct，使用 JSON 文件进行配置的读写。
        *   **`load_settings()` 方法**:
            *   尝试从指定路径读取 `app_settings.json` 文件。
            *   如果文件存在且解析成功，返回解析的 `AppSettings`。
            *   如果文件不存在或解析失败，返回 `AppSettings::default()`，并可能记录一个警告。
        *   **`save_settings(settings: &AppSettings)` 方法**:
            *   将 `AppSettings` 序列化为 JSON 并写入到指定文件路径。
            *   处理可能的文件写入错误。
        *   提供 `AppSettingsServiceFactory` 工厂类用于创建服务实例。
    3.  **创建 Tauri Commands** (`src/commands/system_settings.rs`):
        *   `#[tauri::command] async fn load_app_settings_cmd(state: tauri::State<'_, AppState>) -> Result<AppSettings, String>`:
            *   调用 `state.app_settings_service.load_settings().await.map_err(|e| e.to_string())`。
        *   `#[tauri::command] async fn save_app_settings_cmd(settings: AppSettings, state: tauri::State<'_, AppState>) -> Result<(), String>`:
            *   调用 `state.app_settings_service.save_settings(&settings).await.map_err(|e| e.to_string())`。
    4.  **前端 Angular 实现** (`SettingsService` 和相关组件):
        *   Angular `SettingsService` 调用上述 Tauri commands。
        *   创建设置页面组件，允许用户查看和修改 `AppSettings`。
        *   应用启动时，Angular 服务调用 `load_app_settings_cmd` 加载配置并应用到UI或相关服务。
*   **如何测试 (How to Test)**:
    *   **设置功能**: 修改设置，重启应用或触发相关逻辑，验证新设置是否生效，并检查对应的 `app_settings.json` 文件内容是否按预期更新。
    *   **默认值与错误处理**: 测试首次启动（无配置文件时）是否正确加载默认设置，以及配置文件损坏或无效时系统的行为。

---

## Phase 6: 真实硬件联调、打包与部署准备

**目标：** 将系统与真实的PLC硬件进行集成测试，确保所有功能在实际环境中按预期工作。准备应用的最终打包和部署。

### 步骤 6.1: `IPlcCommunicationService` 真实实现

*   **原因 (Reason)**:
    *   Mock 实现无法验证与真实PLC的通信。
    *   需要针对目标PLC型号和通信协议（如Modbus TCP, S7, OPC UA等）实现具体的通信逻辑。
*   **期望效果 (Expected Outcome)**:
    *   根据项目选用的PLC型号和协议，选择合适的Rust crate (如 `tokio-modbus`, `s7-rs`, `opcua` 等) 或自行实现通信协议的必要部分。
    *   实现 `RealPlcCommunicationService` struct，完整实现 `IPlcCommunicationService` trait 中定义的所有方法 (connect, disconnect, read/write various types)。
    *   包含详细的错误处理和重连机制。
    *   能够在开发环境中连接到测试用PLC并成功读写数据。
*   **实施描述 (Implementation Description)**:
    1.  **选择/实现协议库**: 
        *   Modbus TCP: 使用 `tokio-modbus`。
        *   Siemens S7: 使用 `s7-rs` 或其他类似库。
        *   OPC UA: 使用 `opcua` crate。
        *   如果协议特殊或没有现成库，可能需要基于TCP/UDP套接字和协议文档自行实现。
    2.  **`RealPlcCommunicationService` 实现**: 
        *   `connect`: 建立与PLC的连接 (e.g., `tokio_modbus::client::tcp::connect_slave`).
        *   `disconnect`: 关闭连接。
        *   `read_bool/f32/u16`等: 调用相应库的读线圈/保持寄存器等功能，并处理数据类型转换。
            *   例如, `tokio-modbus`: `ctx.read_coils(addr, count).await?`, `ctx.read_holding_registers(addr, count).await?`。
            *   需要处理字节序 (endianness) 和数据类型转换 (e.g., 两个u16寄存器组合成f32)。
        *   `write_X`: 调用相应库的写功能。
        *   错误处理: 包装库返回的错误到 `AppError::PlcCommunicationError`，提供清晰的错误信息。
        *   重连机制: 实现简单的自动重连逻辑，例如在连接断开或读写失败后尝试几次重连。
    3.  **配置**: PLC的IP地址、端口、Slave ID等应可配置 (例如通过之前实现的设置功能或配置文件)。
*   **如何测试 (How to Test)**:
    *   **独立单元测试/集成测试 (连接真实PLC)**: 
        *   准备一个测试PLC程序，包含各种类型的测试点位（开关量、模拟量输入输出）。
        *   编写测试用例，直接调用 `RealPlcCommunicationService` 的方法：
            *   测试连接和断开。
            *   对已知地址和值的点位进行读操作，验证返回值是否与PLC中的实际值一致。
            *   对已知地址的点位进行写操作，然后在PLC监控软件中或通过后续读操作验证值是否被成功写入。
            *   测试不同数据类型（bool, u16, f32, etc.）。
            *   测试并发读写 (如果 `RealPlcCommunicationService` 设计为支持，例如内部使用 `Mutex` 保护客户端上下文)。
            *   测试PLC断开连接或网络故障时的错误报告和重连行为。

### 步骤 6.2: 替换 Mock 服务为真实实现并进行完整流程联调

*   **原因 (Reason)**:
    *   确保整个应用在真实硬件环境下能正常工作。
*   **期望效果 (Expected Outcome)**:
    *   在 `src-tauri/src/main.rs` 中，将 `MockPlcCommunicationService` 和 `MockPersistenceService` (如果之前用的是Mock) 替换为 `RealPlcCommunicationService` 和 `JsonFilePersistenceService` (或数据库实现)。
    *   在连接真实PLC和目标测试设备的环境中，运行完整的 FAT 测试流程：
        *   通过UI导入Excel点位表。
        *   配置批次信息。
        *   执行（模拟的或真实的）接线确认。
        *   启动自动测试。
        *   观察UI上测试进度、各通道状态的实时更新。
        *   执行部分手动测试项。
        *   验证测试结果是否与预期一致 (需要人工比对PLC状态和UI显示)。
        *   验证测试报告是否能正确生成和导出。
    *   所有功能按预期工作，数据准确，系统稳定。
*   **实施描述 (Implementation Description)**:
    1.  **修改 `main.rs`**: 更新服务实例化部分，使用真实的PLC服务和主要的数据库持久化服务。
        ```rust
        // src-tauri/src/main.rs
        // ...
        use crate::services::infrastructure::persistence::SqliteOrmPersistenceService; // 确保引入
        // ...
        let plc_service = Arc::new(RealPlcCommunicationService::new(/* plc config */)); // 传入PLC配置
        // 主持久化服务，用于数据库操作
        let db_path = "fat_test_app.sqlite"; // 从配置或Tauri API获取
        let persistence_service = Arc::new(
            SqliteOrmPersistenceService::new(db_path).await.expect("Failed to initialize DB for testing")
        );
        // AppSettings 等配置现在由专门的 AppSettingsService 处理，使用JSON文件存储。
        
        // ...然后用这些实例创建其他服务，如 TestRecordService, DataManagementService 等，
        // 它们将通过注入的 IPersistenceService 与 SQLite 数据库交互。
        ```
    2.  **环境准备**: 
        *   连接好PLC、测试台架、被测设备。
        *   确保网络通畅，PLC程序已下载并运行。
    3.  **执行测试场景**: 
        *   **完整自动测试**: 导入一个包含各种类型点位的Excel表，运行完整测试流程。
        *   **手动干预测试**: 在自动测试过程中或完成后，进行手动测试操作。
        *   **异常处理测试**: 模拟PLC通信中断、设备故障等情况，观察系统反应和错误提示。
        *   **数据一致性检查**: 对比UI显示的测试结果、导出的报告与PLC的实际状态。
        *   **长时间运行测试**: (如果条件允许) 让系统长时间运行，检查是否有内存泄漏或性能下降。
*   **如何测试 (How to Test)**:
    *   **端到端场景通过性**: 如"实施描述"中所列的各项测试场景能够顺利完成，并且结果符合预期。
    *   **日志分析**: 仔细检查Rust后端日志和前端控制台日志，排查任何错误或异常。
    *   **人工观察与验证**: 测试工程师根据测试用例，比对系统行为和预期结果。

### 步骤 6.3: 应用图标、元数据和打包配置

*   **原因 (Reason)**:
    *   为应用提供专业的门面和正确的打包信息，以便生成可分发的安装包。
*   **期望效果 (Expected Outcome)**:
    *   为应用设计并准备不同尺寸的图标文件 (如 .ico, .png, .icns)。
    *   在 `tauri.conf.json` 中配置应用元数据：
        *   `package.productName`, `package.version`
        *   `tauri.bundle.identifier` (唯一包名，如 `com.mycompany.fattesst`)
        *   `tauri.bundle.icon` (指向图标文件列表)
        *   `tauri.bundle.publisher`, `tauri.bundle.copyright` 等。
    *   配置特定平台的打包选项 (如Windows的 `nsis` 或 `msi`，macOS的 `.app` 和 `.dmg`)。
*   **实施描述 (Implementation Description)**:
    1.  **创建图标**: 使用图像编辑工具创建符合各平台要求的图标文件，并放置在 `src-tauri/icons` 或约定的目录中。
        *   Windows: 通常需要一个 `.ico` 文件，包含多种尺寸 (e.g., 16x16, 32x32, 48x48, 256x256)。
        *   macOS: 需要一个 `.icns` 文件集。
        *   Linux: 通常使用 `.png`。
    2.  **修改 `tauri.conf.json`**: 
        ```json
        {
          "package": {
            "productName": "FAT Test Suite",
            "version": "1.0.0"
          },
          "tauri": {
            "bundle": {
              "active": true,
              "identifier": "com.example.fattest",
              "icon": [
                "icons/32x32.png",
                "icons/128x128.png",
                "icons/128x128@2x.png",
                "icons/icon.icns",
                "icons/icon.ico"
              ],
              "publisher": "My Company",
              "copyright": "Copyright © My Company 2023",
              // ... Windows specific (NSIS or WiX/MSI)
              "windows": {
                "certificateThumbprint": null, // For code signing
                "digestAlgorithm": "sha256",
                "timestampUrl": "",
                "nsis": {
                    "installerIcon": "icons/installer.ico",
                    "sidebarImage": "icons/sidebar.bmp", // Optional
                    "headerImage": "icons/header.bmp" // Optional
                }
              },
              // ... macOS specific
              "macOS": {
                "frameworks": [],
                "minimumSystemVersion": "10.13",
                "exceptionDomain": "",
                "signingIdentity": null, // For code signing
                "providerShortName": null,
                "entitlements": null
              }
            }
            // ...
          }
        }
        ```
    3.  查阅 Tauri 打包和签名的官方文档，了解各平台特定配置的详细信息。
*   **如何测试 (How to Test)**:
    *   **配置验证**: 仔细检查 `tauri.conf.json` 中的路径和值是否正确。
    *   后续通过实际打包来验证图标和元数据是否正确应用到安装包和已安装的应用上。

### 步骤 6.4: 构建生产版本并测试安装包

*   **原因 (Reason)**:
    *   生成最终的可分发安装包，并在干净的环境中测试其安装和运行情况。
*   **期望效果 (Expected Outcome)**:
    *   运行 `npm run tauri build` 成功生成目标平台的安装包 (如 `.msi` 或 `.exe` for Windows, `.dmg` for macOS, `.deb` or `.AppImage` for Linux)。
    *   在干净的虚拟机或物理机（未安装过开发环境）上成功安装应用程序。
    *   安装后的应用程序能够正常启动，图标、名称等元数据正确显示。
    *   应用的核心功能（如导入、连接PLC（如果测试环境允许）、显示数据）能够基本工作。
*   **实施描述 (Implementation Description)**:
    1.  **执行构建命令**: 在项目根目录运行 `npm run tauri build`。
    2.  **定位安装包**: 构建成功后，安装包通常位于 `src-tauri/target/release/bundle/` 目录下对应的平台文件夹中。
    3.  **测试环境准备**: 准备一个或多个干净的测试环境 (虚拟机是理想选择)，覆盖目标操作系统版本。
    4.  **安装测试**: 
        *   将安装包拷贝到测试环境。
        *   执行安装程序，注意安装过程中的提示、选项、许可协议（如果配置了）。
        *   验证安装路径、开始菜单/桌面快捷方式是否正确创建。
    5.  **运行测试**: 
        *   从快捷方式或安装目录启动应用。
        *   检查应用窗口标题、图标是否正确。
        *   执行基本的核心功能进行冒烟测试。
        *   检查应用是否能正确创建和访问其数据文件（如JSON持久化文件，日志文件）。
    6.  **卸载测试**: 测试应用的卸载过程是否干净，是否正确移除了所有文件和注册表项（如果适用）。
*   **如何测试 (How to Test)**:
    *   **构建成功**: `tauri build` 命令无错误完成。
    *   **安装/卸载成功**: 在目标平台上，安装和卸载过程符合预期。
    *   **应用运行正常**: 安装后的应用能够启动并执行核心功能，无明显崩溃或错误。
    *   **元数据正确**: 应用的名称、图标、版本号等在操作系统中正确显示。

### 步骤 6.5: 编写用户手册和部署文档 (可选)

*   **原因 (Reason)**:
    *   为最终用户和部署人员提供必要的指导。
*   **期望效果 (Expected Outcome)**:
    *   **用户手册**: 描述如何安装、配置和使用应用的主要功能，包含截图和操作步骤。
    *   **部署文档**: (如果应用有特殊的服务器端或环境依赖) 描述部署环境要求、配置步骤、故障排除指南。
*   **实施描述 (Implementation Description)**:
    1.  根据应用功能，编写用户操作流程。
    2.  截图并加以说明。
    3.  整理部署所需的系统要求、依赖项、配置文件说明等。
*   **如何测试 (How to Test)**:
    *   **文档审阅**: 由不熟悉项目的测试人员或同事按照文档进行操作，检查文档的清晰度、准确性和完整性。
    *   **实际操作验证**: 按照部署文档在测试环境中尝试部署，验证步骤可行性。

---
**项目完成！后续可能进入维护和迭代周期。**
