# FAT_TEST ç¬¬äºŒé˜¶æ®µé‡æ„å®æ–½æ­¥éª¤

## ğŸ“‹ æ€»ä½“è§„åˆ’

### ğŸ¯ é‡æ„ç›®æ ‡
åŸºäºç¬¬ä¸€é˜¶æ®µå·²å®Œæˆçš„åŸºç¡€æ¶æ„ï¼Œæ·±åº¦é‡æ„æ ¸å¿ƒä¸šåŠ¡é€»è¾‘ï¼Œå®ç°å®Œæ•´çš„å·¥å‚éªŒæ”¶æµ‹è¯•åŠŸèƒ½ã€‚

### ğŸ“Š é‡æ„èŒƒå›´
- **åç«¯æ ¸å¿ƒæœåŠ¡**: æµ‹è¯•æ‰§è¡Œå¼•æ“ã€çŠ¶æ€ç®¡ç†ã€PLCé€šä¿¡ã€æ•°æ®æŒä¹…åŒ–
- **å‰ç«¯ç”¨æˆ·ç•Œé¢**: æµ‹è¯•åŒºåŸŸã€é…ç½®ç®¡ç†ã€å®æ—¶ç›‘æ§ã€æŠ¥å‘Šç”Ÿæˆ
- **æ•°æ®æ¨¡å‹å®Œå–„**: åŸºäºåŸC#é¡¹ç›®çš„æ•°æ®ç»“æ„è¿ç§»å’Œä¼˜åŒ–
- **é›†æˆæµ‹è¯•**: ç«¯åˆ°ç«¯æµ‹è¯•æµç¨‹éªŒè¯

### ğŸ—“ï¸ å®æ–½è®¡åˆ’
æ€»è®¡ **8ä¸ªä¸»è¦é˜¶æ®µ**ï¼Œé¢„è®¡ **4-6å‘¨** å®Œæˆ

---

## ğŸ—ï¸ é˜¶æ®µä¸€ï¼šæ•°æ®æ¨¡å‹é‡æ„å’Œæ•°æ®åº“è¿ç§»

### ğŸ“ é‡æ„åŸå› 
- å½“å‰æ•°æ®æ¨¡å‹å­—æ®µä¸å®Œæ•´ï¼Œç¼ºå°‘å…³é”®ä¸šåŠ¡å­—æ®µ
- éœ€è¦åŸºäºåŸC#é¡¹ç›®çš„æ•°æ®åº“ç»“æ„è¿›è¡Œå®Œæ•´è¿ç§»
- çŠ¶æ€æšä¸¾å’Œä¸šåŠ¡é€»è¾‘éœ€è¦ä¸åŸç³»ç»Ÿä¿æŒä¸€è‡´

### ğŸ¯ å®æ–½ç›®æ ‡
- [x] å®Œæˆæ‰€æœ‰æ ¸å¿ƒå®ä½“çš„SeaORMæ¨¡å‹å®šä¹‰
- [x] å®ç°æ•°æ®åº“è¿ç§»è„šæœ¬
- [x] å»ºç«‹å®Œæ•´çš„æ•°æ®è®¿é—®å±‚
- [x] éªŒè¯æ•°æ®æ¨¡å‹çš„å®Œæ•´æ€§å’Œæ­£ç¡®æ€§

### ğŸ“‹ è¯¦ç»†å®æ–½æ­¥éª¤

#### 1.1 åˆ†æåŸC#é¡¹ç›®æ•°æ®ç»“æ„
**æ‰§è¡Œå†…å®¹**:
- [x] æ·±å…¥åˆ†æ `Notes/ChannelMappings_202505301041.sql` æ–‡ä»¶
- [x] æå–æ‰€æœ‰è¡¨ç»“æ„å’Œå­—æ®µå®šä¹‰
- [x] åˆ†æè¡¨ä¹‹é—´çš„å…³ç³»å’Œçº¦æŸ
- [x] è¯†åˆ«å…³é”®ä¸šåŠ¡å­—æ®µå’Œæšä¸¾ç±»å‹

**è¯¦ç»†æ‰§è¡Œæ­¥éª¤**:

**æ­¥éª¤1.1.1: åˆ›å»ºæ•°æ®åˆ†æå·¥ä½œç›®å½•**
```bash
# åœ¨é¡¹ç›®æ ¹ç›®å½•æ‰§è¡Œ
mkdir -p docs/data-analysis
cd docs/data-analysis
```

**æ­¥éª¤1.1.2: æå–SQLè¡¨ç»“æ„**
```bash
# æå–æ‰€æœ‰CREATE TABLEè¯­å¥
grep -A 50 "CREATE TABLE" ../../Notes/ChannelMappings_202505301041.sql > tables_structure.sql

# æå–æ‰€æœ‰å­—æ®µå®šä¹‰
grep -E "^\s*\[.*\].*," ../../Notes/ChannelMappings_202505301041.sql > fields_list.txt

# æå–ä¸»é”®å’Œå¤–é”®çº¦æŸ
grep -E "(PRIMARY KEY|FOREIGN KEY|REFERENCES)" ../../Notes/ChannelMappings_202505301041.sql > constraints.sql
```

**æ­¥éª¤1.1.3: åˆ›å»ºå­—æ®µæ˜ å°„è¡¨**
åˆ›å»ºæ–‡ä»¶ `field_mapping.md`:
```markdown
# C# åˆ° Rust å­—æ®µæ˜ å°„è¡¨

## ChannelPointDefinitions è¡¨
| C# å­—æ®µå | C# ç±»å‹ | Rust å­—æ®µå | Rust ç±»å‹ | è¯´æ˜ |
|-----------|---------|-------------|-----------|------|
| Id | string | id | String | ä¸»é”® |
| ChannelTag | string | tag | String | é€šé“æ ‡è¯† |
| VariableName | string | variable_name | String | å˜é‡å |
| ModuleType | string | module_type | ModuleType | æ¨¡å—ç±»å‹æšä¸¾ |
| PlcCommunicationAddress | string | plc_communication_address | String | PLCé€šä¿¡åœ°å€ |
| PowerSupplyType | string | power_supply_type | PowerSupplyType | ä¾›ç”µç±»å‹æšä¸¾ |
| RangeLowerLimit | decimal? | range_lower_limit | Option<f64> | é‡ç¨‹ä¸‹é™ |
| RangeUpperLimit | decimal? | range_upper_limit | Option<f64> | é‡ç¨‹ä¸Šé™ |
| VariableDescription | string | variable_description | Option<String> | å˜é‡æè¿° |
| WireSystem | string | wire_system | Option<WireSystem> | æ¥çº¿åˆ¶å¼æšä¸¾ |
| CreatedTime | DateTime | created_time | DateTime<Utc> | åˆ›å»ºæ—¶é—´ |
| UpdatedTime | DateTime | updated_time | DateTime<Utc> | æ›´æ–°æ—¶é—´ |

## ChannelTestInstances è¡¨
| C# å­—æ®µå | C# ç±»å‹ | Rust å­—æ®µå | Rust ç±»å‹ | è¯´æ˜ |
|-----------|---------|-------------|-----------|------|
| InstanceId | string | instance_id | String | å®ä¾‹IDä¸»é”® |
| DefinitionId | string | definition_id | String | å…³è”å®šä¹‰ID |
| OverallStatus | string | overall_status | OverallTestStatus | æ•´ä½“çŠ¶æ€æšä¸¾ |
| TestBatch | string | test_batch | String | æµ‹è¯•æ‰¹æ¬¡ |
| CreatedTime | DateTime | created_time | DateTime<Utc> | åˆ›å»ºæ—¶é—´ |
| UpdatedTime | DateTime | updated_time | DateTime<Utc> | æ›´æ–°æ—¶é—´ |
```

**æ­¥éª¤1.1.4: åˆ†ææšä¸¾ç±»å‹**
åˆ›å»ºæ–‡ä»¶ `enums_analysis.md`:
```markdown
# æšä¸¾ç±»å‹åˆ†æ

## ModuleType (æ¨¡å—ç±»å‹)
- AI: æ¨¡æ‹Ÿé‡è¾“å…¥
- AO: æ¨¡æ‹Ÿé‡è¾“å‡º
- DI: æ•°å­—é‡è¾“å…¥
- DO: æ•°å­—é‡è¾“å‡º

## PowerSupplyType (ä¾›ç”µç±»å‹)
- Active: æœ‰æº
- Passive: æ— æº

## WireSystem (æ¥çº¿åˆ¶å¼)
- TwoWire: äºŒçº¿åˆ¶
- FourWire: å››çº¿åˆ¶

## OverallTestStatus (æ•´ä½“æµ‹è¯•çŠ¶æ€)
- NotTested: æœªæµ‹è¯•
- WiringConfirmed: æ¥çº¿ç¡®è®¤
- HardPointTesting: ç¡¬ç‚¹æµ‹è¯•ä¸­
- HardPointPassed: ç¡¬ç‚¹æµ‹è¯•é€šè¿‡
- HardPointFailed: ç¡¬ç‚¹æµ‹è¯•å¤±è´¥
- ManualTesting: æ‰‹åŠ¨æµ‹è¯•ä¸­
- ManualPassed: æ‰‹åŠ¨æµ‹è¯•é€šè¿‡
- AllCompleted: å…¨éƒ¨å®Œæˆ

## SubTestItem (å­æµ‹è¯•é¡¹ç›®)
- HardPoint: ç¡¬ç‚¹æµ‹è¯•
- HighHighAlarm: é«˜é«˜æŠ¥è­¦
- HighAlarm: é«˜æŠ¥è­¦
- LowAlarm: ä½æŠ¥è­¦
- LowLowAlarm: ä½ä½æŠ¥è­¦
- ShowValue: æ˜¾ç¤ºå€¼
- TrendCheck: è¶‹åŠ¿æ£€æŸ¥
- ReportCheck: æŠ¥è¡¨æ£€æŸ¥
- MaintenanceFunction: ç»´æŠ¤åŠŸèƒ½

## TestResult (æµ‹è¯•ç»“æœ)
- Pass: é€šè¿‡
- Fail: å¤±è´¥
- NotTested: æœªæµ‹è¯•

## TestExecutionStatus (æµ‹è¯•æ‰§è¡ŒçŠ¶æ€)
- Pending: ç­‰å¾…ä¸­
- Running: æ‰§è¡Œä¸­
- Completed: å·²å®Œæˆ
- Failed: æ‰§è¡Œå¤±è´¥
- Cancelled: å·²å–æ¶ˆ
```

**æ­¥éª¤1.1.5: åˆ›å»ºè¡¨å…³ç³»å›¾**
åˆ›å»ºæ–‡ä»¶ `table_relationships.md`:
```markdown
# æ•°æ®åº“è¡¨å…³ç³»å›¾

```mermaid
erDiagram
    ChannelPointDefinitions ||--o{ ChannelTestInstances : "1:N"
    ChannelTestInstances ||--o{ SubTestExecutionResults : "1:N"
    TestBatches ||--o{ ChannelTestInstances : "1:N"
    PlcConnectionConfigs ||--o{ ChannelPointDefinitions : "1:N"

    ChannelPointDefinitions {
        string id PK
        string tag
        string variable_name
        string module_type
        string plc_communication_address
        string power_supply_type
        decimal range_lower_limit
        decimal range_upper_limit
        string variable_description
        string wire_system
        datetime created_time
        datetime updated_time
    }

    ChannelTestInstances {
        string instance_id PK
        string definition_id FK
        string overall_status
        string test_batch
        datetime created_time
        datetime updated_time
    }

    SubTestExecutionResults {
        string id PK
        string instance_id FK
        string test_item
        string status
        string result
        string error_message
        datetime execution_time
        text test_values_json
    }

    TestBatches {
        string batch_id PK
        string product_model
        int total_channels
        int completed_channels
        string status
        datetime created_time
        datetime started_time
        datetime completed_time
    }

    PlcConnectionConfigs {
        string id PK
        string name
        string ip_address
        int port
        string protocol_type
        int timeout_ms
        int max_connections
        bool is_test_plc
        datetime created_time
        datetime updated_time
    }
```

**éªŒè¯æ£€æŸ¥ç‚¹**:
- [x] æ‰€æœ‰è¡¨ç»“æ„å·²æå–åˆ° `docs/data-analysis/tables_structure.sql`
- [x] å­—æ®µæ˜ å°„è¡¨å·²åˆ›å»ºå¹¶åŒ…å«æ‰€æœ‰å¿…è¦å­—æ®µ `docs/data-analysis/field_mapping.md`
- [x] æšä¸¾ç±»å‹åˆ†æå®Œæ•´ï¼ŒåŒ…å«æ‰€æœ‰å¯èƒ½å€¼ `docs/data-analysis/enums_analysis.md`
- [x] è¡¨å…³ç³»å›¾å‡†ç¡®åæ˜ æ•°æ®åº“è®¾è®¡ `docs/data-analysis/table_relationships.md`
- [x] çº¦æŸæ¡ä»¶å·²è¯†åˆ«å¹¶è®°å½• `docs/data-analysis/constraints.sql`

**é¢„æœŸç»“æœ**:
- âœ… å®Œæ•´çš„æ•°æ®åº“è¡¨ç»“æ„æ¸…å• (`docs/data-analysis/tables_structure.sql`)
- âœ… è¯¦ç»†çš„å­—æ®µæ˜ å°„å¯¹ç…§è¡¨ (`docs/data-analysis/field_mapping.md`)
- âœ… å®Œæ•´çš„æšä¸¾ç±»å‹å®šä¹‰ (`docs/data-analysis/enums_analysis.md`)
- âœ… æ¸…æ™°çš„è¡¨å…³ç³»å›¾ (`docs/data-analysis/table_relationships.md`)
- âœ… çº¦æŸæ¡ä»¶å’Œä¸šåŠ¡è§„åˆ™æ–‡æ¡£ (`docs/data-analysis/constraints.sql`)

#### 1.2 è®¾è®¡Rustæ•°æ®æ¨¡å‹
**æ‰§è¡Œå†…å®¹**:
- [x] åˆ›å»º `src/domain/entities/` ç›®å½•ç»“æ„
- [x] å®šä¹‰æ‰€æœ‰æ ¸å¿ƒå®ä½“çš„Rustç»“æ„ä½“
- [x] å®ç°SeaORMçš„Entityã€Modelã€ActiveModel
- [x] å®šä¹‰æšä¸¾ç±»å‹å’ŒçŠ¶æ€è½¬æ¢

**è¯¦ç»†æ‰§è¡Œæ­¥éª¤**:

**æ­¥éª¤1.2.1: åˆ›å»ºå®ä½“ç›®å½•ç»“æ„**
```bash
# åœ¨ src-tauri ç›®å½•ä¸‹æ‰§è¡Œ
cd FactoryTesting/src-tauri
mkdir -p src/domain/entities
mkdir -p src/domain/enums
mkdir -p src/domain/value_objects
```

**æ­¥éª¤1.2.2: å®šä¹‰æ ¸å¿ƒæšä¸¾ç±»å‹**
åˆ›å»ºæ–‡ä»¶ `src/domain/enums/mod.rs`:
```rust
pub mod module_type;
pub mod power_supply_type;
pub mod wire_system;
pub mod overall_test_status;
pub mod sub_test_item;
pub mod test_result;
pub mod test_execution_status;

pub use module_type::ModuleType;
pub use power_supply_type::PowerSupplyType;
pub use wire_system::WireSystem;
pub use overall_test_status::OverallTestStatus;
pub use sub_test_item::SubTestItem;
pub use test_result::TestResult;
pub use test_execution_status::TestExecutionStatus;
```

**æ­¥éª¤1.2.3: å®ç°ModuleTypeæšä¸¾**
åˆ›å»ºæ–‡ä»¶ `src/domain/enums/module_type.rs`:
```rust
use sea_orm::entity::prelude::*;
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, PartialEq, Eq, EnumIter, DeriveActiveEnum, Serialize, Deserialize)]
#[sea_orm(rs_type = "String", db_type = "String(Some(10))")]
pub enum ModuleType {
    #[sea_orm(string_value = "AI")]
    AI,
    #[sea_orm(string_value = "AO")]
    AO,
    #[sea_orm(string_value = "DI")]
    DI,
    #[sea_orm(string_value = "DO")]
    DO,
}

impl ModuleType {
    /// è·å–æ¨¡å—ç±»å‹çš„ä¸­æ–‡æè¿°
    pub fn description(&self) -> &'static str {
        match self {
            ModuleType::AI => "æ¨¡æ‹Ÿé‡è¾“å…¥",
            ModuleType::AO => "æ¨¡æ‹Ÿé‡è¾“å‡º",
            ModuleType::DI => "æ•°å­—é‡è¾“å…¥",
            ModuleType::DO => "æ•°å­—é‡è¾“å‡º",
        }
    }

    /// åˆ¤æ–­æ˜¯å¦ä¸ºæ¨¡æ‹Ÿé‡ç±»å‹
    pub fn is_analog(&self) -> bool {
        matches!(self, ModuleType::AI | ModuleType::AO)
    }

    /// åˆ¤æ–­æ˜¯å¦ä¸ºæ•°å­—é‡ç±»å‹
    pub fn is_digital(&self) -> bool {
        matches!(self, ModuleType::DI | ModuleType::DO)
    }

    /// åˆ¤æ–­æ˜¯å¦ä¸ºè¾“å…¥ç±»å‹
    pub fn is_input(&self) -> bool {
        matches!(self, ModuleType::AI | ModuleType::DI)
    }

    /// åˆ¤æ–­æ˜¯å¦ä¸ºè¾“å‡ºç±»å‹
    pub fn is_output(&self) -> bool {
        matches!(self, ModuleType::AO | ModuleType::DO)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_module_type_description() {
        assert_eq!(ModuleType::AI.description(), "æ¨¡æ‹Ÿé‡è¾“å…¥");
        assert_eq!(ModuleType::AO.description(), "æ¨¡æ‹Ÿé‡è¾“å‡º");
        assert_eq!(ModuleType::DI.description(), "æ•°å­—é‡è¾“å…¥");
        assert_eq!(ModuleType::DO.description(), "æ•°å­—é‡è¾“å‡º");
    }

    #[test]
    fn test_module_type_classification() {
        assert!(ModuleType::AI.is_analog());
        assert!(ModuleType::AO.is_analog());
        assert!(ModuleType::DI.is_digital());
        assert!(ModuleType::DO.is_digital());

        assert!(ModuleType::AI.is_input());
        assert!(ModuleType::DI.is_input());
        assert!(ModuleType::AO.is_output());
        assert!(ModuleType::DO.is_output());
    }
}
```

**æ­¥éª¤1.2.4: å®ç°OverallTestStatusæšä¸¾**
åˆ›å»ºæ–‡ä»¶ `src/domain/enums/overall_test_status.rs`:
```rust
use sea_orm::entity::prelude::*;
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, PartialEq, Eq, EnumIter, DeriveActiveEnum, Serialize, Deserialize)]
#[sea_orm(rs_type = "String", db_type = "String(Some(20))")]
pub enum OverallTestStatus {
    #[sea_orm(string_value = "NotTested")]
    NotTested,
    #[sea_orm(string_value = "WiringConfirmed")]
    WiringConfirmed,
    #[sea_orm(string_value = "HardPointTesting")]
    HardPointTesting,
    #[sea_orm(string_value = "HardPointPassed")]
    HardPointPassed,
    #[sea_orm(string_value = "HardPointFailed")]
    HardPointFailed,
    #[sea_orm(string_value = "ManualTesting")]
    ManualTesting,
    #[sea_orm(string_value = "ManualPassed")]
    ManualPassed,
    #[sea_orm(string_value = "AllCompleted")]
    AllCompleted,
}

impl OverallTestStatus {
    /// è·å–çŠ¶æ€çš„ä¸­æ–‡æè¿°
    pub fn description(&self) -> &'static str {
        match self {
            OverallTestStatus::NotTested => "æœªæµ‹è¯•",
            OverallTestStatus::WiringConfirmed => "æ¥çº¿ç¡®è®¤",
            OverallTestStatus::HardPointTesting => "ç¡¬ç‚¹æµ‹è¯•ä¸­",
            OverallTestStatus::HardPointPassed => "ç¡¬ç‚¹æµ‹è¯•é€šè¿‡",
            OverallTestStatus::HardPointFailed => "ç¡¬ç‚¹æµ‹è¯•å¤±è´¥",
            OverallTestStatus::ManualTesting => "æ‰‹åŠ¨æµ‹è¯•ä¸­",
            OverallTestStatus::ManualPassed => "æ‰‹åŠ¨æµ‹è¯•é€šè¿‡",
            OverallTestStatus::AllCompleted => "å…¨éƒ¨å®Œæˆ",
        }
    }

    /// è·å–çŠ¶æ€çš„é¢œè‰²ä»£ç ï¼ˆç”¨äºå‰ç«¯æ˜¾ç¤ºï¼‰
    pub fn color_code(&self) -> &'static str {
        match self {
            OverallTestStatus::NotTested => "#d9d9d9",           // ç°è‰²
            OverallTestStatus::WiringConfirmed => "#1890ff",     // è“è‰²
            OverallTestStatus::HardPointTesting => "#faad14",    // æ©™è‰²
            OverallTestStatus::HardPointPassed => "#52c41a",     // ç»¿è‰²
            OverallTestStatus::HardPointFailed => "#f5222d",     // çº¢è‰²
            OverallTestStatus::ManualTesting => "#722ed1",       // ç´«è‰²
            OverallTestStatus::ManualPassed => "#13c2c2",        // é’è‰²
            OverallTestStatus::AllCompleted => "#389e0d",        // æ·±ç»¿è‰²
        }
    }

    /// åˆ¤æ–­æ˜¯å¦ä¸ºå®ŒæˆçŠ¶æ€
    pub fn is_completed(&self) -> bool {
        matches!(self,
            OverallTestStatus::HardPointPassed |
            OverallTestStatus::HardPointFailed |
            OverallTestStatus::ManualPassed |
            OverallTestStatus::AllCompleted
        )
    }

    /// åˆ¤æ–­æ˜¯å¦ä¸ºæµ‹è¯•ä¸­çŠ¶æ€
    pub fn is_testing(&self) -> bool {
        matches!(self,
            OverallTestStatus::HardPointTesting |
            OverallTestStatus::ManualTesting
        )
    }

    /// è·å–ä¸‹ä¸€ä¸ªå¯èƒ½çš„çŠ¶æ€åˆ—è¡¨
    pub fn next_possible_states(&self) -> Vec<OverallTestStatus> {
        match self {
            OverallTestStatus::NotTested => vec![OverallTestStatus::WiringConfirmed],
            OverallTestStatus::WiringConfirmed => vec![OverallTestStatus::HardPointTesting],
            OverallTestStatus::HardPointTesting => vec![
                OverallTestStatus::HardPointPassed,
                OverallTestStatus::HardPointFailed,
            ],
            OverallTestStatus::HardPointPassed => vec![OverallTestStatus::ManualTesting],
            OverallTestStatus::HardPointFailed => vec![OverallTestStatus::HardPointTesting],
            OverallTestStatus::ManualTesting => vec![OverallTestStatus::ManualPassed],
            OverallTestStatus::ManualPassed => vec![
                OverallTestStatus::AllCompleted,
                OverallTestStatus::HardPointTesting, // å…è®¸é‡æ–°æµ‹è¯•
            ],
            OverallTestStatus::AllCompleted => vec![], // ç»ˆæ€
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_status_description() {
        assert_eq!(OverallTestStatus::NotTested.description(), "æœªæµ‹è¯•");
        assert_eq!(OverallTestStatus::HardPointPassed.description(), "ç¡¬ç‚¹æµ‹è¯•é€šè¿‡");
    }

    #[test]
    fn test_status_classification() {
        assert!(OverallTestStatus::HardPointPassed.is_completed());
        assert!(OverallTestStatus::HardPointTesting.is_testing());
        assert!(!OverallTestStatus::NotTested.is_completed());
    }

    #[test]
    fn test_state_transitions() {
        let next_states = OverallTestStatus::HardPointTesting.next_possible_states();
        assert!(next_states.contains(&OverallTestStatus::HardPointPassed));
        assert!(next_states.contains(&OverallTestStatus::HardPointFailed));
    }
}
```

**æ­¥éª¤1.2.5: å®ç°ChannelPointDefinitionå®ä½“**
åˆ›å»ºæ–‡ä»¶ `src/domain/entities/channel_point_definition.rs`:
```rust
use sea_orm::entity::prelude::*;
use serde::{Deserialize, Serialize};
use chrono::{DateTime, Utc};
use crate::domain::enums::{ModuleType, PowerSupplyType, WireSystem};

#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Serialize, Deserialize)]
#[sea_orm(table_name = "channel_point_definitions")]
pub struct Model {
    #[sea_orm(primary_key, auto_increment = false)]
    pub id: String,
    pub tag: String,
    pub variable_name: String,
    pub module_type: ModuleType,
    pub plc_communication_address: String,
    pub power_supply_type: PowerSupplyType,
    pub range_lower_limit: Option<f64>,
    pub range_upper_limit: Option<f64>,
    pub variable_description: Option<String>,
    pub wire_system: Option<WireSystem>,
    pub created_time: DateTime<Utc>,
    pub updated_time: DateTime<Utc>,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    #[sea_orm(has_many = "super::channel_test_instance::Entity")]
    ChannelTestInstances,
}

impl Related<super::channel_test_instance::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::ChannelTestInstances.def()
    }
}

impl ActiveModelBehavior for ActiveModel {
    fn new() -> Self {
        Self {
            id: Set(uuid::Uuid::new_v4().to_string()),
            created_time: Set(Utc::now()),
            updated_time: Set(Utc::now()),
            ..ActiveModelTrait::default()
        }
    }

    fn before_save<C>(mut self, _db: &C, _insert: bool) -> Result<Self, DbErr>
    where
        C: ConnectionTrait,
    {
        self.updated_time = Set(Utc::now());
        Ok(self)
    }
}

impl Model {
    /// åˆ›å»ºæ–°çš„é€šé“ç‚¹ä½å®šä¹‰
    pub fn new(
        tag: String,
        variable_name: String,
        module_type: ModuleType,
        plc_communication_address: String,
        power_supply_type: PowerSupplyType,
    ) -> Self {
        Self {
            id: uuid::Uuid::new_v4().to_string(),
            tag,
            variable_name,
            module_type,
            plc_communication_address,
            power_supply_type,
            range_lower_limit: None,
            range_upper_limit: None,
            variable_description: None,
            wire_system: None,
            created_time: Utc::now(),
            updated_time: Utc::now(),
        }
    }

    /// è®¾ç½®é‡ç¨‹èŒƒå›´
    pub fn with_range(mut self, lower: f64, upper: f64) -> Self {
        self.range_lower_limit = Some(lower);
        self.range_upper_limit = Some(upper);
        self
    }

    /// è®¾ç½®æè¿°
    pub fn with_description(mut self, description: String) -> Self {
        self.variable_description = Some(description);
        self
    }

    /// è®¾ç½®æ¥çº¿åˆ¶å¼
    pub fn with_wire_system(mut self, wire_system: WireSystem) -> Self {
        self.wire_system = Some(wire_system);
        self
    }

    /// éªŒè¯æ•°æ®æœ‰æ•ˆæ€§
    pub fn validate(&self) -> Result<(), String> {
        if self.tag.is_empty() {
            return Err("æ ‡ç­¾ä¸èƒ½ä¸ºç©º".to_string());
        }

        if self.variable_name.is_empty() {
            return Err("å˜é‡åä¸èƒ½ä¸ºç©º".to_string());
        }

        if self.plc_communication_address.is_empty() {
            return Err("PLCé€šä¿¡åœ°å€ä¸èƒ½ä¸ºç©º".to_string());
        }

        // æ¨¡æ‹Ÿé‡ç±»å‹å¿…é¡»æœ‰é‡ç¨‹
        if self.module_type.is_analog() {
            if self.range_lower_limit.is_none() || self.range_upper_limit.is_none() {
                return Err("æ¨¡æ‹Ÿé‡ç±»å‹å¿…é¡»è®¾ç½®é‡ç¨‹èŒƒå›´".to_string());
            }

            let lower = self.range_lower_limit.unwrap();
            let upper = self.range_upper_limit.unwrap();
            if lower >= upper {
                return Err("é‡ç¨‹ä¸‹é™å¿…é¡»å°äºä¸Šé™".to_string());
            }
        }

        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_channel_point_definition_creation() {
        let definition = Model::new(
            "AI_001".to_string(),
            "Temperature_01".to_string(),
            ModuleType::AI,
            "40001".to_string(),
            PowerSupplyType::Active,
        );

        assert_eq!(definition.tag, "AI_001");
        assert_eq!(definition.module_type, ModuleType::AI);
        assert!(!definition.id.is_empty());
    }

    #[test]
    fn test_validation() {
        let mut definition = Model::new(
            "AI_001".to_string(),
            "Temperature_01".to_string(),
            ModuleType::AI,
            "40001".to_string(),
            PowerSupplyType::Active,
        );

        // æ¨¡æ‹Ÿé‡ç±»å‹æ²¡æœ‰é‡ç¨‹åº”è¯¥éªŒè¯å¤±è´¥
        assert!(definition.validate().is_err());

        // è®¾ç½®é‡ç¨‹ååº”è¯¥éªŒè¯æˆåŠŸ
        definition = definition.with_range(0.0, 100.0);
        assert!(definition.validate().is_ok());
    }

    #[test]
    fn test_builder_pattern() {
        let definition = Model::new(
            "AI_001".to_string(),
            "Temperature_01".to_string(),
            ModuleType::AI,
            "40001".to_string(),
            PowerSupplyType::Active,
        )
        .with_range(0.0, 100.0)
        .with_description("æ¸©åº¦ä¼ æ„Ÿå™¨".to_string())
        .with_wire_system(WireSystem::FourWire);

        assert_eq!(definition.range_lower_limit, Some(0.0));
        assert_eq!(definition.range_upper_limit, Some(100.0));
        assert_eq!(definition.variable_description, Some("æ¸©åº¦ä¼ æ„Ÿå™¨".to_string()));
        assert_eq!(definition.wire_system, Some(WireSystem::FourWire));
    }
}
```

**éªŒè¯æ£€æŸ¥ç‚¹**:
- [x] æ‰€æœ‰æšä¸¾ç±»å‹å·²å®šä¹‰å¹¶åŒ…å«ä¸šåŠ¡æ–¹æ³•
- [x] ChannelPointDefinitionå®ä½“å·²å®ç°å¹¶åŒ…å«éªŒè¯é€»è¾‘
- [x] å®ä½“å…³ç³»å·²æ­£ç¡®å®šä¹‰
- [x] å•å…ƒæµ‹è¯•è¦†ç›–æ‰€æœ‰æ ¸å¿ƒåŠŸèƒ½
- [x] Builderæ¨¡å¼å®ç°ä¾¿äºå¯¹è±¡åˆ›å»º

#### 1.3 å®ç°æ•°æ®åº“è¿ç§»
**æ‰§è¡Œå†…å®¹**:
- [x] åˆ›å»ºSeaORMè¿ç§»æ–‡ä»¶
- [x] å®ç°up/downè¿ç§»é€»è¾‘
- [x] æ·»åŠ ç´¢å¼•å’Œçº¦æŸ
- [x] åˆ›å»ºåˆå§‹åŒ–æ•°æ®è„šæœ¬

**å®æ–½ç»†èŠ‚**:
```rust
// æ–‡ä»¶: migration/src/m20241201_000001_create_channel_point_definitions.rs
use sea_orm_migration::prelude::*;

#[derive(DeriveMigrationName)]
pub struct Migration;

#[async_trait::async_trait]
impl MigrationTrait for Migration {
    async fn up(&self, manager: &SchemaManager) -> Result<(), DbErr> {
        manager
            .create_table(
                Table::create()
                    .table(ChannelPointDefinition::Table)
                    .if_not_exists()
                    .col(
                        ColumnDef::new(ChannelPointDefinition::Id)
                            .string()
                            .not_null()
                            .primary_key(),
                    )
                    .col(ColumnDef::new(ChannelPointDefinition::Tag).string().not_null())
                    .col(ColumnDef::new(ChannelPointDefinition::ModuleType).string().not_null())
                    // ... å…¶ä»–å­—æ®µ
                    .to_owned(),
            )
            .await
    }
}
```

**æµ‹è¯•æ–¹æ³•**:
```bash
# è¿è¡Œè¿ç§»æµ‹è¯•
cd FactoryTesting/src-tauri
cargo test migration_tests -- --nocapture

# éªŒè¯æ•°æ®åº“ç»“æ„
sqlite3 test.db ".schema channel_point_definitions"
```

#### 1.4 å®ç°æ•°æ®è®¿é—®å±‚
**æ‰§è¡Œå†…å®¹**:
- [x] åˆ›å»ºRepositoryæ¥å£å’Œå®ç°
- [x] å®ç°CRUDæ“ä½œ
- [x] æ·»åŠ æŸ¥è¯¢æ–¹æ³•å’Œä¸šåŠ¡é€»è¾‘
- [x] å®ç°äº‹åŠ¡æ”¯æŒ

**å®æ–½ç»†èŠ‚**:
```rust
// æ–‡ä»¶: src/infrastructure/repositories/channel_point_definition_repository.rs
#[async_trait::async_trait]
pub trait IChannelPointDefinitionRepository: Send + Sync {
    async fn find_by_id(&self, id: &str) -> Result<Option<ChannelPointDefinition>, AppError>;
    async fn find_by_module_type(&self, module_type: ModuleType) -> Result<Vec<ChannelPointDefinition>, AppError>;
    async fn save(&self, definition: &ChannelPointDefinition) -> Result<(), AppError>;
    async fn delete(&self, id: &str) -> Result<(), AppError>;
    async fn find_all_paginated(&self, page: u64, per_page: u64) -> Result<(Vec<ChannelPointDefinition>, u64), AppError>;
}

pub struct ChannelPointDefinitionRepository {
    db: DatabaseConnection,
}

impl ChannelPointDefinitionRepository {
    pub fn new(db: DatabaseConnection) -> Self {
        Self { db }
    }
}

#[async_trait::async_trait]
impl IChannelPointDefinitionRepository for ChannelPointDefinitionRepository {
    async fn find_by_id(&self, id: &str) -> Result<Option<ChannelPointDefinition>, AppError> {
        let result = ChannelPointDefinitionEntity::find_by_id(id)
            .one(&self.db)
            .await
            .map_err(|e| AppError::DatabaseError(e.to_string()))?;

        Ok(result.map(|model| model.into()))
    }

    // ... å…¶ä»–æ–¹æ³•å®ç°
}
```

**æµ‹è¯•æ–¹æ³•**:
```rust
#[tokio::test]
async fn test_repository_crud_operations() {
    let db = setup_test_database().await;
    let repo = ChannelPointDefinitionRepository::new(db);

    // æµ‹è¯•åˆ›å»º
    let definition = create_test_definition();
    repo.save(&definition).await.unwrap();

    // æµ‹è¯•æŸ¥è¯¢
    let found = repo.find_by_id(&definition.id).await.unwrap();
    assert!(found.is_some());

    // æµ‹è¯•æ›´æ–°å’Œåˆ é™¤
    // ...
}
```

### ğŸ§ª æµ‹è¯•éªŒè¯

#### å•å…ƒæµ‹è¯•
- [x] å®ä½“æ¨¡å‹åºåˆ—åŒ–/ååºåˆ—åŒ–æµ‹è¯•
- [x] æšä¸¾ç±»å‹è½¬æ¢æµ‹è¯•
- [x] Repository CRUDæ“ä½œæµ‹è¯•
- [x] æ•°æ®éªŒè¯è§„åˆ™æµ‹è¯•

#### é›†æˆæµ‹è¯•
- [x] æ•°æ®åº“è¿ç§»å®Œæ•´æ€§æµ‹è¯•
- [x] å¤šè¡¨å…³è”æŸ¥è¯¢æµ‹è¯•
- [x] äº‹åŠ¡å›æ»šæµ‹è¯•
- [x] æ€§èƒ½åŸºå‡†æµ‹è¯•

### ğŸ“Š é¢„æœŸç»“æœ
- âœ… å®Œæ•´çš„æ•°æ®æ¨¡å‹å®šä¹‰ï¼ŒåŒ…å«æ‰€æœ‰ä¸šåŠ¡å­—æ®µ
- âœ… å¯è¿è¡Œçš„æ•°æ®åº“è¿ç§»è„šæœ¬
- âœ… é«˜è´¨é‡çš„æ•°æ®è®¿é—®å±‚ï¼Œæ”¯æŒæ‰€æœ‰CRUDæ“ä½œ
- âœ… 90%ä»¥ä¸Šçš„æµ‹è¯•è¦†ç›–ç‡
- âœ… ä¸åŸC#é¡¹ç›®æ•°æ®ç»“æ„100%å…¼å®¹

---

## ğŸ”§ é˜¶æ®µäºŒï¼šæ ¸å¿ƒæœåŠ¡æ¥å£è®¾è®¡

### ğŸ“ é‡æ„åŸå› 
- å½“å‰ç¼ºå°‘æ ¸å¿ƒä¸šåŠ¡æœåŠ¡çš„æ¥å£å®šä¹‰
- éœ€è¦å»ºç«‹æ¸…æ™°çš„æœåŠ¡è¾¹ç•Œå’Œä¾èµ–å…³ç³»
- ä¸ºåç»­çš„å…·ä½“å®ç°æä¾›ç¨³å®šçš„å¥‘çº¦

### ğŸ¯ å®æ–½ç›®æ ‡
- [ ] å®šä¹‰æ‰€æœ‰æ ¸å¿ƒæœåŠ¡æ¥å£
- [ ] å»ºç«‹æœåŠ¡ä¾èµ–å…³ç³»å›¾
- [ ] å®ç°ä¾èµ–æ³¨å…¥å®¹å™¨
- [ ] åˆ›å»ºMockå®ç°ç”¨äºæµ‹è¯•

### ğŸ“‹ è¯¦ç»†å®æ–½æ­¥éª¤

#### 2.1 è®¾è®¡æœåŠ¡æ¥å£æ¶æ„
**æ‰§è¡Œå†…å®¹**:
- [ ] åˆ†æä¸šåŠ¡æµç¨‹ï¼Œè¯†åˆ«æ ¸å¿ƒæœåŠ¡
- [ ] å®šä¹‰æœåŠ¡æ¥å£å’Œæ–¹æ³•ç­¾å
- [ ] å»ºç«‹æœåŠ¡é—´çš„ä¾èµ–å…³ç³»
- [ ] è®¾è®¡é”™è¯¯å¤„ç†å’Œå¼‚å¸¸ä¼ æ’­

**è¯¦ç»†æ‰§è¡Œæ­¥éª¤**:

**æ­¥éª¤2.1.1: åˆ›å»ºæœåŠ¡æ¥å£ç›®å½•ç»“æ„**
```bash
# åœ¨ src-tauri ç›®å½•ä¸‹æ‰§è¡Œ
cd FactoryTesting/src-tauri
mkdir -p src/domain/services
mkdir -p src/domain/services/mocks
mkdir -p src/application/services
mkdir -p src/infrastructure/services
```

**æ­¥éª¤2.1.2: å®šä¹‰æ ¸å¿ƒæœåŠ¡æ¥å£æ¨¡å—**
åˆ›å»ºæ–‡ä»¶ `src/domain/services/mod.rs`:
```rust
//! é¢†åŸŸæœåŠ¡æ¥å£å®šä¹‰
//!
//! è¿™ä¸ªæ¨¡å—åŒ…å«äº†æ‰€æœ‰æ ¸å¿ƒä¸šåŠ¡æœåŠ¡çš„æ¥å£å®šä¹‰ï¼Œ
//! éµå¾ªä¾èµ–å€’ç½®åŸåˆ™ï¼Œå…·ä½“å®ç°åœ¨infrastructureå±‚

pub mod test_orchestration_service;
pub mod channel_state_manager;
pub mod test_execution_engine;
pub mod plc_communication_service;
pub mod batch_allocation_service;
pub mod event_publisher;

// é‡æ–°å¯¼å‡ºæ‰€æœ‰æ¥å£
pub use test_orchestration_service::ITestOrchestrationService;
pub use channel_state_manager::IChannelStateManager;
pub use test_execution_engine::ITestExecutionEngine;
pub use plc_communication_service::IPlcCommunicationService;
pub use batch_allocation_service::IBatchAllocationService;
pub use event_publisher::IEventPublisher;

// å¯¼å…¥å…±äº«ç±»å‹
use crate::domain::entities::*;
use crate::domain::enums::*;
use crate::infrastructure::errors::AppError;
use async_trait::async_trait;
use std::sync::Arc;
```

**æ­¥éª¤2.1.3: å®ç°æµ‹è¯•ç¼–æ’æœåŠ¡æ¥å£**
åˆ›å»ºæ–‡ä»¶ `src/domain/services/test_orchestration_service.rs`:
```rust
use super::*;
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};

/// æµ‹è¯•è¿›åº¦ä¿¡æ¯
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestProgress {
    pub batch_id: String,
    pub total_count: usize,
    pub completed_count: usize,
    pub passed_count: usize,
    pub failed_count: usize,
    pub progress_percentage: u32,
    pub estimated_remaining_time: std::time::Duration,
    pub current_stage: String,
    pub started_time: Option<DateTime<Utc>>,
    pub last_updated: DateTime<Utc>,
}

/// æµ‹è¯•æ‰¹æ¬¡ä¿¡æ¯
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestBatchInfo {
    pub batch_id: String,
    pub product_model: Option<String>,
    pub total_channels: usize,
    pub status: BatchStatus,
    pub created_time: DateTime<Utc>,
    pub started_time: Option<DateTime<Utc>>,
    pub completed_time: Option<DateTime<Utc>>,
    pub progress: Option<TestProgress>,
}

/// æ‰¹æ¬¡çŠ¶æ€æšä¸¾
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum BatchStatus {
    Created,
    Running,
    Paused,
    Completed,
    Failed,
    Cancelled,
}

/// æµ‹è¯•ç¼–æ’æœåŠ¡æ¥å£
///
/// è´Ÿè´£åè°ƒæ•´ä¸ªæµ‹è¯•æµç¨‹ï¼ŒåŒ…æ‹¬æ‰¹æ¬¡ç®¡ç†ã€æµ‹è¯•æ‰§è¡Œæ§åˆ¶ç­‰
#[async_trait]
pub trait ITestOrchestrationService: Send + Sync {
    /// åˆ›å»ºæµ‹è¯•æ‰¹æ¬¡
    ///
    /// # å‚æ•°
    /// * `product_model` - å¯é€‰çš„äº§å“å‹å·ï¼Œç”¨äºç­›é€‰æµ‹è¯•é€šé“
    ///
    /// # è¿”å›
    /// * `Ok(TestBatchInfo)` - åˆ›å»ºæˆåŠŸçš„æ‰¹æ¬¡ä¿¡æ¯
    /// * `Err(AppError)` - åˆ›å»ºå¤±è´¥çš„é”™è¯¯ä¿¡æ¯
    async fn create_test_batch(&self, product_model: Option<String>) -> Result<TestBatchInfo, AppError>;

    /// å¯åŠ¨æ‰¹æ¬¡æµ‹è¯•
    ///
    /// # å‚æ•°
    /// * `batch_id` - è¦å¯åŠ¨çš„æ‰¹æ¬¡ID
    async fn start_batch_test(&self, batch_id: &str) -> Result<(), AppError>;

    /// æš‚åœæµ‹è¯•
    ///
    /// # å‚æ•°
    /// * `batch_id` - è¦æš‚åœçš„æ‰¹æ¬¡ID
    async fn pause_test(&self, batch_id: &str) -> Result<(), AppError>;

    /// æ¢å¤æµ‹è¯•
    ///
    /// # å‚æ•°
    /// * `batch_id` - è¦æ¢å¤çš„æ‰¹æ¬¡ID
    async fn resume_test(&self, batch_id: &str) -> Result<(), AppError>;

    /// å–æ¶ˆæµ‹è¯•
    ///
    /// # å‚æ•°
    /// * `batch_id` - è¦å–æ¶ˆçš„æ‰¹æ¬¡ID
    async fn cancel_test(&self, batch_id: &str) -> Result<(), AppError>;

    /// è·å–æµ‹è¯•è¿›åº¦
    ///
    /// # å‚æ•°
    /// * `batch_id` - æ‰¹æ¬¡ID
    ///
    /// # è¿”å›
    /// å®æ—¶çš„æµ‹è¯•è¿›åº¦ä¿¡æ¯
    async fn get_test_progress(&self, batch_id: &str) -> Result<TestProgress, AppError>;

    /// è·å–æ‰€æœ‰æ‰¹æ¬¡ä¿¡æ¯
    ///
    /// # è¿”å›
    /// æ‰€æœ‰æ‰¹æ¬¡çš„ä¿¡æ¯åˆ—è¡¨ï¼ŒæŒ‰åˆ›å»ºæ—¶é—´å€’åºæ’åˆ—
    async fn get_all_batches(&self) -> Result<Vec<TestBatchInfo>, AppError>;

    /// è·å–æ‰¹æ¬¡è¯¦ç»†ä¿¡æ¯
    ///
    /// # å‚æ•°
    /// * `batch_id` - æ‰¹æ¬¡ID
    async fn get_batch_details(&self, batch_id: &str) -> Result<TestBatchInfo, AppError>;

    /// åˆ é™¤æ‰¹æ¬¡
    ///
    /// # å‚æ•°
    /// * `batch_id` - è¦åˆ é™¤çš„æ‰¹æ¬¡ID
    ///
    /// # æ³¨æ„
    /// åªèƒ½åˆ é™¤å·²å®Œæˆæˆ–å·²å–æ¶ˆçš„æ‰¹æ¬¡
    async fn delete_batch(&self, batch_id: &str) -> Result<(), AppError>;

    /// é‡æ–°è¿è¡Œå¤±è´¥çš„æµ‹è¯•
    ///
    /// # å‚æ•°
    /// * `batch_id` - æ‰¹æ¬¡ID
    async fn retry_failed_tests(&self, batch_id: &str) -> Result<(), AppError>;
}
```

**æ­¥éª¤2.1.4: å®ç°é€šé“çŠ¶æ€ç®¡ç†å™¨æ¥å£**
åˆ›å»ºæ–‡ä»¶ `src/domain/services/channel_state_manager.rs`:
```rust
use super::*;
use std::collections::HashMap;

/// çŠ¶æ€å˜æ›´äº‹ä»¶
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StateChangedEvent {
    pub instance_id: String,
    pub old_status: OverallTestStatus,
    pub new_status: OverallTestStatus,
    pub timestamp: DateTime<Utc>,
    pub batch_id: Option<String>,
    pub error_message: Option<String>,
}

/// åŸå§‹æµ‹è¯•ç»“æœ
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RawTestOutcome {
    pub test_item: SubTestItem,
    pub result: TestResult,
    pub test_values: Vec<TestValue>,
    pub error_message: Option<String>,
    pub execution_time: DateTime<Utc>,
    pub duration_ms: u64,
}

/// æµ‹è¯•å€¼è®°å½•
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestValue {
    pub step: String,
    pub expected: f64,
    pub actual: f64,
    pub tolerance: Option<f64>,
    pub passed: bool,
    pub timestamp: DateTime<Utc>,
}

/// é€šé“çŠ¶æ€ç®¡ç†å™¨æ¥å£
///
/// è´Ÿè´£ç®¡ç†é€šé“æµ‹è¯•å®ä¾‹çš„çŠ¶æ€è½¬æ¢ï¼Œæ˜¯ç³»ç»Ÿä¸­å”¯ä¸€å…è®¸ä¿®æ”¹çŠ¶æ€çš„ç»„ä»¶
/// ç¬¦åˆ FAT-CSM-001 è§„åˆ™ï¼šå”¯ä¸€çŠ¶æ€ä¿®æ”¹å…¥å£
#[async_trait]
pub trait IChannelStateManager: Send + Sync {
    /// åº”ç”¨åŸå§‹æµ‹è¯•ç»“æœ
    ///
    /// è¿™æ˜¯çŠ¶æ€ç®¡ç†å™¨çš„æ ¸å¿ƒæ–¹æ³•ï¼Œè´Ÿè´£ï¼š
    /// 1. éªŒè¯çŠ¶æ€è½¬æ¢çš„åˆæ³•æ€§
    /// 2. æ›´æ–°æµ‹è¯•å®ä¾‹çŠ¶æ€
    /// 3. æŒä¹…åŒ–çŠ¶æ€å˜æ›´
    /// 4. å‘å¸ƒçŠ¶æ€å˜æ›´äº‹ä»¶
    ///
    /// # å‚æ•°
    /// * `instance` - è¦æ›´æ–°çš„æµ‹è¯•å®ä¾‹ï¼ˆå¯å˜å¼•ç”¨ï¼‰
    /// * `outcome` - åŸå§‹æµ‹è¯•ç»“æœ
    async fn apply_raw_outcome(
        &self,
        instance: &mut ChannelTestInstance,
        outcome: RawTestOutcome,
    ) -> Result<(), AppError>;

    /// éªŒè¯çŠ¶æ€è½¬æ¢
    ///
    /// # å‚æ•°
    /// * `current_status` - å½“å‰çŠ¶æ€
    /// * `target_status` - ç›®æ ‡çŠ¶æ€
    ///
    /// # è¿”å›
    /// * `Ok(true)` - è½¬æ¢åˆæ³•
    /// * `Ok(false)` - è½¬æ¢ä¸åˆæ³•
    /// * `Err(AppError)` - éªŒè¯è¿‡ç¨‹å‡ºé”™
    async fn validate_state_transition(
        &self,
        current_status: &OverallTestStatus,
        target_status: &OverallTestStatus,
    ) -> Result<bool, AppError>;

    /// æ‰¹é‡æ›´æ–°å®ä¾‹çŠ¶æ€
    ///
    /// # å‚æ•°
    /// * `updates` - çŠ¶æ€æ›´æ–°æ˜ å°„è¡¨ (instance_id -> new_status)
    async fn batch_update_status(
        &self,
        updates: HashMap<String, OverallTestStatus>,
    ) -> Result<(), AppError>;

    /// è·å–æ‰¹æ¬¡ä¸­çš„æ‰€æœ‰å®ä¾‹
    ///
    /// # å‚æ•°
    /// * `batch_id` - æ‰¹æ¬¡ID
    async fn get_batch_instances(&self, batch_id: &str) -> Result<Vec<ChannelTestInstance>, AppError>;

    /// æ›´æ–°å®ä¾‹çŠ¶æ€ï¼ˆä¸è§¦å‘ä¸šåŠ¡é€»è¾‘ï¼‰
    ///
    /// # å‚æ•°
    /// * `instance` - è¦æ›´æ–°çš„å®ä¾‹
    async fn update_instance_status(&self, instance: &ChannelTestInstance) -> Result<(), AppError>;

    /// é‡ç½®å®ä¾‹çŠ¶æ€
    ///
    /// # å‚æ•°
    /// * `instance_id` - å®ä¾‹ID
    /// * `target_status` - ç›®æ ‡çŠ¶æ€ï¼ˆé€šå¸¸æ˜¯NotTestedï¼‰
    async fn reset_instance_status(
        &self,
        instance_id: &str,
        target_status: OverallTestStatus,
    ) -> Result<(), AppError>;

    /// è·å–çŠ¶æ€ç»Ÿè®¡ä¿¡æ¯
    ///
    /// # å‚æ•°
    /// * `batch_id` - æ‰¹æ¬¡ID
    ///
    /// # è¿”å›
    /// å„çŠ¶æ€çš„å®ä¾‹æ•°é‡ç»Ÿè®¡
    async fn get_status_statistics(&self, batch_id: &str) -> Result<HashMap<OverallTestStatus, usize>, AppError>;
}
```

**æ­¥éª¤2.1.5: å®ç°æµ‹è¯•æ‰§è¡Œå¼•æ“æ¥å£**
åˆ›å»ºæ–‡ä»¶ `src/domain/services/test_execution_engine.rs`:
```rust
use super::*;
use tokio_util::sync::CancellationToken;

/// æµ‹è¯•ä»»åŠ¡ä¿¡æ¯
#[derive(Debug, Clone)]
pub struct TestTask {
    pub task_id: String,
    pub instance_id: String,
    pub batch_id: String,
    pub priority: TaskPriority,
    pub created_time: DateTime<Utc>,
    pub estimated_duration: std::time::Duration,
}

/// ä»»åŠ¡ä¼˜å…ˆçº§
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub enum TaskPriority {
    Low = 1,
    Normal = 2,
    High = 3,
    Critical = 4,
}

/// æ‰§è¡Œç»Ÿè®¡ä¿¡æ¯
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExecutionStatistics {
    pub total_tasks: usize,
    pub completed_tasks: usize,
    pub failed_tasks: usize,
    pub average_execution_time: std::time::Duration,
    pub concurrent_tasks: usize,
    pub queue_length: usize,
}

/// æµ‹è¯•æ‰§è¡Œå¼•æ“æ¥å£
///
/// è´Ÿè´£å¹¶å‘æ‰§è¡Œæµ‹è¯•ä»»åŠ¡ï¼Œç®¡ç†ä»»åŠ¡é˜Ÿåˆ—å’Œè°ƒåº¦
#[async_trait]
pub trait ITestExecutionEngine: Send + Sync {
    /// æ‰§è¡Œæ‰¹æ¬¡æµ‹è¯•
    ///
    /// # å‚æ•°
    /// * `batch` - è¦æ‰§è¡Œçš„æµ‹è¯•æ‰¹æ¬¡
    ///
    /// # è¿”å›
    /// æ‰§è¡Œå®Œæˆåçš„ç»“æœï¼ŒåŒ…å«æˆåŠŸå’Œå¤±è´¥çš„ä»»åŠ¡æ•°é‡
    async fn execute_batch_test(&self, batch: &TestBatchInfo) -> Result<ExecutionStatistics, AppError>;

    /// æš‚åœæ‰¹æ¬¡æµ‹è¯•
    ///
    /// # å‚æ•°
    /// * `batch_id` - è¦æš‚åœçš„æ‰¹æ¬¡ID
    async fn pause_batch_test(&self, batch_id: &str) -> Result<(), AppError>;

    /// æ¢å¤æ‰¹æ¬¡æµ‹è¯•
    ///
    /// # å‚æ•°
    /// * `batch_id` - è¦æ¢å¤çš„æ‰¹æ¬¡ID
    async fn resume_batch_test(&self, batch_id: &str) -> Result<(), AppError>;

    /// å–æ¶ˆæ‰¹æ¬¡æµ‹è¯•
    ///
    /// # å‚æ•°
    /// * `batch_id` - è¦å–æ¶ˆçš„æ‰¹æ¬¡ID
    async fn cancel_batch_test(&self, batch_id: &str) -> Result<(), AppError>;

    /// è·å–æ‰¹æ¬¡è¿›åº¦
    ///
    /// # å‚æ•°
    /// * `batch_id` - æ‰¹æ¬¡ID
    async fn get_batch_progress(&self, batch_id: &str) -> Result<TestProgress, AppError>;

    /// è·å–æ‰§è¡Œç»Ÿè®¡ä¿¡æ¯
    async fn get_execution_statistics(&self) -> Result<ExecutionStatistics, AppError>;

    /// è®¾ç½®æœ€å¤§å¹¶å‘æ•°
    ///
    /// # å‚æ•°
    /// * `max_concurrency` - æœ€å¤§å¹¶å‘ä»»åŠ¡æ•°
    async fn set_max_concurrency(&self, max_concurrency: usize) -> Result<(), AppError>;

    /// æ·»åŠ ä»»åŠ¡åˆ°é˜Ÿåˆ—
    ///
    /// # å‚æ•°
    /// * `task` - è¦æ·»åŠ çš„ä»»åŠ¡
    async fn enqueue_task(&self, task: TestTask) -> Result<(), AppError>;

    /// è·å–é˜Ÿåˆ—çŠ¶æ€
    async fn get_queue_status(&self) -> Result<(usize, usize), AppError>; // (queue_length, running_tasks)
}
```

**éªŒè¯æ£€æŸ¥ç‚¹**:
- [ ] æ‰€æœ‰æœåŠ¡æ¥å£å·²å®šä¹‰å¹¶åŒ…å«å®Œæ•´çš„æ–¹æ³•ç­¾å
- [ ] æ¥å£æ–‡æ¡£æ³¨é‡Šå®Œæ•´ï¼ŒåŒ…å«å‚æ•°è¯´æ˜å’Œè¿”å›å€¼è¯´æ˜
- [ ] é”™è¯¯å¤„ç†ç»Ÿä¸€ä½¿ç”¨AppErrorç±»å‹
- [ ] æ‰€æœ‰å¼‚æ­¥æ–¹æ³•éƒ½ä½¿ç”¨async_trait
- [ ] æ•°æ®ä¼ è¾“å¯¹è±¡ï¼ˆDTOï¼‰å·²å®šä¹‰å¹¶å®ç°åºåˆ—åŒ–

#### 2.2 å®ç°ä¾èµ–æ³¨å…¥å®¹å™¨
**æ‰§è¡Œå†…å®¹**:
- [ ] é€‰æ‹©åˆé€‚çš„DIæ¡†æ¶ï¼ˆå¦‚ `shaku` æˆ–è‡ªå®šä¹‰ï¼‰
- [ ] é…ç½®æœåŠ¡æ³¨å†Œå’Œç”Ÿå‘½å‘¨æœŸ
- [ ] å®ç°æœåŠ¡è§£æå’Œæ³¨å…¥
- [ ] æ·»åŠ é…ç½®é©±åŠ¨çš„æœåŠ¡åˆ›å»º

**è¯¦ç»†æ‰§è¡Œæ­¥éª¤**:

**æ­¥éª¤2.2.1: æ·»åŠ ä¾èµ–æ³¨å…¥ç›¸å…³ä¾èµ–**
åœ¨ `Cargo.toml` ä¸­æ·»åŠ ï¼š
```toml
[dependencies]
# ä¾èµ–æ³¨å…¥æ¡†æ¶
shaku = "0.6"
# é…ç½®ç®¡ç†
config = "0.13"
# å¼‚æ­¥traitæ”¯æŒ
async-trait = "0.1"
```

**æ­¥éª¤2.2.2: åˆ›å»ºæœåŠ¡å®¹å™¨æ¥å£**
åˆ›å»ºæ–‡ä»¶ `src/infrastructure/di_container.rs`:
```rust
//! ä¾èµ–æ³¨å…¥å®¹å™¨
//!
//! è´Ÿè´£ç®¡ç†æ‰€æœ‰æœåŠ¡çš„ç”Ÿå‘½å‘¨æœŸå’Œä¾èµ–å…³ç³»

use std::sync::Arc;
use shaku::{module, Component, Interface, HasComponent};
use crate::domain::services::*;
use crate::infrastructure::errors::AppError;

/// æœåŠ¡å®¹å™¨æ¥å£
///
/// æä¾›ç»Ÿä¸€çš„æœåŠ¡è·å–æ¥å£ï¼Œéšè—å…·ä½“çš„DIå®ç°ç»†èŠ‚
pub trait ServiceContainer: Send + Sync {
    /// è·å–æµ‹è¯•ç¼–æ’æœåŠ¡
    fn get_test_orchestration_service(&self) -> Arc<dyn ITestOrchestrationService>;

    /// è·å–é€šé“çŠ¶æ€ç®¡ç†å™¨
    fn get_channel_state_manager(&self) -> Arc<dyn IChannelStateManager>;

    /// è·å–æµ‹è¯•æ‰§è¡Œå¼•æ“
    fn get_test_execution_engine(&self) -> Arc<dyn ITestExecutionEngine>;

    /// è·å–PLCé€šä¿¡æœåŠ¡
    fn get_plc_communication_service(&self) -> Arc<dyn IPlcCommunicationService>;

    /// è·å–æ‰¹æ¬¡åˆ†é…æœåŠ¡
    fn get_batch_allocation_service(&self) -> Arc<dyn IBatchAllocationService>;

    /// è·å–äº‹ä»¶å‘å¸ƒå™¨
    fn get_event_publisher(&self) -> Arc<dyn IEventPublisher>;
}

/// Shakuæ¨¡å—å®šä¹‰
///
/// å®šä¹‰æ‰€æœ‰æœåŠ¡çš„æ³¨å†Œå’Œä¾èµ–å…³ç³»
module! {
    pub AppModule {
        components = [
            TestOrchestrationServiceImpl,
            ChannelStateManagerImpl,
            TestExecutionEngineImpl,
            PlcCommunicationServiceImpl,
            BatchAllocationServiceImpl,
            EventPublisherImpl,
        ],
        providers = [
            DatabaseConnectionProvider,
            AppConfigProvider,
        ],
    }
}

/// åº”ç”¨é…ç½®æä¾›è€…
#[derive(Component)]
#[shaku(interface = AppConfig)]
pub struct AppConfigProvider;

impl AppConfig for AppConfigProvider {
    fn max_concurrent_tests(&self) -> usize {
        88 // é»˜è®¤88ä¸ªå¹¶å‘æµ‹è¯•
    }

    fn plc_timeout_ms(&self) -> u64 {
        5000 // é»˜è®¤5ç§’è¶…æ—¶
    }

    fn database_path(&self) -> String {
        "fat_test.db".to_string()
    }
}

/// æ•°æ®åº“è¿æ¥æä¾›è€…
#[derive(Component)]
#[shaku(interface = DatabaseConnection)]
pub struct DatabaseConnectionProvider {
    #[shaku(inject)]
    config: Arc<dyn AppConfig>,
}

impl DatabaseConnection for DatabaseConnectionProvider {
    async fn get_connection(&self) -> Result<sea_orm::DatabaseConnection, AppError> {
        let database_url = format!("sqlite://{}?mode=rwc", self.config.database_path());

        sea_orm::Database::connect(&database_url)
            .await
            .map_err(|e| AppError::DatabaseError(e.to_string()))
    }
}

/// æœåŠ¡å®¹å™¨å®ç°
pub struct AppServiceContainer {
    module: AppModule,
}

impl AppServiceContainer {
    /// åˆ›å»ºæ–°çš„æœåŠ¡å®¹å™¨
    pub fn new() -> Result<Self, AppError> {
        let module = AppModule::builder()
            .build()
            .map_err(|e| AppError::DependencyInjectionError(e.to_string()))?;

        Ok(Self { module })
    }

    /// ä»é…ç½®æ–‡ä»¶åˆ›å»ºæœåŠ¡å®¹å™¨
    pub fn from_config(config_path: &str) -> Result<Self, AppError> {
        // åŠ è½½é…ç½®æ–‡ä»¶
        let settings = config::Config::builder()
            .add_source(config::File::with_name(config_path))
            .build()
            .map_err(|e| AppError::ConfigurationError(e.to_string()))?;

        // ä½¿ç”¨é…ç½®åˆ›å»ºæ¨¡å—
        let module = AppModule::builder()
            .with_component_override::<dyn AppConfig>(Arc::new(ConfigBasedAppConfig::new(settings)))
            .build()
            .map_err(|e| AppError::DependencyInjectionError(e.to_string()))?;

        Ok(Self { module })
    }
}

impl ServiceContainer for AppServiceContainer {
    fn get_test_orchestration_service(&self) -> Arc<dyn ITestOrchestrationService> {
        self.module.resolve()
    }

    fn get_channel_state_manager(&self) -> Arc<dyn IChannelStateManager> {
        self.module.resolve()
    }

    fn get_test_execution_engine(&self) -> Arc<dyn ITestExecutionEngine> {
        self.module.resolve()
    }

    fn get_plc_communication_service(&self) -> Arc<dyn IPlcCommunicationService> {
        self.module.resolve()
    }

    fn get_batch_allocation_service(&self) -> Arc<dyn IBatchAllocationService> {
        self.module.resolve()
    }

    fn get_event_publisher(&self) -> Arc<dyn IEventPublisher> {
        self.module.resolve()
    }
}

/// åŸºäºé…ç½®æ–‡ä»¶çš„åº”ç”¨é…ç½®
pub struct ConfigBasedAppConfig {
    settings: config::Config,
}

impl ConfigBasedAppConfig {
    pub fn new(settings: config::Config) -> Self {
        Self { settings }
    }
}

impl AppConfig for ConfigBasedAppConfig {
    fn max_concurrent_tests(&self) -> usize {
        self.settings.get("max_concurrent_tests").unwrap_or(88)
    }

    fn plc_timeout_ms(&self) -> u64 {
        self.settings.get("plc_timeout_ms").unwrap_or(5000)
    }

    fn database_path(&self) -> String {
        self.settings.get("database_path").unwrap_or_else(|_| "fat_test.db".to_string())
    }
}
```

**æ­¥éª¤2.2.3: åˆ›å»ºåº”ç”¨é…ç½®æ¥å£**
åˆ›å»ºæ–‡ä»¶ `src/infrastructure/config.rs`:
```rust
//! åº”ç”¨é…ç½®ç®¡ç†
//!
//! å®šä¹‰åº”ç”¨ç¨‹åºçš„é…ç½®æ¥å£å’Œå®ç°

use std::path::PathBuf;

/// åº”ç”¨é…ç½®æ¥å£
pub trait AppConfig: Send + Sync {
    /// æœ€å¤§å¹¶å‘æµ‹è¯•æ•°
    fn max_concurrent_tests(&self) -> usize;

    /// PLCé€šä¿¡è¶…æ—¶æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
    fn plc_timeout_ms(&self) -> u64;

    /// æ•°æ®åº“æ–‡ä»¶è·¯å¾„
    fn database_path(&self) -> String;

    /// è·å–PLCè¿æ¥é…ç½®
    fn get_plc_config(&self) -> PlcConfig {
        PlcConfig {
            test_plc_ip: self.get_test_plc_ip(),
            test_plc_port: self.get_test_plc_port(),
            target_plc_ip: self.get_target_plc_ip(),
            target_plc_port: self.get_target_plc_port(),
            timeout_ms: self.plc_timeout_ms(),
            max_connections: self.max_concurrent_tests(),
        }
    }

    /// æµ‹è¯•PLC IPåœ°å€
    fn get_test_plc_ip(&self) -> String {
        "192.168.1.100".to_string() // é»˜è®¤å€¼
    }

    /// æµ‹è¯•PLCç«¯å£
    fn get_test_plc_port(&self) -> u16 {
        502 // Modbus TCPé»˜è®¤ç«¯å£
    }

    /// è¢«æµ‹PLC IPåœ°å€
    fn get_target_plc_ip(&self) -> String {
        "192.168.1.101".to_string() // é»˜è®¤å€¼
    }

    /// è¢«æµ‹PLCç«¯å£
    fn get_target_plc_port(&self) -> u16 {
        502 // Modbus TCPé»˜è®¤ç«¯å£
    }
}

/// PLCè¿æ¥é…ç½®
#[derive(Debug, Clone)]
pub struct PlcConfig {
    pub test_plc_ip: String,
    pub test_plc_port: u16,
    pub target_plc_ip: String,
    pub target_plc_port: u16,
    pub timeout_ms: u64,
    pub max_connections: usize,
}
```

**éªŒè¯æ£€æŸ¥ç‚¹**:
- [ ] ä¾èµ–æ³¨å…¥å®¹å™¨å·²å®ç°å¹¶å¯ä»¥æ­£å¸¸è§£ææœåŠ¡
- [ ] é…ç½®ç®¡ç†ç³»ç»Ÿå·²å»ºç«‹ï¼Œæ”¯æŒæ–‡ä»¶å’Œé»˜è®¤é…ç½®
- [ ] æœåŠ¡ç”Ÿå‘½å‘¨æœŸç®¡ç†æ­£ç¡®ï¼Œæ”¯æŒå•ä¾‹æ¨¡å¼
- [ ] å¾ªç¯ä¾èµ–æ£€æµ‹æœºåˆ¶å·²å®ç°
- [ ] é”™è¯¯å¤„ç†å®Œæ•´ï¼ŒåŒ…å«è¯¦ç»†çš„é”™è¯¯ä¿¡æ¯

#### 2.3 åˆ›å»ºMockå®ç°
**æ‰§è¡Œå†…å®¹**:
- [ ] ä¸ºæ‰€æœ‰æœåŠ¡æ¥å£åˆ›å»ºMockå®ç°
- [ ] å®ç°å¯é…ç½®çš„æµ‹è¯•è¡Œä¸º
- [ ] æ·»åŠ æµ‹è¯•æ•°æ®ç”Ÿæˆå™¨
- [ ] å»ºç«‹æµ‹è¯•åœºæ™¯æ¨¡æ¿

**è¯¦ç»†æ‰§è¡Œæ­¥éª¤**:

**æ­¥éª¤2.3.1: æ·»åŠ Mockæµ‹è¯•ä¾èµ–**
åœ¨ `Cargo.toml` ä¸­æ·»åŠ ï¼š
```toml
[dev-dependencies]
mockall = "0.11"
tokio-test = "0.4"
```

**æ­¥éª¤2.3.2: åˆ›å»ºMockæœåŠ¡å®ç°**
åˆ›å»ºæ–‡ä»¶ `src/domain/services/mocks/mod.rs`:
```rust
//! MockæœåŠ¡å®ç°
//!
//! ç”¨äºå•å…ƒæµ‹è¯•å’Œé›†æˆæµ‹è¯•çš„MockæœåŠ¡

pub mod mock_test_orchestration_service;
pub mod mock_channel_state_manager;
pub mod mock_test_execution_engine;
pub mod mock_plc_communication_service;
pub mod test_data_generator;

pub use mock_test_orchestration_service::MockTestOrchestrationService;
pub use mock_channel_state_manager::MockChannelStateManager;
pub use mock_test_execution_engine::MockTestExecutionEngine;
pub use mock_plc_communication_service::MockPlcCommunicationService;
pub use test_data_generator::TestDataGenerator;
```

**æ­¥éª¤2.3.3: å®ç°æµ‹è¯•ç¼–æ’æœåŠ¡Mock**
åˆ›å»ºæ–‡ä»¶ `src/domain/services/mocks/mock_test_orchestration_service.rs`:
```rust
use mockall::mock;
use super::super::*;
use crate::infrastructure::errors::AppError;

mock! {
    pub TestOrchestrationService {}

    #[async_trait::async_trait]
    impl ITestOrchestrationService for TestOrchestrationService {
        async fn create_test_batch(&self, product_model: Option<String>) -> Result<TestBatchInfo, AppError>;
        async fn start_batch_test(&self, batch_id: &str) -> Result<(), AppError>;
        async fn pause_test(&self, batch_id: &str) -> Result<(), AppError>;
        async fn resume_test(&self, batch_id: &str) -> Result<(), AppError>;
        async fn cancel_test(&self, batch_id: &str) -> Result<(), AppError>;
        async fn get_test_progress(&self, batch_id: &str) -> Result<TestProgress, AppError>;
        async fn get_all_batches(&self) -> Result<Vec<TestBatchInfo>, AppError>;
        async fn get_batch_details(&self, batch_id: &str) -> Result<TestBatchInfo, AppError>;
        async fn delete_batch(&self, batch_id: &str) -> Result<(), AppError>;
        async fn retry_failed_tests(&self, batch_id: &str) -> Result<(), AppError>;
    }
}

impl MockTestOrchestrationService {
    /// åˆ›å»ºä¸€ä¸ªé¢„é…ç½®çš„Mockï¼Œè¿”å›æˆåŠŸçš„æµ‹è¯•æ‰¹æ¬¡
    pub fn with_successful_batch() -> Self {
        let mut mock = MockTestOrchestrationService::new();

        mock.expect_create_test_batch()
            .returning(|_| {
                Ok(TestBatchInfo {
                    batch_id: "test_batch_001".to_string(),
                    product_model: Some("TestModel".to_string()),
                    total_channels: 88,
                    status: BatchStatus::Created,
                    created_time: chrono::Utc::now(),
                    started_time: None,
                    completed_time: None,
                    progress: None,
                })
            });

        mock.expect_start_batch_test()
            .returning(|_| Ok(()));

        mock.expect_get_test_progress()
            .returning(|_| {
                Ok(TestProgress {
                    batch_id: "test_batch_001".to_string(),
                    total_count: 88,
                    completed_count: 44,
                    passed_count: 40,
                    failed_count: 4,
                    progress_percentage: 50,
                    estimated_remaining_time: std::time::Duration::from_secs(15),
                    current_stage: "ç¡¬ç‚¹æµ‹è¯•".to_string(),
                    started_time: Some(chrono::Utc::now()),
                    last_updated: chrono::Utc::now(),
                })
            });

        mock
    }

    /// åˆ›å»ºä¸€ä¸ªæ¨¡æ‹Ÿå¤±è´¥åœºæ™¯çš„Mock
    pub fn with_failure_scenarios() -> Self {
        let mut mock = MockTestOrchestrationService::new();

        mock.expect_create_test_batch()
            .returning(|_| Err(AppError::BusinessLogicError("æ‰¹æ¬¡åˆ›å»ºå¤±è´¥".to_string())));

        mock.expect_start_batch_test()
            .returning(|_| Err(AppError::BusinessLogicError("æ‰¹æ¬¡å¯åŠ¨å¤±è´¥".to_string())));

        mock
    }
}
```

**æ­¥éª¤2.3.4: å®ç°PLCé€šä¿¡æœåŠ¡Mock**
åˆ›å»ºæ–‡ä»¶ `src/domain/services/mocks/mock_plc_communication_service.rs`:
```rust
use mockall::mock;
use super::super::*;
use crate::infrastructure::errors::AppError;

mock! {
    pub PlcCommunicationService {}

    #[async_trait::async_trait]
    impl IPlcCommunicationService for PlcCommunicationService {
        async fn connect(&self) -> Result<(), AppError>;
        async fn disconnect(&self) -> Result<(), AppError>;
        async fn read_bool(&self, address: &str) -> Result<bool, AppError>;
        async fn write_bool(&self, address: &str, value: bool) -> Result<(), AppError>;
        async fn read_f32(&self, address: &str) -> Result<f32, AppError>;
        async fn write_f32(&self, address: &str, value: f32) -> Result<(), AppError>;
        async fn read_u16(&self, address: &str) -> Result<u16, AppError>;
        async fn write_u16(&self, address: &str, value: u16) -> Result<(), AppError>;
        async fn is_connected(&self) -> bool;
        async fn get_connection_status(&self) -> ConnectionStatus;
    }
}

impl MockPlcCommunicationService {
    /// åˆ›å»ºä¸€ä¸ªæ¨¡æ‹Ÿæ­£å¸¸PLCé€šä¿¡çš„Mock
    pub fn with_normal_communication() -> Self {
        let mut mock = MockPlcCommunicationService::new();

        mock.expect_connect()
            .returning(|| Ok(()));

        mock.expect_is_connected()
            .returning(|| true);

        mock.expect_read_bool()
            .returning(|address| {
                // æ ¹æ®åœ°å€è¿”å›ä¸åŒçš„å€¼ï¼Œæ¨¡æ‹ŸçœŸå®PLCè¡Œä¸º
                match address {
                    "40001" => Ok(true),   // DIé€šé“
                    "40002" => Ok(false),  // DIé€šé“
                    _ => Ok(false),
                }
            });

        mock.expect_write_bool()
            .returning(|_, _| Ok(()));

        mock.expect_read_f32()
            .returning(|address| {
                // æ¨¡æ‹ŸAIé€šé“è¯»å–
                match address {
                    "40101" => Ok(25.5),   // æ¸©åº¦ä¼ æ„Ÿå™¨
                    "40102" => Ok(1013.2), // å‹åŠ›ä¼ æ„Ÿå™¨
                    _ => Ok(0.0),
                }
            });

        mock.expect_write_f32()
            .returning(|_, _| Ok(()));

        mock
    }

    /// åˆ›å»ºä¸€ä¸ªæ¨¡æ‹Ÿé€šä¿¡æ•…éšœçš„Mock
    pub fn with_communication_errors() -> Self {
        let mut mock = MockPlcCommunicationService::new();

        mock.expect_connect()
            .returning(|| Err(AppError::PlcCommunicationError("è¿æ¥è¶…æ—¶".to_string())));

        mock.expect_is_connected()
            .returning(|| false);

        mock.expect_read_bool()
            .returning(|_| Err(AppError::PlcCommunicationError("è¯»å–å¤±è´¥".to_string())));

        mock.expect_write_bool()
            .returning(|_, _| Err(AppError::PlcCommunicationError("å†™å…¥å¤±è´¥".to_string())));

        mock
    }
}
```

**æ­¥éª¤2.3.5: åˆ›å»ºæµ‹è¯•æ•°æ®ç”Ÿæˆå™¨**
åˆ›å»ºæ–‡ä»¶ `src/domain/services/mocks/test_data_generator.rs`:
```rust
//! æµ‹è¯•æ•°æ®ç”Ÿæˆå™¨
//!
//! ç”¨äºç”Ÿæˆå„ç§æµ‹è¯•åœºæ™¯çš„æ•°æ®

use crate::domain::entities::*;
use crate::domain::enums::*;
use chrono::{DateTime, Utc};
use std::collections::HashMap;

pub struct TestDataGenerator;

impl TestDataGenerator {
    /// ç”Ÿæˆé€šé“ç‚¹ä½å®šä¹‰åˆ—è¡¨
    pub fn generate_channel_definitions(count: usize) -> Vec<ChannelPointDefinition> {
        let mut definitions = Vec::new();

        for i in 0..count {
            let module_type = match i % 4 {
                0 => ModuleType::AI,
                1 => ModuleType::AO,
                2 => ModuleType::DI,
                3 => ModuleType::DO,
                _ => ModuleType::AI,
            };

            let definition = ChannelPointDefinition {
                id: format!("def_{:03}", i + 1),
                tag: format!("{}_{:03}",
                    match module_type {
                        ModuleType::AI => "AI",
                        ModuleType::AO => "AO",
                        ModuleType::DI => "DI",
                        ModuleType::DO => "DO",
                    },
                    i + 1
                ),
                variable_name: format!("Variable_{:03}", i + 1),
                module_type,
                plc_communication_address: format!("{}", 40001 + i),
                power_supply_type: if module_type.is_analog() {
                    PowerSupplyType::Active
                } else {
                    PowerSupplyType::Passive
                },
                range_lower_limit: if module_type.is_analog() { Some(0.0) } else { None },
                range_upper_limit: if module_type.is_analog() { Some(100.0) } else { None },
                variable_description: Some(format!("æµ‹è¯•å˜é‡ {}", i + 1)),
                wire_system: if module_type == ModuleType::AI {
                    Some(WireSystem::FourWire)
                } else {
                    None
                },
                created_time: Utc::now(),
                updated_time: Utc::now(),
            };

            definitions.push(definition);
        }

        definitions
    }

    /// ç”Ÿæˆæµ‹è¯•å®ä¾‹åˆ—è¡¨
    pub fn generate_test_instances(
        definitions: &[ChannelPointDefinition],
        batch_id: &str
    ) -> Vec<ChannelTestInstance> {
        definitions.iter().enumerate().map(|(i, def)| {
            ChannelTestInstance {
                instance_id: format!("inst_{:03}", i + 1),
                definition_id: def.id.clone(),
                overall_status: OverallTestStatus::NotTested,
                test_batch: batch_id.to_string(),
                sub_test_results: HashMap::new(),
                created_time: Utc::now(),
                updated_time: Utc::now(),
            }
        }).collect()
    }

    /// ç”Ÿæˆæµ‹è¯•æ‰¹æ¬¡ä¿¡æ¯
    pub fn generate_test_batch(channel_count: usize) -> TestBatchInfo {
        TestBatchInfo {
            batch_id: format!("batch_{}", Utc::now().timestamp()),
            product_model: Some("TestModel_V1.0".to_string()),
            total_channels: channel_count,
            status: BatchStatus::Created,
            created_time: Utc::now(),
            started_time: None,
            completed_time: None,
            progress: None,
        }
    }

    /// ç”Ÿæˆæµ‹è¯•è¿›åº¦ä¿¡æ¯
    pub fn generate_test_progress(
        batch_id: &str,
        total: usize,
        completed: usize,
        passed: usize
    ) -> TestProgress {
        TestProgress {
            batch_id: batch_id.to_string(),
            total_count: total,
            completed_count: completed,
            passed_count: passed,
            failed_count: completed - passed,
            progress_percentage: ((completed as f64 / total as f64) * 100.0) as u32,
            estimated_remaining_time: std::time::Duration::from_secs(
                ((total - completed) as u64 * 2) // å‡è®¾æ¯ä¸ªé€šé“2ç§’
            ),
            current_stage: if completed < total / 2 {
                "ç¡¬ç‚¹æµ‹è¯•".to_string()
            } else {
                "æ‰‹åŠ¨æµ‹è¯•".to_string()
            },
            started_time: Some(Utc::now() - chrono::Duration::seconds(completed as i64 * 2)),
            last_updated: Utc::now(),
        }
    }

    /// ç”ŸæˆåŸå§‹æµ‹è¯•ç»“æœ
    pub fn generate_raw_test_outcome(
        test_item: SubTestItem,
        result: TestResult
    ) -> RawTestOutcome {
        RawTestOutcome {
            test_item,
            result: result.clone(),
            test_values: vec![
                TestValue {
                    step: "åˆå§‹åŒ–".to_string(),
                    expected: 1.0,
                    actual: 1.0,
                    tolerance: Some(0.1),
                    passed: true,
                    timestamp: Utc::now(),
                },
                TestValue {
                    step: "æµ‹è¯•æ‰§è¡Œ".to_string(),
                    expected: 5.0,
                    actual: if result == TestResult::Pass { 5.0 } else { 4.5 },
                    tolerance: Some(0.2),
                    passed: result == TestResult::Pass,
                    timestamp: Utc::now(),
                },
            ],
            error_message: if result == TestResult::Fail {
                Some("æµ‹è¯•å€¼è¶…å‡ºå®¹å·®èŒƒå›´".to_string())
            } else {
                None
            },
            execution_time: Utc::now(),
            duration_ms: 1500,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generate_channel_definitions() {
        let definitions = TestDataGenerator::generate_channel_definitions(4);

        assert_eq!(definitions.len(), 4);
        assert_eq!(definitions[0].module_type, ModuleType::AI);
        assert_eq!(definitions[1].module_type, ModuleType::AO);
        assert_eq!(definitions[2].module_type, ModuleType::DI);
        assert_eq!(definitions[3].module_type, ModuleType::DO);
    }

    #[test]
    fn test_generate_test_instances() {
        let definitions = TestDataGenerator::generate_channel_definitions(2);
        let instances = TestDataGenerator::generate_test_instances(&definitions, "test_batch");

        assert_eq!(instances.len(), 2);
        assert_eq!(instances[0].test_batch, "test_batch");
        assert_eq!(instances[0].overall_status, OverallTestStatus::NotTested);
    }

    #[test]
    fn test_generate_test_progress() {
        let progress = TestDataGenerator::generate_test_progress("batch_001", 100, 50, 45);

        assert_eq!(progress.total_count, 100);
        assert_eq!(progress.completed_count, 50);
        assert_eq!(progress.passed_count, 45);
        assert_eq!(progress.failed_count, 5);
        assert_eq!(progress.progress_percentage, 50);
    }
}
```

**éªŒè¯æ£€æŸ¥ç‚¹**:
- [ ] æ‰€æœ‰æœåŠ¡æ¥å£éƒ½æœ‰å¯¹åº”çš„Mockå®ç°
- [ ] Mockå®ç°æ”¯æŒå¤šç§æµ‹è¯•åœºæ™¯ï¼ˆæˆåŠŸã€å¤±è´¥ã€å¼‚å¸¸ï¼‰
- [ ] æµ‹è¯•æ•°æ®ç”Ÿæˆå™¨å¯ä»¥ç”Ÿæˆå®Œæ•´çš„æµ‹è¯•æ•°æ®é›†
- [ ] MockæœåŠ¡å¯ä»¥æ¨¡æ‹ŸçœŸå®çš„ä¸šåŠ¡é€»è¾‘è¡Œä¸º
- [ ] å•å…ƒæµ‹è¯•éªŒè¯Mockå®ç°çš„æ­£ç¡®æ€§

### ğŸ§ª æµ‹è¯•éªŒè¯

#### æ¥å£å¥‘çº¦æµ‹è¯•
- [ ] æœåŠ¡æ¥å£æ–¹æ³•ç­¾åéªŒè¯
- [ ] é”™è¯¯å¤„ç†è¡Œä¸ºæµ‹è¯•
- [ ] å¼‚æ­¥æ“ä½œè¶…æ—¶æµ‹è¯•
- [ ] å¹¶å‘è®¿é—®å®‰å…¨æ€§æµ‹è¯•

#### ä¾èµ–æ³¨å…¥æµ‹è¯•
- [ ] æœåŠ¡æ³¨å†Œå’Œè§£ææµ‹è¯•
- [ ] å¾ªç¯ä¾èµ–æ£€æµ‹æµ‹è¯•
- [ ] ç”Ÿå‘½å‘¨æœŸç®¡ç†æµ‹è¯•
- [ ] é…ç½®é©±åŠ¨åˆ›å»ºæµ‹è¯•

### ğŸ“Š é¢„æœŸç»“æœ
- âœ… å®Œæ•´çš„æœåŠ¡æ¥å£å®šä¹‰ï¼Œè¦†ç›–æ‰€æœ‰æ ¸å¿ƒä¸šåŠ¡
- âœ… å¯å·¥ä½œçš„ä¾èµ–æ³¨å…¥å®¹å™¨
- âœ… æ¸…æ™°çš„æœåŠ¡ä¾èµ–å…³ç³»å›¾
- âœ… Mockå®ç°æ”¯æŒå•å…ƒæµ‹è¯•
- âœ… ç¨³å®šçš„æœåŠ¡å¥‘çº¦ï¼Œæ”¯æŒå¹¶è¡Œå¼€å‘

---

## âš™ï¸ é˜¶æ®µä¸‰ï¼šPLCé€šä¿¡æœåŠ¡å®ç°

### ğŸ“ é‡æ„åŸå› 
- å½“å‰PLCé€šä¿¡åŠŸèƒ½ä¸å®Œæ•´ï¼Œä»…æœ‰åŸºç¡€æ¡†æ¶
- éœ€è¦å®ç°å®Œæ•´çš„Modbus TCPåè®®æ”¯æŒ
- éœ€è¦å»ºç«‹ç¨³å®šå¯é çš„PLCè¿æ¥ç®¡ç†
- å¿…é¡»æ”¯æŒé«˜å¹¶å‘çš„è¯»å†™æ“ä½œ

### ğŸ¯ å®æ–½ç›®æ ‡
- [ ] å®ç°å®Œæ•´çš„Modbus TCPé€šä¿¡åŠŸèƒ½
- [ ] å»ºç«‹è¿æ¥æ± å’Œé‡è¿æœºåˆ¶
- [ ] å®ç°è¯»å†™æ“ä½œçš„é”™è¯¯å¤„ç†å’Œé‡è¯•
- [ ] æ·»åŠ é€šä¿¡çŠ¶æ€ç›‘æ§å’Œè¯Šæ–­
- [ ] æ”¯æŒ88ä¸ªå¹¶å‘é€šé“çš„é€šä¿¡éœ€æ±‚

### ğŸ“‹ è¯¦ç»†å®æ–½æ­¥éª¤

#### 3.1 å®ç°Modbus TCPå®¢æˆ·ç«¯
**æ‰§è¡Œå†…å®¹**:
- [ ] é›†æˆ `tokio-modbus` åº“
- [ ] å®ç°åŸºç¡€çš„è¯»å†™æ“ä½œ
- [ ] æ·»åŠ è¿æ¥ç®¡ç†å’Œé‡è¿é€»è¾‘
- [ ] å®ç°åœ°å€è§£æå’Œæ•°æ®ç±»å‹è½¬æ¢

**è¯¦ç»†æ‰§è¡Œæ­¥éª¤**:

**æ­¥éª¤3.1.1: æ·»åŠ Modbusç›¸å…³ä¾èµ–**
åœ¨ `Cargo.toml` ä¸­æ·»åŠ ï¼š
```toml
[dependencies]
# PLCé€šä¿¡åº“
tokio-modbus = "0.7"
modbus = "1.0"
tokio-util = "0.7"
# ç½‘ç»œå’Œå¼‚æ­¥æ”¯æŒ
tokio = { version = "1.0", features = ["full"] }
# æ•°æ®è½¬æ¢
byteorder = "1.4"
# é‡è¯•æœºåˆ¶
tokio-retry = "0.3"
```

**æ­¥éª¤3.1.2: åˆ›å»ºModbuså®¢æˆ·ç«¯åŸºç¡€ç»“æ„**
åˆ›å»ºæ–‡ä»¶ `src/infrastructure/plc/modbus_client.rs`:
```rust
use tokio_modbus::prelude::*;
use std::net::SocketAddr;
use std::time::Duration;
use tokio::time::timeout;
use tokio_retry::{strategy::FixedInterval, Retry};
use byteorder::{BigEndian, LittleEndian, ReadBytesExt, WriteBytesExt};
use crate::infrastructure::errors::AppError;

/// Modbus TCPå®¢æˆ·ç«¯
///
/// æä¾›å¯¹PLCçš„Modbus TCPé€šä¿¡åŠŸèƒ½ï¼Œæ”¯æŒï¼š
/// - è‡ªåŠ¨é‡è¿æœºåˆ¶
/// - è¶…æ—¶æ§åˆ¶
/// - æ•°æ®ç±»å‹è½¬æ¢
/// - é”™è¯¯é‡è¯•
pub struct ModbusClient {
    /// Modbusä¸Šä¸‹æ–‡
    context: Option<Context>,
    /// æœåŠ¡å™¨åœ°å€
    address: SocketAddr,
    /// è¿æ¥è¶…æ—¶æ—¶é—´
    timeout_duration: Duration,
    /// é‡è¯•ç­–ç•¥
    retry_strategy: FixedInterval,
    /// è¿æ¥çŠ¶æ€
    is_connected: bool,
    /// æœ€åä¸€æ¬¡é”™è¯¯
    last_error: Option<String>,
}

impl ModbusClient {
    /// åˆ›å»ºæ–°çš„Modbuså®¢æˆ·ç«¯
    pub fn new(ip: &str, port: u16, timeout_ms: u64) -> Result<Self, AppError> {
        let address = format!("{}:{}", ip, port)
            .parse()
            .map_err(|e| AppError::PlcCommunicationError(format!("æ— æ•ˆåœ°å€ {}:{}: {}", ip, port, e)))?;

        Ok(Self {
            context: None,
            address,
            timeout_duration: Duration::from_millis(timeout_ms),
            retry_strategy: FixedInterval::from_millis(1000).take(3),
            is_connected: false,
            last_error: None,
        })
    }

    /// è¿æ¥åˆ°PLC
    pub async fn connect(&mut self) -> Result<(), AppError> {
        let connect_future = async {
            let socket = tokio::net::TcpStream::connect(self.address).await
                .map_err(|e| AppError::PlcCommunicationError(format!("TCPè¿æ¥å¤±è´¥: {}", e)))?;

            let context = tcp::connect(socket).await
                .map_err(|e| AppError::PlcCommunicationError(format!("Modbusè¿æ¥å¤±è´¥: {}", e)))?;

            self.context = Some(context);
            self.is_connected = true;
            self.last_error = None;

            log::info!("æˆåŠŸè¿æ¥åˆ°PLC: {}", self.address);
            Ok(())
        };

        timeout(self.timeout_duration, connect_future)
            .await
            .map_err(|_| AppError::PlcCommunicationError("è¿æ¥è¶…æ—¶".to_string()))?
    }
}
```

**æ­¥éª¤3.1.3: å®ç°æ•°æ®è¯»å†™æ“ä½œ**
ç»§ç»­åœ¨ `modbus_client.rs` ä¸­æ·»åŠ ï¼š
```rust
impl ModbusClient {
    /// è¯»å–ä¿æŒå¯„å­˜å™¨
    pub async fn read_holding_registers(&mut self, address: u16, count: u16) -> Result<Vec<u16>, AppError> {
        self.execute_with_retry(|context| {
            Box::pin(async move {
                context.read_holding_registers(address, count).await
            })
        }).await
    }

    /// å†™å…¥å•ä¸ªä¿æŒå¯„å­˜å™¨
    pub async fn write_single_register(&mut self, address: u16, value: u16) -> Result<(), AppError> {
        self.execute_with_retry(|context| {
            Box::pin(async move {
                context.write_single_register(address, value).await
            })
        }).await
    }

    /// è¯»å–çº¿åœˆçŠ¶æ€
    pub async fn read_coils(&mut self, address: u16, count: u16) -> Result<Vec<bool>, AppError> {
        self.execute_with_retry(|context| {
            Box::pin(async move {
                context.read_coils(address, count).await
            })
        }).await
    }

    /// å†™å…¥å•ä¸ªçº¿åœˆ
    pub async fn write_single_coil(&mut self, address: u16, value: bool) -> Result<(), AppError> {
        self.execute_with_retry(|context| {
            Box::pin(async move {
                context.write_single_coil(address, value).await
            })
        }).await
    }

    /// å¸¦é‡è¯•çš„æ“ä½œæ‰§è¡Œ
    async fn execute_with_retry<F, T>(&mut self, operation: F) -> Result<T, AppError>
    where
        F: Fn(&mut Context) -> std::pin::Pin<Box<dyn std::future::Future<Output = Result<T, tokio_modbus::Error>> + Send + '_>>,
    {
        if !self.is_connected() {
            self.connect().await?;
        }

        let retry_strategy = FixedInterval::from_millis(1000).take(3);

        Retry::spawn(retry_strategy, || async {
            let context = self.context.as_mut()
                .ok_or_else(|| AppError::PlcCommunicationError("æœªè¿æ¥".to_string()))?;

            let operation_future = operation(context);

            match timeout(self.timeout_duration, operation_future).await {
                Ok(Ok(result)) => {
                    self.last_error = None;
                    Ok(result)
                }
                Ok(Err(e)) => {
                    let error_msg = format!("Modbusæ“ä½œå¤±è´¥: {}", e);
                    self.last_error = Some(error_msg.clone());
                    self.is_connected = false;
                    Err(AppError::PlcCommunicationError(error_msg))
                }
                Err(_) => {
                    let error_msg = "æ“ä½œè¶…æ—¶".to_string();
                    self.last_error = Some(error_msg.clone());
                    self.is_connected = false;
                    Err(AppError::PlcCommunicationError(error_msg))
                }
            }
        }).await
    }
}
```

**éªŒè¯æ£€æŸ¥ç‚¹**:
- [ ] Modbuså®¢æˆ·ç«¯å¯ä»¥æˆåŠŸè¿æ¥åˆ°PLC
- [ ] æ”¯æŒæ‰€æœ‰åŸºç¡€çš„ModbusåŠŸèƒ½ç 
- [ ] è‡ªåŠ¨é‡è¿æœºåˆ¶å·¥ä½œæ­£å¸¸
- [ ] è¶…æ—¶æ§åˆ¶æœ‰æ•ˆ
- [ ] é”™è¯¯å¤„ç†å®Œæ•´

#### 3.2 å®ç°è¿æ¥æ± ç®¡ç†
**æ‰§è¡Œå†…å®¹**:
- [ ] è®¾è®¡è¿æ¥æ± æ¶æ„
- [ ] å®ç°è¿æ¥çš„åˆ›å»ºã€å¤ç”¨å’Œé”€æ¯
- [ ] æ·»åŠ è¿æ¥å¥åº·æ£€æŸ¥
- [ ] å®ç°è¿æ¥è¶…æ—¶å’Œé‡è¯•æœºåˆ¶

**è¯¦ç»†æ‰§è¡Œæ­¥éª¤**:

**æ­¥éª¤3.2.1: åˆ›å»ºè¿æ¥æ± é…ç½®ç»“æ„**
åˆ›å»ºæ–‡ä»¶ `src/infrastructure/plc/connection_pool_config.rs`:
```rust
use std::time::Duration;
use serde::{Deserialize, Serialize};

/// è¿æ¥æ± é…ç½®
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ConnectionPoolConfig {
    /// æœ€å¤§è¿æ¥æ•°
    pub max_connections: usize,
    /// æœ€å°è¿æ¥æ•°
    pub min_connections: usize,
    /// è¿æ¥è¶…æ—¶æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
    pub connection_timeout_ms: u64,
    /// ç©ºé—²è¿æ¥è¶…æ—¶æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
    pub idle_timeout_ms: u64,
    /// å¥åº·æ£€æŸ¥é—´éš”ï¼ˆæ¯«ç§’ï¼‰
    pub health_check_interval_ms: u64,
    /// é‡è¯•æ¬¡æ•°
    pub max_retries: u32,
    /// é‡è¯•é—´éš”ï¼ˆæ¯«ç§’ï¼‰
    pub retry_interval_ms: u64,
}

impl Default for ConnectionPoolConfig {
    fn default() -> Self {
        Self {
            max_connections: 88,  // æ”¯æŒ88ä¸ªå¹¶å‘é€šé“
            min_connections: 5,   // æœ€å°‘ä¿æŒ5ä¸ªè¿æ¥
            connection_timeout_ms: 5000,
            idle_timeout_ms: 300000, // 5åˆ†é’Ÿç©ºé—²è¶…æ—¶
            health_check_interval_ms: 30000, // 30ç§’å¥åº·æ£€æŸ¥
            max_retries: 3,
            retry_interval_ms: 1000,
        }
    }
}

impl ConnectionPoolConfig {
    pub fn connection_timeout(&self) -> Duration {
        Duration::from_millis(self.connection_timeout_ms)
    }

    pub fn idle_timeout(&self) -> Duration {
        Duration::from_millis(self.idle_timeout_ms)
    }

    pub fn health_check_interval(&self) -> Duration {
        Duration::from_millis(self.health_check_interval_ms)
    }

    pub fn retry_interval(&self) -> Duration {
        Duration::from_millis(self.retry_interval_ms)
    }
}
```

**æ­¥éª¤3.2.2: å®ç°è¿æ¥æ± æ ¸å¿ƒç»“æ„**
åˆ›å»ºæ–‡ä»¶ `src/infrastructure/plc/modbus_connection_pool.rs`:
```rust
use std::collections::VecDeque;
use std::sync::atomic::{AtomicUsize, Ordering};
use std::sync::Arc;
use std::time::{Duration, Instant};
use tokio::sync::{Mutex, Semaphore};
use tokio::time::{interval, timeout};
use tokio_util::sync::CancellationToken;
use super::modbus_client::ModbusClient;
use super::connection_pool_config::ConnectionPoolConfig;
use crate::infrastructure::errors::AppError;

/// è¿æ¥åŒ…è£…å™¨ï¼ŒåŒ…å«è¿æ¥å’Œå…ƒæ•°æ®
#[derive(Debug)]
struct PooledConnection {
    client: ModbusClient,
    created_at: Instant,
    last_used: Instant,
    use_count: u64,
}

impl PooledConnection {
    fn new(client: ModbusClient) -> Self {
        let now = Instant::now();
        Self {
            client,
            created_at: now,
            last_used: now,
            use_count: 0,
        }
    }

    fn is_idle_timeout(&self, timeout: Duration) -> bool {
        self.last_used.elapsed() > timeout
    }

    fn mark_used(&mut self) {
        self.last_used = Instant::now();
        self.use_count += 1;
    }
}

/// Modbusè¿æ¥æ± 
pub struct ModbusConnectionPool {
    /// å¯ç”¨è¿æ¥é˜Ÿåˆ—
    available_connections: Arc<Mutex<VecDeque<PooledConnection>>>,
    /// é…ç½®ä¿¡æ¯
    config: ConnectionPoolConfig,
    /// PLCè¿æ¥ä¿¡æ¯
    plc_ip: String,
    plc_port: u16,
    /// å½“å‰è¿æ¥æ•°è®¡æ•°å™¨
    current_connections: Arc<AtomicUsize>,
    /// å¹¶å‘æ§åˆ¶ä¿¡å·é‡
    semaphore: Arc<Semaphore>,
    /// å–æ¶ˆä»¤ç‰Œ
    cancellation_token: CancellationToken,
    /// å¥åº·æ£€æŸ¥ä»»åŠ¡å¥æŸ„
    health_check_handle: Option<tokio::task::JoinHandle<()>>,
}

impl ModbusConnectionPool {
    /// åˆ›å»ºæ–°çš„è¿æ¥æ± 
    pub async fn new(
        plc_ip: String,
        plc_port: u16,
        config: ConnectionPoolConfig,
    ) -> Result<Self, AppError> {
        let semaphore = Arc::new(Semaphore::new(config.max_connections));
        let cancellation_token = CancellationToken::new();

        let pool = Self {
            available_connections: Arc::new(Mutex::new(VecDeque::new())),
            config: config.clone(),
            plc_ip,
            plc_port,
            current_connections: Arc::new(AtomicUsize::new(0)),
            semaphore,
            cancellation_token: cancellation_token.clone(),
            health_check_handle: None,
        };

        // é¢„åˆ›å»ºæœ€å°è¿æ¥æ•°
        pool.ensure_min_connections().await?;

        // å¯åŠ¨å¥åº·æ£€æŸ¥ä»»åŠ¡
        let health_check_handle = pool.start_health_check_task().await;

        Ok(Self {
            health_check_handle: Some(health_check_handle),
            ..pool
        })
    }

    /// è·å–è¿æ¥
    pub async fn get_connection(&self) -> Result<ModbusClient, AppError> {
        // è·å–ä¿¡å·é‡è®¸å¯
        let _permit = self.semaphore.acquire().await
            .map_err(|e| AppError::PlcCommunicationError(format!("è·å–è¿æ¥è®¸å¯å¤±è´¥: {}", e)))?;

        // å°è¯•ä»æ± ä¸­è·å–å¯ç”¨è¿æ¥
        {
            let mut available = self.available_connections.lock().await;
            if let Some(mut pooled_conn) = available.pop_front() {
                // æ£€æŸ¥è¿æ¥æ˜¯å¦ä»ç„¶æœ‰æ•ˆ
                if pooled_conn.client.is_connected() {
                    pooled_conn.mark_used();
                    log::debug!("ä»è¿æ¥æ± è·å–è¿æ¥ï¼Œå½“å‰æ± å¤§å°: {}", available.len());
                    return Ok(pooled_conn.client);
                } else {
                    // è¿æ¥å·²æ–­å¼€ï¼Œå‡å°‘è®¡æ•°å™¨
                    self.current_connections.fetch_sub(1, Ordering::Relaxed);
                }
            }
        }

        // æ± ä¸­æ²¡æœ‰å¯ç”¨è¿æ¥ï¼Œåˆ›å»ºæ–°è¿æ¥
        self.create_new_connection().await
    }

    /// å½’è¿˜è¿æ¥åˆ°æ± ä¸­
    pub async fn return_connection(&self, mut client: ModbusClient) -> Result<(), AppError> {
        // æ£€æŸ¥è¿æ¥æ˜¯å¦ä»ç„¶æœ‰æ•ˆ
        if !client.is_connected() {
            // è¿æ¥å·²æ–­å¼€ï¼Œå‡å°‘è®¡æ•°å™¨
            self.current_connections.fetch_sub(1, Ordering::Relaxed);
            return Ok(());
        }

        let pooled_conn = PooledConnection::new(client);

        {
            let mut available = self.available_connections.lock().await;
            available.push_back(pooled_conn);
            log::debug!("è¿æ¥å·²å½’è¿˜åˆ°æ± ä¸­ï¼Œå½“å‰æ± å¤§å°: {}", available.len());
        }

        Ok(())
    }

    /// åˆ›å»ºæ–°è¿æ¥
    async fn create_new_connection(&self) -> Result<ModbusClient, AppError> {
        let current_count = self.current_connections.load(Ordering::Relaxed);

        if current_count >= self.config.max_connections {
            return Err(AppError::PlcCommunicationError("è¿æ¥æ± å·²æ»¡".to_string()));
        }

        let mut client = ModbusClient::new(
            &self.plc_ip,
            self.plc_port,
            self.config.connection_timeout_ms,
        )?;

        // ä½¿ç”¨è¶…æ—¶è¿æ¥
        timeout(self.config.connection_timeout(), client.connect())
            .await
            .map_err(|_| AppError::PlcCommunicationError("è¿æ¥è¶…æ—¶".to_string()))??;

        self.current_connections.fetch_add(1, Ordering::Relaxed);

        log::info!("åˆ›å»ºæ–°PLCè¿æ¥ï¼Œå½“å‰è¿æ¥æ•°: {}",
                  self.current_connections.load(Ordering::Relaxed));

        Ok(client)
    }

    /// ç¡®ä¿æœ€å°è¿æ¥æ•°
    async fn ensure_min_connections(&self) -> Result<(), AppError> {
        let current_count = self.current_connections.load(Ordering::Relaxed);

        if current_count < self.config.min_connections {
            let needed = self.config.min_connections - current_count;

            for _ in 0..needed {
                match self.create_new_connection().await {
                    Ok(client) => {
                        self.return_connection(client).await?;
                    }
                    Err(e) => {
                        log::warn!("é¢„åˆ›å»ºè¿æ¥å¤±è´¥: {}", e);
                        break;
                    }
                }
            }
        }

        Ok(())
    }
}
```

**æ­¥éª¤3.2.3: å®ç°å¥åº·æ£€æŸ¥æœºåˆ¶**
ç»§ç»­åœ¨ `modbus_connection_pool.rs` ä¸­æ·»åŠ ï¼š
```rust
impl ModbusConnectionPool {
    /// å¯åŠ¨å¥åº·æ£€æŸ¥ä»»åŠ¡
    async fn start_health_check_task(&self) -> tokio::task::JoinHandle<()> {
        let available_connections = self.available_connections.clone();
        let current_connections = self.current_connections.clone();
        let config = self.config.clone();
        let cancellation_token = self.cancellation_token.clone();

        tokio::spawn(async move {
            let mut interval = interval(config.health_check_interval());

            loop {
                tokio::select! {
                    _ = interval.tick() => {
                        Self::perform_health_check(
                            &available_connections,
                            &current_connections,
                            &config,
                        ).await;
                    }
                    _ = cancellation_token.cancelled() => {
                        log::info!("å¥åº·æ£€æŸ¥ä»»åŠ¡å·²å–æ¶ˆ");
                        break;
                    }
                }
            }
        })
    }

    /// æ‰§è¡Œå¥åº·æ£€æŸ¥
    async fn perform_health_check(
        available_connections: &Arc<Mutex<VecDeque<PooledConnection>>>,
        current_connections: &Arc<AtomicUsize>,
        config: &ConnectionPoolConfig,
    ) {
        let mut available = available_connections.lock().await;
        let mut removed_count = 0;

        // ç§»é™¤ç©ºé—²è¶…æ—¶çš„è¿æ¥
        available.retain(|conn| {
            if conn.is_idle_timeout(config.idle_timeout()) || !conn.client.is_connected() {
                removed_count += 1;
                false
            } else {
                true
            }
        });

        if removed_count > 0 {
            current_connections.fetch_sub(removed_count, Ordering::Relaxed);
            log::info!("å¥åº·æ£€æŸ¥ç§»é™¤äº† {} ä¸ªæ— æ•ˆè¿æ¥", removed_count);
        }

        log::debug!("å¥åº·æ£€æŸ¥å®Œæˆï¼Œå½“å‰å¯ç”¨è¿æ¥: {}, æ€»è¿æ¥æ•°: {}",
                   available.len(),
                   current_connections.load(Ordering::Relaxed));
    }

    /// è·å–è¿æ¥æ± ç»Ÿè®¡ä¿¡æ¯
    pub async fn get_statistics(&self) -> ConnectionPoolStatistics {
        let available = self.available_connections.lock().await;
        let total_connections = self.current_connections.load(Ordering::Relaxed);
        let available_connections = available.len();
        let active_connections = total_connections - available_connections;

        ConnectionPoolStatistics {
            total_connections,
            available_connections,
            active_connections,
            max_connections: self.config.max_connections,
            min_connections: self.config.min_connections,
        }
    }
}

/// è¿æ¥æ± ç»Ÿè®¡ä¿¡æ¯
#[derive(Debug, Clone)]
pub struct ConnectionPoolStatistics {
    pub total_connections: usize,
    pub available_connections: usize,
    pub active_connections: usize,
    pub max_connections: usize,
    pub min_connections: usize,
}

impl Drop for ModbusConnectionPool {
    fn drop(&mut self) {
        // å–æ¶ˆå¥åº·æ£€æŸ¥ä»»åŠ¡
        self.cancellation_token.cancel();

        if let Some(handle) = self.health_check_handle.take() {
            handle.abort();
        }
    }
}
```

**éªŒè¯æ£€æŸ¥ç‚¹**:
- [ ] è¿æ¥æ± å¯ä»¥æ­£ç¡®åˆ›å»ºå’Œç®¡ç†è¿æ¥
- [ ] æ”¯æŒ88ä¸ªå¹¶å‘è¿æ¥çš„éœ€æ±‚
- [ ] å¥åº·æ£€æŸ¥æœºåˆ¶æ­£å¸¸å·¥ä½œ
- [ ] è¿æ¥è¶…æ—¶å’Œé‡è¯•æœºåˆ¶æœ‰æ•ˆ
- [ ] è¿æ¥æ± ç»Ÿè®¡ä¿¡æ¯å‡†ç¡®

#### 3.3 å®ç°é«˜çº§é€šä¿¡åŠŸèƒ½
**æ‰§è¡Œå†…å®¹**:
- [ ] å®ç°æ•°æ®ç±»å‹è½¬æ¢ï¼ˆf32, boolç­‰ï¼‰
- [ ] æ·»åŠ æ‰¹é‡è¯»å†™æ“ä½œ
- [ ] å®ç°é€šä¿¡é‡è¯•å’Œé”™è¯¯æ¢å¤
- [ ] æ·»åŠ é€šä¿¡æ€§èƒ½ç›‘æ§

**å®æ–½ç»†èŠ‚**:
```rust
// æ–‡ä»¶: src/infrastructure/plc/plc_communication_service.rs
#[async_trait::async_trait]
impl IPlcCommunicationService for PlcCommunicationServiceImpl {
    async fn connect(&self) -> Result<(), AppError> {
        let mut pool = self.connection_pool.lock().await;
        // é¢„çƒ­è¿æ¥æ± 
        for _ in 0..self.config.initial_connections {
            let client = pool.get_connection().await?;
            pool.return_connection(client).await;
        }

        // æ›´æ–°è¿æ¥çŠ¶æ€
        let mut state = self.connection_state.lock().await;
        *state = ConnectionState::Connected;

        Ok(())
    }

    async fn read_bool(&self, address: &str) -> Result<bool, AppError> {
        let parsed_address = self.parse_address(address)?;
        let pool = self.connection_pool.lock().await;
        let mut client = pool.get_connection().await?;

        let result = match parsed_address.register_type {
            RegisterType::Coil => {
                let values = client.read_coils(parsed_address.address, 1).await?;
                values.first().copied().unwrap_or(false)
            },
            RegisterType::DiscreteInput => {
                let values = client.read_discrete_inputs(parsed_address.address, 1).await?;
                values.first().copied().unwrap_or(false)
            },
            _ => return Err(AppError::PlcCommunicationError("Invalid register type for bool".to_string())),
        };

        pool.return_connection(client).await;
        Ok(result)
    }

    async fn write_f32(&self, address: &str, value: f32) -> Result<(), AppError> {
        let parsed_address = self.parse_address(address)?;
        let pool = self.connection_pool.lock().await;
        let mut client = pool.get_connection().await?;

        // å°†f32è½¬æ¢ä¸ºä¸¤ä¸ªu16å¯„å­˜å™¨
        let bytes = value.to_be_bytes();
        let high_register = u16::from_be_bytes([bytes[0], bytes[1]]);
        let low_register = u16::from_be_bytes([bytes[2], bytes[3]]);

        client.write_multiple_registers(parsed_address.address, &[high_register, low_register]).await?;

        pool.return_connection(client).await;
        Ok(())
    }
}
```

### ğŸ§ª æµ‹è¯•éªŒè¯

#### å•å…ƒæµ‹è¯•
- [ ] Modbuså®¢æˆ·ç«¯è¿æ¥æµ‹è¯•
- [ ] æ•°æ®ç±»å‹è½¬æ¢æµ‹è¯•
- [ ] åœ°å€è§£ææµ‹è¯•
- [ ] é”™è¯¯å¤„ç†æµ‹è¯•

#### é›†æˆæµ‹è¯•
- [ ] è¿æ¥æ± å¹¶å‘æµ‹è¯•
- [ ] å®é™…PLCé€šä¿¡æµ‹è¯•
- [ ] ç½‘ç»œå¼‚å¸¸æ¢å¤æµ‹è¯•
- [ ] æ€§èƒ½å‹åŠ›æµ‹è¯•

#### æ€§èƒ½æµ‹è¯•
- [ ] 88ä¸ªå¹¶å‘è¿æ¥æµ‹è¯•
- [ ] è¯»å†™æ“ä½œå»¶è¿Ÿæµ‹è¯•
- [ ] è¿æ¥æ± æ•ˆç‡æµ‹è¯•
- [ ] å†…å­˜ä½¿ç”¨ç›‘æ§

### ğŸ“Š é¢„æœŸç»“æœ
- âœ… ç¨³å®šçš„Modbus TCPé€šä¿¡åŠŸèƒ½ï¼Œæ”¯æŒæ‰€æœ‰æ•°æ®ç±»å‹
- âœ… é«˜æ•ˆçš„è¿æ¥æ± ç®¡ç†ï¼Œæ”¯æŒ88ä¸ªå¹¶å‘è¿æ¥
- âœ… å®Œå–„çš„é”™è¯¯å¤„ç†å’Œé‡è¯•æœºåˆ¶
- âœ… å®æ—¶çš„è¿æ¥çŠ¶æ€ç›‘æ§å’Œè¯Šæ–­
- âœ… æ»¡è¶³30ç§’æµ‹è¯•æ—¶é—´è¦æ±‚çš„é€šä¿¡æ€§èƒ½

---

## ğŸ® é˜¶æ®µå››ï¼šæµ‹è¯•æ‰§è¡Œå¼•æ“å®ç°

### ğŸ“ é‡æ„åŸå› 
- è¿™æ˜¯ç³»ç»Ÿçš„æ ¸å¿ƒåŠŸèƒ½ï¼Œè´Ÿè´£å¹¶å‘æ‰§è¡Œæµ‹è¯•ä»»åŠ¡
- éœ€è¦å®ç°å¤æ‚çš„å¹¶å‘æ§åˆ¶å’Œä»»åŠ¡è°ƒåº¦
- å¿…é¡»ä¿è¯30ç§’å†…å®Œæˆæ‰¹æ¬¡æµ‹è¯•çš„æ€§èƒ½è¦æ±‚
- éœ€è¦æ”¯æŒä»»åŠ¡æš‚åœã€æ¢å¤ã€å–æ¶ˆç­‰æ“ä½œ

### ğŸ¯ å®æ–½ç›®æ ‡
- [ ] å®ç°é«˜æ€§èƒ½çš„å¹¶å‘æµ‹è¯•æ‰§è¡Œå¼•æ“
- [ ] å»ºç«‹ä»»åŠ¡é˜Ÿåˆ—å’Œè°ƒåº¦æœºåˆ¶
- [ ] å®ç°å…·ä½“çš„æµ‹è¯•æ­¥éª¤æ‰§è¡Œå™¨
- [ ] æ·»åŠ è¿›åº¦ç›‘æ§å’Œé”™è¯¯å¤„ç†
- [ ] æ”¯æŒ88ä¸ªé€šé“çš„å¹¶å‘æµ‹è¯•

### ğŸ“‹ è¯¦ç»†å®æ–½æ­¥éª¤

#### 4.1 å®ç°å¹¶å‘æ§åˆ¶æ¡†æ¶
**æ‰§è¡Œå†…å®¹**:
- [ ] è®¾è®¡ä»»åŠ¡è°ƒåº¦å™¨æ¶æ„
- [ ] å®ç°ä¿¡å·é‡æ§åˆ¶å¹¶å‘æ•°
- [ ] åˆ›å»ºä»»åŠ¡é˜Ÿåˆ—å’Œå·¥ä½œçº¿ç¨‹æ± 
- [ ] æ·»åŠ ä»»åŠ¡ä¼˜å…ˆçº§å’Œå–æ¶ˆæœºåˆ¶

**è¯¦ç»†æ‰§è¡Œæ­¥éª¤**:

**æ­¥éª¤4.1.1: åˆ›å»ºæµ‹è¯•ä»»åŠ¡å®šä¹‰**
åˆ›å»ºæ–‡ä»¶ `src/domain/entities/test_task.rs`:
```rust
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use std::time::Duration;
use tokio_util::sync::CancellationToken;

/// ä»»åŠ¡ä¼˜å…ˆçº§
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Serialize, Deserialize)]
pub enum TaskPriority {
    Low = 1,
    Normal = 2,
    High = 3,
    Critical = 4,
}

/// ä»»åŠ¡çŠ¶æ€
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum TaskStatus {
    Pending,
    Running,
    Completed,
    Failed,
    Cancelled,
}

/// æµ‹è¯•ä»»åŠ¡
#[derive(Debug, Clone)]
pub struct TestTask {
    pub task_id: String,
    pub instance_id: String,
    pub batch_id: String,
    pub priority: TaskPriority,
    pub status: TaskStatus,
    pub created_time: DateTime<Utc>,
    pub started_time: Option<DateTime<Utc>>,
    pub completed_time: Option<DateTime<Utc>>,
    pub estimated_duration: Duration,
    pub actual_duration: Option<Duration>,
    pub error_message: Option<String>,
    pub retry_count: u32,
    pub max_retries: u32,
}

impl TestTask {
    pub fn new(
        instance_id: String,
        batch_id: String,
        priority: TaskPriority,
    ) -> Self {
        Self {
            task_id: uuid::Uuid::new_v4().to_string(),
            instance_id,
            batch_id,
            priority,
            status: TaskStatus::Pending,
            created_time: Utc::now(),
            started_time: None,
            completed_time: None,
            estimated_duration: Duration::from_secs(2), // é»˜è®¤2ç§’
            actual_duration: None,
            error_message: None,
            retry_count: 0,
            max_retries: 3,
        }
    }

    pub fn start(&mut self) {
        self.status = TaskStatus::Running;
        self.started_time = Some(Utc::now());
    }

    pub fn complete(&mut self) {
        self.status = TaskStatus::Completed;
        self.completed_time = Some(Utc::now());
        if let Some(started) = self.started_time {
            self.actual_duration = Some(
                Duration::from_millis(
                    (Utc::now() - started).num_milliseconds() as u64
                )
            );
        }
    }

    pub fn fail(&mut self, error: String) {
        self.status = TaskStatus::Failed;
        self.completed_time = Some(Utc::now());
        self.error_message = Some(error);
        if let Some(started) = self.started_time {
            self.actual_duration = Some(
                Duration::from_millis(
                    (Utc::now() - started).num_milliseconds() as u64
                )
            );
        }
    }

    pub fn cancel(&mut self) {
        self.status = TaskStatus::Cancelled;
        self.completed_time = Some(Utc::now());
    }

    pub fn can_retry(&self) -> bool {
        self.retry_count < self.max_retries && self.status == TaskStatus::Failed
    }

    pub fn retry(&mut self) {
        if self.can_retry() {
            self.retry_count += 1;
            self.status = TaskStatus::Pending;
            self.started_time = None;
            self.completed_time = None;
            self.actual_duration = None;
            self.error_message = None;
        }
    }
}
```

**æ­¥éª¤4.1.2: å®ç°æµ‹è¯•æ‰§è¡Œå¼•æ“æ ¸å¿ƒç»“æ„**
åˆ›å»ºæ–‡ä»¶ `src/application/services/test_execution_engine_impl.rs`:
```rust
use std::collections::{HashMap, VecDeque};
use std::sync::atomic::{AtomicUsize, Ordering};
use std::sync::Arc;
use std::time::Duration;
use tokio::sync::{Mutex, Semaphore, RwLock};
use tokio::time::{interval, timeout};
use tokio_util::sync::CancellationToken;
use futures::future::join_all;

use crate::domain::entities::{TestTask, ChannelTestInstance, ChannelPointDefinition};
use crate::domain::enums::{OverallTestStatus, SubTestItem};
use crate::domain::services::{
    ITestExecutionEngine, IChannelStateManager, IPlcCommunicationService,
    TestProgress, ExecutionStatistics, TaskPriority
};
use crate::infrastructure::errors::AppError;

/// æ‰¹æ¬¡æ‰§è¡ŒçŠ¶æ€
#[derive(Debug, Clone)]
struct BatchExecutionState {
    batch_id: String,
    total_tasks: usize,
    completed_tasks: AtomicUsize,
    failed_tasks: AtomicUsize,
    cancellation_token: CancellationToken,
    started_time: DateTime<Utc>,
}

/// æµ‹è¯•æ‰§è¡Œå¼•æ“å®ç°
pub struct TestExecutionEngineImpl {
    /// å¹¶å‘æ§åˆ¶ä¿¡å·é‡
    concurrency_semaphore: Arc<Semaphore>,
    /// ä»»åŠ¡é˜Ÿåˆ—ï¼ˆæŒ‰ä¼˜å…ˆçº§æ’åºï¼‰
    task_queue: Arc<Mutex<VecDeque<TestTask>>>,
    /// æ­£åœ¨æ‰§è¡Œçš„ä»»åŠ¡
    running_tasks: Arc<RwLock<HashMap<String, TestTask>>>,
    /// æ‰¹æ¬¡æ‰§è¡ŒçŠ¶æ€
    batch_states: Arc<RwLock<HashMap<String, BatchExecutionState>>>,
    /// æµ‹è¯•æ­¥éª¤æ‰§è¡Œå™¨
    step_executors: HashMap<SubTestItem, Arc<dyn ISpecificTestStepExecutor>>,
    /// ä¾èµ–æœåŠ¡
    state_manager: Arc<dyn IChannelStateManager>,
    plc_service: Arc<dyn IPlcCommunicationService>,
    /// é…ç½®å‚æ•°
    max_concurrency: usize,
    task_timeout: Duration,
    /// ç»Ÿè®¡ä¿¡æ¯
    total_executed: AtomicUsize,
    total_failed: AtomicUsize,
}

impl TestExecutionEngineImpl {
    pub fn new(
        max_concurrency: usize,
        state_manager: Arc<dyn IChannelStateManager>,
        plc_service: Arc<dyn IPlcCommunicationService>,
    ) -> Self {
        let mut step_executors = HashMap::new();
        step_executors.insert(
            SubTestItem::HardPoint,
            Arc::new(HardPointTestExecutor::new(plc_service.clone())) as Arc<dyn ISpecificTestStepExecutor>
        );

        Self {
            concurrency_semaphore: Arc::new(Semaphore::new(max_concurrency)),
            task_queue: Arc::new(Mutex::new(VecDeque::new())),
            running_tasks: Arc::new(RwLock::new(HashMap::new())),
            batch_states: Arc::new(RwLock::new(HashMap::new())),
            step_executors,
            state_manager,
            plc_service,
            max_concurrency,
            task_timeout: Duration::from_secs(30), // 30ç§’ä»»åŠ¡è¶…æ—¶
            total_executed: AtomicUsize::new(0),
            total_failed: AtomicUsize::new(0),
        }
    }

    /// å¯åŠ¨ä»»åŠ¡å¤„ç†å¾ªç¯
    pub async fn start_task_processor(&self) {
        let task_queue = self.task_queue.clone();
        let running_tasks = self.running_tasks.clone();
        let batch_states = self.batch_states.clone();
        let semaphore = self.concurrency_semaphore.clone();
        let state_manager = self.state_manager.clone();
        let step_executors = self.step_executors.clone();
        let total_executed = self.total_executed.clone();
        let total_failed = self.total_failed.clone();
        let task_timeout = self.task_timeout;

        tokio::spawn(async move {
            let mut interval = interval(Duration::from_millis(100)); // 100msæ£€æŸ¥é—´éš”

            loop {
                interval.tick().await;

                // è·å–ä¸‹ä¸€ä¸ªå¾…æ‰§è¡Œä»»åŠ¡
                let task = {
                    let mut queue = task_queue.lock().await;
                    queue.pop_front()
                };

                if let Some(mut task) = task {
                    // æ£€æŸ¥æ‰¹æ¬¡æ˜¯å¦å·²å–æ¶ˆ
                    let batch_cancelled = {
                        let states = batch_states.read().await;
                        states.get(&task.batch_id)
                            .map(|state| state.cancellation_token.is_cancelled())
                            .unwrap_or(true)
                    };

                    if batch_cancelled {
                        task.cancel();
                        continue;
                    }

                    // å°è¯•è·å–ä¿¡å·é‡è®¸å¯
                    if let Ok(permit) = semaphore.try_acquire() {
                        let task_id = task.task_id.clone();
                        task.start();

                        // æ·»åŠ åˆ°è¿è¡Œä»»åŠ¡åˆ—è¡¨
                        {
                            let mut running = running_tasks.write().await;
                            running.insert(task_id.clone(), task.clone());
                        }

                        // å¯åŠ¨ä»»åŠ¡æ‰§è¡Œ
                        let running_tasks_clone = running_tasks.clone();
                        let batch_states_clone = batch_states.clone();
                        let state_manager_clone = state_manager.clone();
                        let step_executors_clone = step_executors.clone();
                        let total_executed_clone = total_executed.clone();
                        let total_failed_clone = total_failed.clone();

                        tokio::spawn(async move {
                            let result = timeout(
                                task_timeout,
                                Self::execute_task(
                                    task.clone(),
                                    state_manager_clone,
                                    step_executors_clone,
                                )
                            ).await;

                            // å¤„ç†ä»»åŠ¡ç»“æœ
                            let mut final_task = task;
                            match result {
                                Ok(Ok(())) => {
                                    final_task.complete();
                                    total_executed_clone.fetch_add(1, Ordering::Relaxed);
                                }
                                Ok(Err(e)) => {
                                    final_task.fail(e.to_string());
                                    total_failed_clone.fetch_add(1, Ordering::Relaxed);
                                }
                                Err(_) => {
                                    final_task.fail("ä»»åŠ¡æ‰§è¡Œè¶…æ—¶".to_string());
                                    total_failed_clone.fetch_add(1, Ordering::Relaxed);
                                }
                            }

                            // æ›´æ–°æ‰¹æ¬¡çŠ¶æ€
                            {
                                let states = batch_states_clone.read().await;
                                if let Some(batch_state) = states.get(&final_task.batch_id) {
                                    if final_task.status == TaskStatus::Completed {
                                        batch_state.completed_tasks.fetch_add(1, Ordering::Relaxed);
                                    } else {
                                        batch_state.failed_tasks.fetch_add(1, Ordering::Relaxed);
                                    }
                                }
                            }

                            // ä»è¿è¡Œä»»åŠ¡åˆ—è¡¨ç§»é™¤
                            {
                                let mut running = running_tasks_clone.write().await;
                                running.remove(&task_id);
                            }

                            // é‡Šæ”¾ä¿¡å·é‡è®¸å¯
                            drop(permit);
                        });
                    } else {
                        // æ²¡æœ‰å¯ç”¨è®¸å¯ï¼Œé‡æ–°æ”¾å›é˜Ÿåˆ—
                        let mut queue = task_queue.lock().await;
                        queue.push_front(task);
                    }
                }
            }
        });
    }
}
```

**éªŒè¯æ£€æŸ¥ç‚¹**:
- [ ] ä»»åŠ¡é˜Ÿåˆ—å’Œä¼˜å…ˆçº§æœºåˆ¶æ­£å¸¸å·¥ä½œ
- [ ] ä¿¡å·é‡å¹¶å‘æ§åˆ¶æœ‰æ•ˆ
- [ ] ä»»åŠ¡çŠ¶æ€è·Ÿè¸ªå‡†ç¡®
- [ ] æ‰¹æ¬¡å–æ¶ˆæœºåˆ¶æ­£å¸¸
- [ ] è¶…æ—¶å¤„ç†æœºåˆ¶æœ‰æ•ˆ

#### 4.2 å®ç°å…·ä½“æµ‹è¯•æ­¥éª¤æ‰§è¡Œå™¨
**æ‰§è¡Œå†…å®¹**:
- [ ] å®ç°ç¡¬ç‚¹æµ‹è¯•æ‰§è¡Œå™¨
- [ ] å®ç°DI/DO/AI/AOæµ‹è¯•é€»è¾‘
- [ ] æ·»åŠ æµ‹è¯•æ•°æ®éªŒè¯
- [ ] å®ç°æµ‹è¯•ç»“æœæ”¶é›†

**è¯¦ç»†æ‰§è¡Œæ­¥éª¤**:

**æ­¥éª¤4.2.1: åˆ›å»ºæµ‹è¯•æ­¥éª¤æ‰§è¡Œå™¨æ¥å£**
åˆ›å»ºæ–‡ä»¶ `src/domain/services/test_step_executors/mod.rs`:
```rust
//! æµ‹è¯•æ­¥éª¤æ‰§è¡Œå™¨æ¨¡å—
//!
//! åŒ…å«å„ç§å…·ä½“æµ‹è¯•æ­¥éª¤çš„æ‰§è¡Œå™¨å®ç°

pub mod hard_point_test_executor;
pub mod di_test_executor;
pub mod do_test_executor;
pub mod ai_test_executor;
pub mod ao_test_executor;

pub use hard_point_test_executor::HardPointTestExecutor;
pub use di_test_executor::DiTestExecutor;
pub use do_test_executor::DoTestExecutor;
pub use ai_test_executor::AiTestExecutor;
pub use ao_test_executor::AoTestExecutor;

use crate::domain::entities::{ChannelTestInstance, ChannelPointDefinition};
use crate::domain::enums::SubTestItem;
use crate::domain::services::{RawTestOutcome, IPlcCommunicationService};
use crate::infrastructure::errors::AppError;
use async_trait::async_trait;
use std::sync::Arc;

/// å…·ä½“æµ‹è¯•æ­¥éª¤æ‰§è¡Œå™¨æ¥å£
///
/// æ¯ä¸ªæ‰§è¡Œå™¨è´Ÿè´£æ‰§è¡Œç‰¹å®šç±»å‹çš„æµ‹è¯•æ­¥éª¤
/// ç¬¦åˆ FAT-CTK-001 è§„åˆ™ï¼šæ¯ä¸ªæ‰§è¡Œå™¨åªå¤„ç†å•ä¸€æµ‹è¯•æ­¥éª¤
#[async_trait]
pub trait ISpecificTestStepExecutor: Send + Sync {
    /// è·å–æ‰§è¡Œå™¨å¤„ç†çš„æµ‹è¯•é¡¹ç›®ç±»å‹
    fn item_type(&self) -> SubTestItem;

    /// æ‰§è¡Œæµ‹è¯•æ­¥éª¤
    async fn execute(
        &self,
        instance: &ChannelTestInstance,
        definition: &ChannelPointDefinition,
        plc_service: Arc<dyn IPlcCommunicationService>,
    ) -> Result<RawTestOutcome, AppError>;

    /// éªŒè¯æµ‹è¯•å‰ç½®æ¡ä»¶
    async fn validate_preconditions(
        &self,
        definition: &ChannelPointDefinition,
        plc_service: Arc<dyn IPlcCommunicationService>,
    ) -> Result<bool, AppError> {
        // é»˜è®¤å®ç°ï¼šæ£€æŸ¥PLCè¿æ¥
        Ok(plc_service.is_connected().await)
    }

    /// è·å–é¢„ä¼°æ‰§è¡Œæ—¶é—´
    fn estimated_duration(&self) -> std::time::Duration {
        std::time::Duration::from_secs(2) // é»˜è®¤2ç§’
    }
}
```

**æ­¥éª¤4.2.2: å®ç°ç¡¬ç‚¹æµ‹è¯•æ‰§è¡Œå™¨**
åˆ›å»ºæ–‡ä»¶ `src/domain/services/test_step_executors/hard_point_test_executor.rs`:
```rust
use super::*;
use crate::domain::services::{TestValue, TestResult};
use chrono::Utc;
use std::time::Duration;
use tokio::time::sleep;

/// ç¡¬ç‚¹æµ‹è¯•æ‰§è¡Œå™¨
///
/// è´Ÿè´£æ‰§è¡Œç¡¬ç‚¹æµ‹è¯•ï¼ŒåŒ…æ‹¬DI/DO/AI/AOçš„åŸºç¡€åŠŸèƒ½éªŒè¯
pub struct HardPointTestExecutor {
    /// é‡è¯•æ¬¡æ•°
    max_retries: u32,
    /// æµ‹è¯•è¶…æ—¶æ—¶é—´
    test_timeout: Duration,
}

impl HardPointTestExecutor {
    pub fn new() -> Self {
        Self {
            max_retries: 3,
            test_timeout: Duration::from_secs(10),
        }
    }

    pub fn with_config(max_retries: u32, test_timeout: Duration) -> Self {
        Self {
            max_retries,
            test_timeout,
        }
    }
}

#[async_trait]
impl ISpecificTestStepExecutor for HardPointTestExecutor {
    fn item_type(&self) -> SubTestItem {
        SubTestItem::HardPoint
    }

    fn estimated_duration(&self) -> Duration {
        Duration::from_secs(3) // ç¡¬ç‚¹æµ‹è¯•é¢„ä¼°3ç§’
    }

    async fn execute(
        &self,
        instance: &ChannelTestInstance,
        definition: &ChannelPointDefinition,
        plc_service: Arc<dyn IPlcCommunicationService>,
    ) -> Result<RawTestOutcome, AppError> {
        log::info!("å¼€å§‹ç¡¬ç‚¹æµ‹è¯•: é€šé“ {}, ç±»å‹ {:?}",
                  instance.instance_id, definition.module_type);

        let mut test_values = Vec::new();
        let start_time = Utc::now();
        let mut error_message = None;

        // éªŒè¯å‰ç½®æ¡ä»¶
        if !self.validate_preconditions(definition, plc_service.clone()).await? {
            return Ok(RawTestOutcome {
                test_item: SubTestItem::HardPoint,
                result: TestResult::Fail,
                test_values: vec![],
                error_message: Some("å‰ç½®æ¡ä»¶éªŒè¯å¤±è´¥".to_string()),
                execution_time: start_time,
                duration_ms: 0,
            });
        }

        // æ ¹æ®æ¨¡å—ç±»å‹æ‰§è¡Œä¸åŒçš„æµ‹è¯•é€»è¾‘
        let test_result = match definition.module_type {
            ModuleType::DI => {
                self.test_di_channel(definition, plc_service.clone(), &mut test_values).await
            }
            ModuleType::DO => {
                self.test_do_channel(definition, plc_service.clone(), &mut test_values).await
            }
            ModuleType::AI => {
                self.test_ai_channel(definition, plc_service.clone(), &mut test_values).await
            }
            ModuleType::AO => {
                self.test_ao_channel(definition, plc_service.clone(), &mut test_values).await
            }
        };

        let (result, error) = match test_result {
            Ok(result) => (result, None),
            Err(e) => {
                error_message = Some(e.to_string());
                (TestResult::Fail, Some(e.to_string()))
            }
        };

        let duration = (Utc::now() - start_time).num_milliseconds() as u64;

        log::info!("ç¡¬ç‚¹æµ‹è¯•å®Œæˆ: é€šé“ {}, ç»“æœ {:?}, è€—æ—¶ {}ms",
                  instance.instance_id, result, duration);

        Ok(RawTestOutcome {
            test_item: SubTestItem::HardPoint,
            result,
            test_values,
            error_message,
            execution_time: start_time,
            duration_ms: duration,
        })
    }
}

impl HardPointTestExecutor {
    /// DIé€šé“æµ‹è¯•
    async fn test_di_channel(
        &self,
        definition: &ChannelPointDefinition,
        plc_service: Arc<dyn IPlcCommunicationService>,
        test_values: &mut Vec<TestValue>,
    ) -> Result<TestResult, AppError> {
        let address = &definition.plc_communication_address;

        // æ­¥éª¤1: è¯»å–åˆå§‹çŠ¶æ€
        let initial_value = plc_service.read_bool(address).await?;
        test_values.push(TestValue {
            step: "DIåˆå§‹çŠ¶æ€è¯»å–".to_string(),
            expected: 0.0, // æœŸæœ›åˆå§‹ä¸ºä½ç”µå¹³
            actual: if initial_value { 1.0 } else { 0.0 },
            tolerance: None,
            passed: true, // åˆå§‹çŠ¶æ€è¯»å–æˆåŠŸå³ä¸ºé€šè¿‡
            timestamp: Utc::now(),
        });

        // æ­¥éª¤2: ç­‰å¾…ä¿¡å·å˜åŒ–ï¼ˆæ¨¡æ‹Ÿå¤–éƒ¨ä¿¡å·è¾“å…¥ï¼‰
        log::debug!("ç­‰å¾…DIä¿¡å·å˜åŒ–æµ‹è¯•...");
        sleep(Duration::from_millis(500)).await;

        // æ­¥éª¤3: è¯»å–ä¿¡å·å˜åŒ–åçš„çŠ¶æ€
        let changed_value = plc_service.read_bool(address).await?;
        let signal_changed = changed_value != initial_value;

        test_values.push(TestValue {
            step: "DIä¿¡å·å“åº”æµ‹è¯•".to_string(),
            expected: if initial_value { 0.0 } else { 1.0 },
            actual: if changed_value { 1.0 } else { 0.0 },
            tolerance: None,
            passed: signal_changed,
            timestamp: Utc::now(),
        });

        // æ­¥éª¤4: ç¨³å®šæ€§æµ‹è¯• - è¿ç»­è¯»å–å¤šæ¬¡éªŒè¯ç¨³å®šæ€§
        let mut stability_passed = true;
        for i in 0..5 {
            sleep(Duration::from_millis(100)).await;
            let stable_value = plc_service.read_bool(address).await?;
            if stable_value != changed_value {
                stability_passed = false;
                break;
            }
        }

        test_values.push(TestValue {
            step: "DIä¿¡å·ç¨³å®šæ€§æµ‹è¯•".to_string(),
            expected: if changed_value { 1.0 } else { 0.0 },
            actual: if changed_value { 1.0 } else { 0.0 },
            tolerance: None,
            passed: stability_passed,
            timestamp: Utc::now(),
        });

        // ç»¼åˆåˆ¤æ–­æµ‹è¯•ç»“æœ
        let overall_passed = signal_changed && stability_passed;
        Ok(if overall_passed { TestResult::Pass } else { TestResult::Fail })
    }

    /// DOé€šé“æµ‹è¯•
    async fn test_do_channel(
        &self,
        definition: &ChannelPointDefinition,
        plc_service: Arc<dyn IPlcCommunicationService>,
        test_values: &mut Vec<TestValue>,
    ) -> Result<TestResult, AppError> {
        let address = &definition.plc_communication_address;

        // æ­¥éª¤1: è¾“å‡ºé«˜ç”µå¹³æµ‹è¯•
        plc_service.write_bool(address, true).await?;
        sleep(Duration::from_millis(100)).await;

        let high_readback = plc_service.read_bool(address).await?;
        test_values.push(TestValue {
            step: "DOé«˜ç”µå¹³è¾“å‡ºæµ‹è¯•".to_string(),
            expected: 1.0,
            actual: if high_readback { 1.0 } else { 0.0 },
            tolerance: None,
            passed: high_readback,
            timestamp: Utc::now(),
        });

        // æ­¥éª¤2: è¾“å‡ºä½ç”µå¹³æµ‹è¯•
        plc_service.write_bool(address, false).await?;
        sleep(Duration::from_millis(100)).await;

        let low_readback = plc_service.read_bool(address).await?;
        test_values.push(TestValue {
            step: "DOä½ç”µå¹³è¾“å‡ºæµ‹è¯•".to_string(),
            expected: 0.0,
            actual: if low_readback { 1.0 } else { 0.0 },
            tolerance: None,
            passed: !low_readback,
            timestamp: Utc::now(),
        });

        // æ­¥éª¤3: å¿«é€Ÿåˆ‡æ¢æµ‹è¯•
        let mut switch_test_passed = true;
        for i in 0..10 {
            let test_value = i % 2 == 0;
            plc_service.write_bool(address, test_value).await?;
            sleep(Duration::from_millis(50)).await;

            let readback = plc_service.read_bool(address).await?;
            if readback != test_value {
                switch_test_passed = false;
                break;
            }
        }

        test_values.push(TestValue {
            step: "DOå¿«é€Ÿåˆ‡æ¢æµ‹è¯•".to_string(),
            expected: 1.0,
            actual: if switch_test_passed { 1.0 } else { 0.0 },
            tolerance: None,
            passed: switch_test_passed,
            timestamp: Utc::now(),
        });

        // å¤ä½åˆ°å®‰å…¨çŠ¶æ€
        plc_service.write_bool(address, false).await?;

        let overall_passed = high_readback && !low_readback && switch_test_passed;
        Ok(if overall_passed { TestResult::Pass } else { TestResult::Fail })
    }

    /// AIé€šé“æµ‹è¯•
    async fn test_ai_channel(
        &self,
        definition: &ChannelPointDefinition,
        plc_service: Arc<dyn IPlcCommunicationService>,
        test_values: &mut Vec<TestValue>,
    ) -> Result<TestResult, AppError> {
        let address = &definition.plc_communication_address;
        let test_points = [0.0, 25.0, 50.0, 75.0, 100.0]; // æµ‹è¯•ç‚¹ï¼š0%, 25%, 50%, 75%, 100%

        // è·å–é‡ç¨‹ä¿¡æ¯
        let lower_limit = definition.range_lower_limit.unwrap_or(0.0);
        let upper_limit = definition.range_upper_limit.unwrap_or(100.0);
        let range = upper_limit - lower_limit;

        let mut all_passed = true;

        for &percentage in test_points.iter() {
            // è®¡ç®—æœŸæœ›çš„æ¨¡æ‹Ÿé‡å€¼
            let expected_value = lower_limit + (range * percentage / 100.0);

            // ç­‰å¾…ä¿¡å·ç¨³å®š
            sleep(Duration::from_millis(200)).await;

            // è¯»å–AIå€¼
            let actual_value = plc_service.read_f32(address).await?;

            // è®¡ç®—åå·®
            let tolerance = range * 0.01; // 1%çš„å®¹å·®
            let deviation = (actual_value - expected_value).abs();
            let passed = deviation <= tolerance;

            if !passed {
                all_passed = false;
            }

            test_values.push(TestValue {
                step: format!("AIæµ‹è¯•ç‚¹{}%", percentage as u32),
                expected: expected_value,
                actual: actual_value,
                tolerance: Some(tolerance),
                passed,
                timestamp: Utc::now(),
            });

            log::debug!("AIæµ‹è¯•ç‚¹{}%: æœŸæœ›={:.2}, å®é™…={:.2}, åå·®={:.2}, é€šè¿‡={}",
                       percentage, expected_value, actual_value, deviation, passed);
        }

        // çº¿æ€§åº¦æµ‹è¯•
        let linearity_passed = self.test_ai_linearity(
            definition,
            plc_service.clone(),
            test_values
        ).await?;

        let overall_passed = all_passed && linearity_passed;
        Ok(if overall_passed { TestResult::Pass } else { TestResult::Fail })
    }

    /// AIçº¿æ€§åº¦æµ‹è¯•
    async fn test_ai_linearity(
        &self,
        definition: &ChannelPointDefinition,
        plc_service: Arc<dyn IPlcCommunicationService>,
        test_values: &mut Vec<TestValue>,
    ) -> Result<bool, AppError> {
        let address = &definition.plc_communication_address;

        // æ”¶é›†å¤šä¸ªæµ‹è¯•ç‚¹çš„æ•°æ®
        let mut measurements = Vec::new();
        for i in 0..=10 {
            let percentage = i as f32 * 10.0; // 0%, 10%, 20%, ..., 100%
            sleep(Duration::from_millis(100)).await;

            let value = plc_service.read_f32(address).await?;
            measurements.push((percentage, value));
        }

        // è®¡ç®—çº¿æ€§åº¦ï¼ˆä½¿ç”¨æœ€å°äºŒä¹˜æ³•ï¼‰
        let n = measurements.len() as f32;
        let sum_x: f32 = measurements.iter().map(|(x, _)| x).sum();
        let sum_y: f32 = measurements.iter().map(|(_, y)| y).sum();
        let sum_xy: f32 = measurements.iter().map(|(x, y)| x * y).sum();
        let sum_x2: f32 = measurements.iter().map(|(x, _)| x * x).sum();

        let slope = (n * sum_xy - sum_x * sum_y) / (n * sum_x2 - sum_x * sum_x);
        let intercept = (sum_y - slope * sum_x) / n;

        // è®¡ç®—ç›¸å…³ç³»æ•°
        let mean_x = sum_x / n;
        let mean_y = sum_y / n;

        let numerator: f32 = measurements.iter()
            .map(|(x, y)| (x - mean_x) * (y - mean_y))
            .sum();
        let denominator_x: f32 = measurements.iter()
            .map(|(x, _)| (x - mean_x).powi(2))
            .sum();
        let denominator_y: f32 = measurements.iter()
            .map(|(_, y)| (y - mean_y).powi(2))
            .sum();

        let correlation = numerator / (denominator_x * denominator_y).sqrt();

        // çº¿æ€§åº¦è¦æ±‚ï¼šç›¸å…³ç³»æ•° > 0.99
        let linearity_passed = correlation > 0.99;

        test_values.push(TestValue {
            step: "AIçº¿æ€§åº¦æµ‹è¯•".to_string(),
            expected: 0.99,
            actual: correlation as f64,
            tolerance: Some(0.01),
            passed: linearity_passed,
            timestamp: Utc::now(),
        });

        log::debug!("AIçº¿æ€§åº¦æµ‹è¯•: ç›¸å…³ç³»æ•°={:.4}, æ–œç‡={:.4}, æˆªè·={:.4}, é€šè¿‡={}",
                   correlation, slope, intercept, linearity_passed);

        Ok(linearity_passed)
    }

    /// AOé€šé“æµ‹è¯•
    async fn test_ao_channel(
        &self,
        definition: &ChannelPointDefinition,
        plc_service: Arc<dyn IPlcCommunicationService>,
        test_values: &mut Vec<TestValue>,
    ) -> Result<TestResult, AppError> {
        let address = &definition.plc_communication_address;
        let test_points = [0.0, 25.0, 50.0, 75.0, 100.0];

        // è·å–é‡ç¨‹ä¿¡æ¯
        let lower_limit = definition.range_lower_limit.unwrap_or(0.0);
        let upper_limit = definition.range_upper_limit.unwrap_or(100.0);
        let range = upper_limit - lower_limit;

        let mut all_passed = true;

        for &percentage in test_points.iter() {
            // è®¡ç®—è¾“å‡ºå€¼
            let output_value = lower_limit + (range * percentage / 100.0);

            // å†™å…¥AOå€¼
            plc_service.write_f32(address, output_value).await?;

            // ç­‰å¾…è¾“å‡ºç¨³å®š
            sleep(Duration::from_millis(200)).await;

            // è¯»å›éªŒè¯
            let readback_value = plc_service.read_f32(address).await?;

            // è®¡ç®—åå·®
            let tolerance = range * 0.01; // 1%çš„å®¹å·®
            let deviation = (readback_value - output_value).abs();
            let passed = deviation <= tolerance;

            if !passed {
                all_passed = false;
            }

            test_values.push(TestValue {
                step: format!("AOè¾“å‡ºæµ‹è¯•{}%", percentage as u32),
                expected: output_value,
                actual: readback_value,
                tolerance: Some(tolerance),
                passed,
                timestamp: Utc::now(),
            });

            log::debug!("AOæµ‹è¯•ç‚¹{}%: è¾“å‡º={:.2}, è¯»å›={:.2}, åå·®={:.2}, é€šè¿‡={}",
                       percentage, output_value, readback_value, deviation, passed);
        }

        // è¾“å‡ºä¿æŒæµ‹è¯•
        let hold_test_passed = self.test_ao_hold(
            definition,
            plc_service.clone(),
            test_values
        ).await?;

        // å¤ä½åˆ°å®‰å…¨å€¼
        plc_service.write_f32(address, lower_limit).await?;

        let overall_passed = all_passed && hold_test_passed;
        Ok(if overall_passed { TestResult::Pass } else { TestResult::Fail })
    }

    /// AOä¿æŒæµ‹è¯•
    async fn test_ao_hold(
        &self,
        definition: &ChannelPointDefinition,
        plc_service: Arc<dyn IPlcCommunicationService>,
        test_values: &mut Vec<TestValue>,
    ) -> Result<bool, AppError> {
        let address = &definition.plc_communication_address;
        let lower_limit = definition.range_lower_limit.unwrap_or(0.0);
        let upper_limit = definition.range_upper_limit.unwrap_or(100.0);
        let test_value = lower_limit + (upper_limit - lower_limit) * 0.5; // 50%å€¼

        // è®¾ç½®æµ‹è¯•å€¼
        plc_service.write_f32(address, test_value).await?;
        sleep(Duration::from_millis(100)).await;

        // è¿ç»­è¯»å–å¤šæ¬¡ï¼ŒéªŒè¯è¾“å‡ºä¿æŒç¨³å®š
        let mut hold_passed = true;
        let tolerance = (upper_limit - lower_limit) * 0.005; // 0.5%å®¹å·®

        for i in 0..10 {
            sleep(Duration::from_millis(100)).await;
            let current_value = plc_service.read_f32(address).await?;
            let deviation = (current_value - test_value).abs();

            if deviation > tolerance {
                hold_passed = false;
                break;
            }
        }

        test_values.push(TestValue {
            step: "AOè¾“å‡ºä¿æŒæµ‹è¯•".to_string(),
            expected: test_value,
            actual: test_value, // ç®€åŒ–æ˜¾ç¤º
            tolerance: Some(tolerance),
            passed: hold_passed,
            timestamp: Utc::now(),
        });

        log::debug!("AOä¿æŒæµ‹è¯•: æµ‹è¯•å€¼={:.2}, å®¹å·®={:.2}, é€šè¿‡={}",
                   test_value, tolerance, hold_passed);

        Ok(hold_passed)
    }
}

**æ­¥éª¤4.2.3: æ·»åŠ éªŒè¯æ£€æŸ¥ç‚¹**
```rust
// åœ¨ hard_point_test_executor.rs ä¸­æ·»åŠ éªŒè¯æ–¹æ³•
impl HardPointTestExecutor {
    /// éªŒè¯æµ‹è¯•å‰ç½®æ¡ä»¶
    async fn validate_preconditions(
        &self,
        definition: &ChannelPointDefinition,
        plc_service: Arc<dyn IPlcCommunicationService>,
    ) -> Result<bool, AppError> {
        // æ£€æŸ¥PLCè¿æ¥çŠ¶æ€
        if !plc_service.is_connected().await {
            log::error!("PLCæœªè¿æ¥");
            return Ok(false);
        }

        // æ£€æŸ¥åœ°å€æ ¼å¼
        if definition.plc_communication_address.is_empty() {
            log::error!("PLCé€šä¿¡åœ°å€ä¸ºç©º");
            return Ok(false);
        }

        // æ£€æŸ¥é‡ç¨‹è®¾ç½®ï¼ˆå¯¹äºAI/AOï¼‰
        if matches!(definition.module_type, ModuleType::AI | ModuleType::AO) {
            if definition.range_lower_limit.is_none() || definition.range_upper_limit.is_none() {
                log::error!("AI/AOé€šé“ç¼ºå°‘é‡ç¨‹è®¾ç½®");
                return Ok(false);
            }

            let lower = definition.range_lower_limit.unwrap();
            let upper = definition.range_upper_limit.unwrap();
            if lower >= upper {
                log::error!("é‡ç¨‹è®¾ç½®é”™è¯¯: ä¸‹é™({}) >= ä¸Šé™({})", lower, upper);
                return Ok(false);
            }
        }

        log::debug!("å‰ç½®æ¡ä»¶éªŒè¯é€šè¿‡: é€šé“ {}", definition.tag);
        Ok(true)
    }
}
```

#### 4.3 å®ç°ä»»åŠ¡æ§åˆ¶åŠŸèƒ½
**æ‰§è¡Œå†…å®¹**:
- [ ] å®ç°æµ‹è¯•æš‚åœå’Œæ¢å¤
- [ ] æ·»åŠ ä»»åŠ¡å–æ¶ˆæœºåˆ¶
- [ ] å®ç°è¿›åº¦ç›‘æ§
- [ ] æ·»åŠ é”™è¯¯æ¢å¤ç­–ç•¥

**å®æ–½ç»†èŠ‚**:
```rust
// ç»§ç»­åœ¨ TestExecutionEngine ä¸­æ·»åŠ æ§åˆ¶æ–¹æ³•
impl TestExecutionEngine {
    pub async fn pause_batch_test(&self, batch_id: &str) -> Result<(), AppError> {
        let tokens = self.cancellation_tokens.lock().await;
        if let Some(token) = tokens.get(batch_id) {
            token.cancel();
            log::info!("Paused batch test: {}", batch_id);
            Ok(())
        } else {
            Err(AppError::TestExecutionError(format!("Batch {} not found", batch_id)))
        }
    }

    pub async fn get_batch_progress(&self, batch_id: &str) -> Result<TestProgress, AppError> {
        // ä»çŠ¶æ€ç®¡ç†å™¨è·å–æ‰¹æ¬¡è¿›åº¦
        let instances = self.state_manager.get_batch_instances(batch_id).await?;

        let total_count = instances.len();
        let completed_count = instances.iter()
            .filter(|i| matches!(i.overall_status,
                OverallTestStatus::HardPointPassed |
                OverallTestStatus::HardPointFailed |
                OverallTestStatus::AllCompleted))
            .count();

        let passed_count = instances.iter()
            .filter(|i| matches!(i.overall_status,
                OverallTestStatus::HardPointPassed |
                OverallTestStatus::AllCompleted))
            .count();

        let failed_count = instances.iter()
            .filter(|i| matches!(i.overall_status, OverallTestStatus::HardPointFailed))
            .count();

        Ok(TestProgress {
            batch_id: batch_id.to_string(),
            total_count,
            completed_count,
            passed_count,
            failed_count,
            progress_percentage: (completed_count as f64 / total_count as f64 * 100.0) as u32,
            estimated_remaining_time: self.calculate_remaining_time(total_count, completed_count).await,
        })
    }

    async fn calculate_remaining_time(&self, total: usize, completed: usize) -> Duration {
        if completed == 0 {
            return Duration::from_secs(30); // é»˜è®¤ä¼°è®¡30ç§’
        }

        let remaining = total - completed;
        let avg_time_per_test = Duration::from_secs(1); // å‡è®¾æ¯ä¸ªæµ‹è¯•å¹³å‡1ç§’

        Duration::from_secs((remaining as u64) * avg_time_per_test.as_secs())
    }
}
```

### ğŸ§ª æµ‹è¯•éªŒè¯

#### å•å…ƒæµ‹è¯•
- [ ] å¹¶å‘æ§åˆ¶ä¿¡å·é‡æµ‹è¯•
- [ ] ä»»åŠ¡å–æ¶ˆæœºåˆ¶æµ‹è¯•
- [ ] æµ‹è¯•æ­¥éª¤æ‰§è¡Œå™¨æµ‹è¯•
- [ ] è¿›åº¦è®¡ç®—é€»è¾‘æµ‹è¯•

#### é›†æˆæµ‹è¯•
- [ ] 88ä¸ªé€šé“å¹¶å‘æµ‹è¯•
- [ ] æ‰¹æ¬¡æµ‹è¯•å®Œæ•´æµç¨‹æµ‹è¯•
- [ ] ä»»åŠ¡æš‚åœæ¢å¤æµ‹è¯•
- [ ] é”™è¯¯æ¢å¤æœºåˆ¶æµ‹è¯•

#### æ€§èƒ½æµ‹è¯•
- [ ] 30ç§’æ€§èƒ½ç›®æ ‡éªŒè¯
- [ ] å†…å­˜ä½¿ç”¨ç›‘æ§
- [ ] CPUä½¿ç”¨ç‡æµ‹è¯•
- [ ] å¹¶å‘ç¨³å®šæ€§æµ‹è¯•

### ğŸ“Š é¢„æœŸç»“æœ
- âœ… é«˜æ€§èƒ½çš„å¹¶å‘æµ‹è¯•æ‰§è¡Œå¼•æ“ï¼Œæ”¯æŒ88ä¸ªé€šé“
- âœ… æ»¡è¶³30ç§’æµ‹è¯•æ—¶é—´è¦æ±‚
- âœ… å®Œå–„çš„ä»»åŠ¡è°ƒåº¦å’Œç›‘æ§æœºåˆ¶
- âœ… ç¨³å®šçš„é”™è¯¯å¤„ç†å’Œæ¢å¤èƒ½åŠ›
- âœ… çµæ´»çš„ä»»åŠ¡æ§åˆ¶åŠŸèƒ½ï¼ˆæš‚åœ/æ¢å¤/å–æ¶ˆï¼‰

---

## ğŸ”„ é˜¶æ®µäº”ï¼šçŠ¶æ€ç®¡ç†å™¨å®ç°

### ğŸ“ é‡æ„åŸå› 
- çŠ¶æ€ç®¡ç†æ˜¯ç³»ç»Ÿçš„æ ¸å¿ƒï¼Œå¿…é¡»ç¡®ä¿çŠ¶æ€è½¬æ¢çš„æ­£ç¡®æ€§
- éœ€è¦å®ç°FAT-CSM-001è§„åˆ™ï¼šå”¯ä¸€çŠ¶æ€ä¿®æ”¹å…¥å£
- å¿…é¡»æ”¯æŒå¹¶å‘ç¯å¢ƒä¸‹çš„çŠ¶æ€ä¸€è‡´æ€§
- éœ€è¦æä¾›çŠ¶æ€æŒä¹…åŒ–å’Œæ¢å¤åŠŸèƒ½

### ğŸ¯ å®æ–½ç›®æ ‡
- [ ] å®ç°çº¿ç¨‹å®‰å…¨çš„çŠ¶æ€ç®¡ç†å™¨
- [ ] å»ºç«‹çŠ¶æ€è½¬æ¢éªŒè¯æœºåˆ¶
- [ ] å®ç°çŠ¶æ€æŒä¹…åŒ–ç­–ç•¥
- [ ] æ·»åŠ çŠ¶æ€å˜æ›´äº‹ä»¶å‘å¸ƒ
- [ ] æ”¯æŒæ‰¹é‡çŠ¶æ€æ›´æ–°æ“ä½œ

### ğŸ“‹ è¯¦ç»†å®æ–½æ­¥éª¤

#### 5.1 å®ç°æ ¸å¿ƒçŠ¶æ€ç®¡ç†å™¨
**æ‰§è¡Œå†…å®¹**:
- [ ] å®ç°ChannelStateManagerç»“æ„
- [ ] æ·»åŠ çŠ¶æ€è½¬æ¢éªŒè¯é€»è¾‘
- [ ] å®ç°çº¿ç¨‹å®‰å…¨çš„çŠ¶æ€æ“ä½œ
- [ ] æ·»åŠ çŠ¶æ€å˜æ›´æ—¥å¿—è®°å½•

**è¯¦ç»†æ‰§è¡Œæ­¥éª¤**:

**æ­¥éª¤5.1.1: åˆ›å»ºçŠ¶æ€ç®¡ç†å™¨æ¥å£å®šä¹‰**
åˆ›å»ºæ–‡ä»¶ `src/domain/services/channel_state_manager.rs`:
```rust
//! é€šé“çŠ¶æ€ç®¡ç†å™¨
//!
//! è¿™æ˜¯ç³»ç»Ÿä¸­å”¯ä¸€å…è®¸ä¿®æ”¹ ChannelTestInstance çŠ¶æ€çš„ç»„ä»¶
//! ç¬¦åˆ FAT-CSM-001 è§„åˆ™ï¼šçŠ¶æ€ç®¡ç†å”¯ä¸€å…¥å£

use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::RwLock;
use chrono::Utc;
use async_trait::async_trait;

use crate::domain::entities::{ChannelTestInstance, SubTestExecutionResult};
use crate::domain::enums::{OverallTestStatus, SubTestItem, TestExecutionStatus};
use crate::domain::services::{RawTestOutcome, IEventPublisher};
use crate::infrastructure::repositories::IChannelTestInstanceRepository;
use crate::infrastructure::errors::AppError;
use crate::infrastructure::events::StateChangedEvent;

/// çŠ¶æ€ç®¡ç†å™¨æ¥å£
///
/// å®šä¹‰äº†çŠ¶æ€ç®¡ç†çš„æ ¸å¿ƒæ“ä½œï¼Œç¡®ä¿çŠ¶æ€è½¬æ¢çš„ä¸€è‡´æ€§å’Œæ­£ç¡®æ€§
#[async_trait]
pub trait IChannelStateManager: Send + Sync {
    /// åº”ç”¨åŸå§‹æµ‹è¯•ç»“æœåˆ°å®ä¾‹çŠ¶æ€
    ///
    /// è¿™æ˜¯å”¯ä¸€å…è®¸ä¿®æ”¹å®ä¾‹çŠ¶æ€çš„æ–¹æ³•ï¼Œç¬¦åˆ FAT-CSM-001 è§„åˆ™
    async fn apply_raw_outcome(
        &self,
        instance: &mut ChannelTestInstance,
        outcome: RawTestOutcome,
    ) -> Result<(), AppError>;

    /// éªŒè¯çŠ¶æ€è½¬æ¢çš„åˆæ³•æ€§
    async fn validate_state_transition(
        &self,
        current_status: &OverallTestStatus,
        target_status: &OverallTestStatus,
    ) -> Result<bool, AppError>;

    /// è·å–å®ä¾‹å½“å‰çŠ¶æ€
    async fn get_instance_status(&self, instance_id: &str) -> Result<OverallTestStatus, AppError>;

    /// æ‰¹é‡æ›´æ–°å®ä¾‹çŠ¶æ€
    async fn batch_update_status(
        &self,
        updates: Vec<(String, OverallTestStatus)>,
    ) -> Result<(), AppError>;

    /// è·å–æ‰¹æ¬¡ä¸­æ‰€æœ‰å®ä¾‹
    async fn get_batch_instances(&self, batch_id: &str) -> Result<Vec<ChannelTestInstance>, AppError>;

    /// é‡ç½®å®ä¾‹çŠ¶æ€
    async fn reset_instance_status(
        &self,
        instance_id: &str,
        target_status: OverallTestStatus,
    ) -> Result<(), AppError>;
}

/// çŠ¶æ€è½¬æ¢è§„åˆ™å®šä¹‰
#[derive(Debug, Clone)]
pub struct StateTransitionRule {
    pub from: OverallTestStatus,
    pub to: OverallTestStatus,
    pub condition: Option<String>,
    pub description: String,
}

/// çŠ¶æ€ç®¡ç†å™¨å®ç°
pub struct ChannelStateManager {
    /// æ•°æ®ä»“åº“
    repository: Arc<dyn IChannelTestInstanceRepository>,
    /// äº‹ä»¶å‘å¸ƒå™¨
    event_publisher: Arc<dyn IEventPublisher>,
    /// çŠ¶æ€ç¼“å­˜
    state_cache: Arc<RwLock<HashMap<String, ChannelTestInstance>>>,
    /// çŠ¶æ€è½¬æ¢è§„åˆ™
    transition_rules: Vec<StateTransitionRule>,
    /// çŠ¶æ€å˜æ›´å†å²
    state_history: Arc<RwLock<Vec<StateChangeRecord>>>,
}

/// çŠ¶æ€å˜æ›´è®°å½•
#[derive(Debug, Clone)]
pub struct StateChangeRecord {
    pub instance_id: String,
    pub old_status: OverallTestStatus,
    pub new_status: OverallTestStatus,
    pub timestamp: chrono::DateTime<Utc>,
    pub reason: String,
    pub operator: Option<String>,
}

impl ChannelStateManager {
    /// åˆ›å»ºæ–°çš„çŠ¶æ€ç®¡ç†å™¨
    pub fn new(
        repository: Arc<dyn IChannelTestInstanceRepository>,
        event_publisher: Arc<dyn IEventPublisher>,
    ) -> Self {
        let transition_rules = Self::create_transition_rules();

        Self {
            repository,
            event_publisher,
            state_cache: Arc::new(RwLock::new(HashMap::new())),
            transition_rules,
            state_history: Arc::new(RwLock::new(Vec::new())),
        }
    }

    /// åˆ›å»ºçŠ¶æ€è½¬æ¢è§„åˆ™
    fn create_transition_rules() -> Vec<StateTransitionRule> {
        vec![
            StateTransitionRule {
                from: OverallTestStatus::NotTested,
                to: OverallTestStatus::WiringConfirmed,
                condition: None,
                description: "åˆå§‹çŠ¶æ€åˆ°æ¥çº¿ç¡®è®¤".to_string(),
            },
            StateTransitionRule {
                from: OverallTestStatus::WiringConfirmed,
                to: OverallTestStatus::HardPointTesting,
                condition: None,
                description: "æ¥çº¿ç¡®è®¤åˆ°ç¡¬ç‚¹æµ‹è¯•".to_string(),
            },
            StateTransitionRule {
                from: OverallTestStatus::HardPointTesting,
                to: OverallTestStatus::HardPointPassed,
                condition: Some("ç¡¬ç‚¹æµ‹è¯•é€šè¿‡".to_string()),
                description: "ç¡¬ç‚¹æµ‹è¯•é€šè¿‡".to_string(),
            },
            StateTransitionRule {
                from: OverallTestStatus::HardPointTesting,
                to: OverallTestStatus::HardPointFailed,
                condition: Some("ç¡¬ç‚¹æµ‹è¯•å¤±è´¥".to_string()),
                description: "ç¡¬ç‚¹æµ‹è¯•å¤±è´¥".to_string(),
            },
            StateTransitionRule {
                from: OverallTestStatus::HardPointPassed,
                to: OverallTestStatus::ManualTesting,
                condition: None,
                description: "ç¡¬ç‚¹é€šè¿‡åˆ°æ‰‹åŠ¨æµ‹è¯•".to_string(),
            },
            StateTransitionRule {
                from: OverallTestStatus::ManualTesting,
                to: OverallTestStatus::ManualPassed,
                condition: Some("æ‰‹åŠ¨æµ‹è¯•é€šè¿‡".to_string()),
                description: "æ‰‹åŠ¨æµ‹è¯•é€šè¿‡".to_string(),
            },
            StateTransitionRule {
                from: OverallTestStatus::ManualPassed,
                to: OverallTestStatus::AllCompleted,
                condition: None,
                description: "æ‰€æœ‰æµ‹è¯•å®Œæˆ".to_string(),
            },
            // é‡æ–°æµ‹è¯•è§„åˆ™
            StateTransitionRule {
                from: OverallTestStatus::HardPointFailed,
                to: OverallTestStatus::HardPointTesting,
                condition: Some("é‡æ–°å¼€å§‹ç¡¬ç‚¹æµ‹è¯•".to_string()),
                description: "é‡æ–°å¼€å§‹ç¡¬ç‚¹æµ‹è¯•".to_string(),
            },
            StateTransitionRule {
                from: OverallTestStatus::ManualPassed,
                to: OverallTestStatus::HardPointTesting,
                condition: Some("é‡æ–°å¼€å§‹å®Œæ•´æµ‹è¯•".to_string()),
                description: "é‡æ–°å¼€å§‹å®Œæ•´æµ‹è¯•".to_string(),
            },
        ]
    }
}
```

**æ­¥éª¤5.1.2: å®ç°æ ¸å¿ƒçŠ¶æ€ç®¡ç†é€»è¾‘**
ç»§ç»­åœ¨ `channel_state_manager.rs` ä¸­æ·»åŠ ï¼š
```rust
#[async_trait]
impl IChannelStateManager for ChannelStateManager {
    /// åº”ç”¨åŸå§‹æµ‹è¯•ç»“æœåˆ°å®ä¾‹çŠ¶æ€
    async fn apply_raw_outcome(
        &self,
        instance: &mut ChannelTestInstance,
        outcome: RawTestOutcome,
    ) -> Result<(), AppError> {
        log::info!("å¼€å§‹åº”ç”¨æµ‹è¯•ç»“æœ: å®ä¾‹ {}, æµ‹è¯•é¡¹ {:?}",
                  instance.instance_id, outcome.test_item);

        // è®°å½•åŸå§‹çŠ¶æ€
        let old_status = instance.overall_status.clone();

        // ç¡®å®šæ–°çŠ¶æ€
        let new_status = self.determine_new_status(&instance.overall_status, &outcome)?;

        // éªŒè¯çŠ¶æ€è½¬æ¢çš„åˆæ³•æ€§
        if old_status != new_status {
            self.validate_state_transition(&old_status, &new_status).await?;
        }

        // æ›´æ–°å­æµ‹è¯•ç»“æœ
        let sub_result = SubTestExecutionResult {
            test_item: outcome.test_item.clone(),
            status: TestExecutionStatus::Completed,
            result: outcome.result.clone(),
            error_message: outcome.error_message.clone(),
            execution_time: outcome.execution_time,
            duration_ms: outcome.duration_ms,
            test_values: outcome.test_values.clone(),
        };

        instance.sub_test_results.insert(outcome.test_item, sub_result);

        // æ›´æ–°æ•´ä½“çŠ¶æ€
        instance.overall_status = new_status.clone();
        instance.updated_time = Utc::now();

        // è®°å½•çŠ¶æ€å˜æ›´å†å²
        self.record_state_change(
            &instance.instance_id,
            old_status.clone(),
            new_status.clone(),
            format!("æµ‹è¯•ç»“æœåº”ç”¨: {:?} -> {:?}", outcome.test_item, outcome.result),
            None,
        ).await;

        // æŒä¹…åŒ–åˆ°æ•°æ®åº“
        self.repository.save(instance).await?;

        // æ›´æ–°ç¼“å­˜
        {
            let mut cache = self.state_cache.write().await;
            cache.insert(instance.instance_id.clone(), instance.clone());
        }

        // å‘å¸ƒçŠ¶æ€å˜æ›´äº‹ä»¶
        if old_status != new_status {
            self.event_publisher.publish_state_changed(StateChangedEvent {
                instance_id: instance.instance_id.clone(),
                old_status: old_status.clone(),
                new_status: new_status.clone(),
                timestamp: Utc::now(),
                batch_id: instance.batch_id.clone(),
                test_item: Some(outcome.test_item),
                test_result: Some(outcome.result),
            }).await?;
        }

        log::info!(
            "çŠ¶æ€æ›´æ–°å®Œæˆ: å®ä¾‹ {}, {} -> {}, è€—æ—¶ {}ms",
            instance.instance_id,
            format!("{:?}", old_status),
            format!("{:?}", new_status),
            outcome.duration_ms
        );

        Ok(())
    }

    /// éªŒè¯çŠ¶æ€è½¬æ¢çš„åˆæ³•æ€§
    async fn validate_state_transition(
        &self,
        current_status: &OverallTestStatus,
        target_status: &OverallTestStatus,
    ) -> Result<bool, AppError> {
        // ç›¸åŒçŠ¶æ€ä¸éœ€è¦éªŒè¯
        if current_status == target_status {
            return Ok(true);
        }

        // æŸ¥æ‰¾åŒ¹é…çš„è½¬æ¢è§„åˆ™
        let valid_transition = self.transition_rules.iter()
            .any(|rule| rule.from == *current_status && rule.to == *target_status);

        if !valid_transition {
            let error_msg = format!(
                "éæ³•çŠ¶æ€è½¬æ¢: {:?} -> {:?}ã€‚å…è®¸çš„è½¬æ¢: {}",
                current_status,
                target_status,
                self.get_valid_transitions(current_status)
            );

            log::error!("{}", error_msg);
            return Err(AppError::StateTransitionError(error_msg));
        }

        log::debug!("çŠ¶æ€è½¬æ¢éªŒè¯é€šè¿‡: {:?} -> {:?}", current_status, target_status);
        Ok(true)
    }

    /// è·å–å®ä¾‹å½“å‰çŠ¶æ€
    async fn get_instance_status(&self, instance_id: &str) -> Result<OverallTestStatus, AppError> {
        // å…ˆä»ç¼“å­˜æŸ¥æ‰¾
        {
            let cache = self.state_cache.read().await;
            if let Some(instance) = cache.get(instance_id) {
                return Ok(instance.overall_status.clone());
            }
        }

        // ç¼“å­˜æœªå‘½ä¸­ï¼Œä»æ•°æ®åº“æŸ¥æ‰¾
        let instance = self.repository.get_by_id(instance_id).await?
            .ok_or_else(|| AppError::NotFound(format!("å®ä¾‹æœªæ‰¾åˆ°: {}", instance_id)))?;

        // æ›´æ–°ç¼“å­˜
        {
            let mut cache = self.state_cache.write().await;
            cache.insert(instance_id.to_string(), instance.clone());
        }

        Ok(instance.overall_status)
    }

    /// æ‰¹é‡æ›´æ–°å®ä¾‹çŠ¶æ€
    async fn batch_update_status(
        &self,
        updates: Vec<(String, OverallTestStatus)>,
    ) -> Result<(), AppError> {
        log::info!("å¼€å§‹æ‰¹é‡æ›´æ–°çŠ¶æ€ï¼Œå…± {} ä¸ªå®ä¾‹", updates.len());

        let mut successful_updates = 0;
        let mut failed_updates = Vec::new();

        for (instance_id, target_status) in updates {
            match self.update_single_instance_status(&instance_id, target_status).await {
                Ok(()) => {
                    successful_updates += 1;
                }
                Err(e) => {
                    failed_updates.push((instance_id, e));
                }
            }
        }

        log::info!("æ‰¹é‡æ›´æ–°å®Œæˆï¼šæˆåŠŸ {} ä¸ªï¼Œå¤±è´¥ {} ä¸ª",
                  successful_updates, failed_updates.len());

        if !failed_updates.is_empty() {
            let error_details: Vec<String> = failed_updates.iter()
                .map(|(id, err)| format!("{}: {}", id, err))
                .collect();
            return Err(AppError::BatchOperationError(
                format!("éƒ¨åˆ†æ›´æ–°å¤±è´¥: {}", error_details.join(", "))
            ));
        }

        Ok(())
    }

    /// è·å–æ‰¹æ¬¡ä¸­æ‰€æœ‰å®ä¾‹
    async fn get_batch_instances(&self, batch_id: &str) -> Result<Vec<ChannelTestInstance>, AppError> {
        log::debug!("è·å–æ‰¹æ¬¡å®ä¾‹: {}", batch_id);

        // ä»æ•°æ®åº“æŸ¥è¯¢æ‰¹æ¬¡å®ä¾‹
        let instances = self.repository.get_by_batch_id(batch_id).await?;

        // æ›´æ–°ç¼“å­˜
        {
            let mut cache = self.state_cache.write().await;
            for instance in &instances {
                cache.insert(instance.instance_id.clone(), instance.clone());
            }
        }

        log::debug!("æ‰¹æ¬¡ {} åŒ…å« {} ä¸ªå®ä¾‹", batch_id, instances.len());
        Ok(instances)
    }

    /// é‡ç½®å®ä¾‹çŠ¶æ€
    async fn reset_instance_status(
        &self,
        instance_id: &str,
        target_status: OverallTestStatus,
    ) -> Result<(), AppError> {
        log::info!("é‡ç½®å®ä¾‹çŠ¶æ€: {} -> {:?}", instance_id, target_status);

        // è·å–å½“å‰å®ä¾‹
        let mut instance = self.repository.get_by_id(instance_id).await?
            .ok_or_else(|| AppError::NotFound(format!("å®ä¾‹æœªæ‰¾åˆ°: {}", instance_id)))?;

        let old_status = instance.overall_status.clone();

        // éªŒè¯é‡ç½®æ“ä½œçš„åˆæ³•æ€§
        self.validate_reset_operation(&old_status, &target_status)?;

        // æ¸…ç†ç›¸å…³çš„å­æµ‹è¯•ç»“æœ
        if target_status == OverallTestStatus::NotTested {
            instance.sub_test_results.clear();
        }

        // æ›´æ–°çŠ¶æ€
        instance.overall_status = target_status.clone();
        instance.updated_time = Utc::now();

        // è®°å½•çŠ¶æ€å˜æ›´
        self.record_state_change(
            instance_id,
            old_status.clone(),
            target_status.clone(),
            "æ‰‹åŠ¨é‡ç½®çŠ¶æ€".to_string(),
            Some("ç³»ç»Ÿç®¡ç†å‘˜".to_string()),
        ).await;

        // æŒä¹…åŒ–
        self.repository.save(&instance).await?;

        // æ›´æ–°ç¼“å­˜
        {
            let mut cache = self.state_cache.write().await;
            cache.insert(instance_id.to_string(), instance.clone());
        }

        // å‘å¸ƒäº‹ä»¶
        self.event_publisher.publish_state_changed(StateChangedEvent {
            instance_id: instance_id.to_string(),
            old_status,
            new_status: target_status,
            timestamp: Utc::now(),
            batch_id: instance.batch_id,
            test_item: None,
            test_result: None,
        }).await?;

        log::info!("å®ä¾‹çŠ¶æ€é‡ç½®å®Œæˆ: {}", instance_id);
        Ok(())
    }
}

impl ChannelStateManager {
    /// ç¡®å®šæ–°çŠ¶æ€
    fn determine_new_status(
        &self,
        current_status: &OverallTestStatus,
        outcome: &RawTestOutcome,
    ) -> Result<OverallTestStatus, AppError> {
        use OverallTestStatus::*;
        use crate::domain::services::TestResult;

        match outcome.test_item {
            SubTestItem::HardPoint => {
                match outcome.result {
                    TestResult::Pass => {
                        // ç¡¬ç‚¹æµ‹è¯•é€šè¿‡ï¼Œè½¬æ¢åˆ°ç¡¬ç‚¹é€šè¿‡çŠ¶æ€
                        Ok(HardPointPassed)
                    }
                    TestResult::Fail => {
                        // ç¡¬ç‚¹æµ‹è¯•å¤±è´¥
                        Ok(HardPointFailed)
                    }
                    TestResult::NotTested => {
                        // ä¿æŒå½“å‰çŠ¶æ€
                        Ok(current_status.clone())
                    }
                }
            }
            SubTestItem::Manual => {
                match outcome.result {
                    TestResult::Pass => Ok(ManualPassed),
                    TestResult::Fail => Ok(ManualTesting), // æ‰‹åŠ¨æµ‹è¯•å¤±è´¥ä¿æŒåœ¨æµ‹è¯•çŠ¶æ€
                    TestResult::NotTested => Ok(current_status.clone()),
                }
            }
            _ => {
                // å…¶ä»–æµ‹è¯•é¡¹ç›®æš‚æ—¶ä¿æŒå½“å‰çŠ¶æ€
                Ok(current_status.clone())
            }
        }
    }

    /// è·å–æœ‰æ•ˆçš„çŠ¶æ€è½¬æ¢
    fn get_valid_transitions(&self, current_status: &OverallTestStatus) -> String {
        let valid_transitions: Vec<String> = self.transition_rules.iter()
            .filter(|rule| rule.from == *current_status)
            .map(|rule| format!("{:?}", rule.to))
            .collect();

        if valid_transitions.is_empty() {
            "æ— å¯ç”¨è½¬æ¢".to_string()
        } else {
            valid_transitions.join(", ")
        }
    }

    /// è®°å½•çŠ¶æ€å˜æ›´å†å²
    async fn record_state_change(
        &self,
        instance_id: &str,
        old_status: OverallTestStatus,
        new_status: OverallTestStatus,
        reason: String,
        operator: Option<String>,
    ) {
        let record = StateChangeRecord {
            instance_id: instance_id.to_string(),
            old_status,
            new_status,
            timestamp: Utc::now(),
            reason,
            operator,
        };

        let mut history = self.state_history.write().await;
        history.push(record);

        // ä¿æŒå†å²è®°å½•åœ¨åˆç†èŒƒå›´å†…ï¼ˆæœ€å¤š1000æ¡ï¼‰
        if history.len() > 1000 {
            history.drain(0..100); // ç§»é™¤æœ€æ—§çš„100æ¡è®°å½•
        }
    }

    /// æ›´æ–°å•ä¸ªå®ä¾‹çŠ¶æ€
    async fn update_single_instance_status(
        &self,
        instance_id: &str,
        target_status: OverallTestStatus,
    ) -> Result<(), AppError> {
        let mut instance = self.repository.get_by_id(instance_id).await?
            .ok_or_else(|| AppError::NotFound(format!("å®ä¾‹æœªæ‰¾åˆ°: {}", instance_id)))?;

        let old_status = instance.overall_status.clone();

        // éªŒè¯çŠ¶æ€è½¬æ¢
        if old_status != target_status {
            self.validate_state_transition(&old_status, &target_status).await?;
        }

        // æ›´æ–°çŠ¶æ€
        instance.overall_status = target_status.clone();
        instance.updated_time = Utc::now();

        // æŒä¹…åŒ–
        self.repository.save(&instance).await?;

        // æ›´æ–°ç¼“å­˜
        {
            let mut cache = self.state_cache.write().await;
            cache.insert(instance_id.to_string(), instance.clone());
        }

        Ok(())
    }

    /// éªŒè¯é‡ç½®æ“ä½œçš„åˆæ³•æ€§
    fn validate_reset_operation(
        &self,
        current_status: &OverallTestStatus,
        target_status: &OverallTestStatus,
    ) -> Result<(), AppError> {
        use OverallTestStatus::*;

        // å®šä¹‰å…è®¸çš„é‡ç½®æ“ä½œ
        let valid_resets = match target_status {
            NotTested => true, // æ€»æ˜¯å¯ä»¥é‡ç½®åˆ°åˆå§‹çŠ¶æ€
            WiringConfirmed => matches!(current_status, HardPointTesting | HardPointFailed | HardPointPassed),
            HardPointTesting => matches!(current_status, HardPointFailed | HardPointPassed | ManualTesting | ManualPassed),
            _ => false, // å…¶ä»–çŠ¶æ€ä¸å…è®¸ç›´æ¥é‡ç½®
        };

        if !valid_resets {
            return Err(AppError::StateTransitionError(
                format!("ä¸å…è®¸ä» {:?} é‡ç½®åˆ° {:?}", current_status, target_status)
            ));
        }

        Ok(())
    }

    /// è·å–çŠ¶æ€å˜æ›´å†å²
    pub async fn get_state_history(&self, instance_id: Option<&str>) -> Vec<StateChangeRecord> {
        let history = self.state_history.read().await;

        match instance_id {
            Some(id) => history.iter()
                .filter(|record| record.instance_id == id)
                .cloned()
                .collect(),
            None => history.clone(),
        }
    }

    /// è·å–çŠ¶æ€ç»Ÿè®¡ä¿¡æ¯
    pub async fn get_status_statistics(&self, batch_id: &str) -> Result<StatusStatistics, AppError> {
        let instances = self.get_batch_instances(batch_id).await?;

        let mut stats = StatusStatistics::default();
        stats.total_count = instances.len();

        for instance in instances {
            match instance.overall_status {
                OverallTestStatus::NotTested => stats.not_tested += 1,
                OverallTestStatus::WiringConfirmed => stats.wiring_confirmed += 1,
                OverallTestStatus::HardPointTesting => stats.hard_point_testing += 1,
                OverallTestStatus::HardPointPassed => stats.hard_point_passed += 1,
                OverallTestStatus::HardPointFailed => stats.hard_point_failed += 1,
                OverallTestStatus::ManualTesting => stats.manual_testing += 1,
                OverallTestStatus::ManualPassed => stats.manual_passed += 1,
                OverallTestStatus::AllCompleted => stats.all_completed += 1,
            }
        }

        Ok(stats)
    }
}

/// çŠ¶æ€ç»Ÿè®¡ä¿¡æ¯
#[derive(Debug, Clone, Default)]
pub struct StatusStatistics {
    pub total_count: usize,
    pub not_tested: usize,
    pub wiring_confirmed: usize,
    pub hard_point_testing: usize,
    pub hard_point_passed: usize,
    pub hard_point_failed: usize,
    pub manual_testing: usize,
    pub manual_passed: usize,
    pub all_completed: usize,
}

impl StatusStatistics {
    pub fn completion_rate(&self) -> f64 {
        if self.total_count == 0 {
            0.0
        } else {
            (self.all_completed as f64 / self.total_count as f64) * 100.0
        }
    }

    pub fn pass_rate(&self) -> f64 {
        if self.total_count == 0 {
            0.0
        } else {
            let passed = self.hard_point_passed + self.manual_passed + self.all_completed;
            (passed as f64 / self.total_count as f64) * 100.0
        }
    }
}
```

**æ­¥éª¤5.1.3: æ·»åŠ çŠ¶æ€ç®¡ç†å™¨æµ‹è¯•**
åˆ›å»ºæ–‡ä»¶ `src/domain/services/channel_state_manager_tests.rs`:
```rust
#[cfg(test)]
mod tests {
    use super::*;
    use crate::infrastructure::repositories::MockChannelTestInstanceRepository;
    use crate::infrastructure::events::MockEventPublisher;
    use mockall::predicate::*;
    use tokio_test;

    fn create_test_instance() -> ChannelTestInstance {
        ChannelTestInstance {
            instance_id: "test_instance_1".to_string(),
            definition_id: "def_1".to_string(),
            batch_id: "batch_1".to_string(),
            overall_status: OverallTestStatus::NotTested,
            sub_test_results: HashMap::new(),
            created_time: Utc::now(),
            updated_time: Utc::now(),
        }
    }

    #[tokio::test]
    async fn test_apply_raw_outcome_success() {
        // å‡†å¤‡
        let mut mock_repo = MockChannelTestInstanceRepository::new();
        let mut mock_publisher = MockEventPublisher::new();

        mock_repo.expect_save()
            .times(1)
            .returning(|_| Ok(()));

        mock_publisher.expect_publish_state_changed()
            .times(1)
            .returning(|_| Ok(()));

        let state_manager = ChannelStateManager::new(
            Arc::new(mock_repo),
            Arc::new(mock_publisher),
        );

        let mut instance = create_test_instance();
        let outcome = RawTestOutcome {
            test_item: SubTestItem::HardPoint,
            result: TestResult::Pass,
            test_values: vec![],
            error_message: None,
            execution_time: Utc::now(),
            duration_ms: 1000,
        };

        // æ‰§è¡Œ
        let result = state_manager.apply_raw_outcome(&mut instance, outcome).await;

        // éªŒè¯
        assert!(result.is_ok());
        assert_eq!(instance.overall_status, OverallTestStatus::HardPointPassed);
        assert!(instance.sub_test_results.contains_key(&SubTestItem::HardPoint));
    }

    #[tokio::test]
    async fn test_validate_state_transition_valid() {
        let mock_repo = MockChannelTestInstanceRepository::new();
        let mock_publisher = MockEventPublisher::new();

        let state_manager = ChannelStateManager::new(
            Arc::new(mock_repo),
            Arc::new(mock_publisher),
        );

        // æµ‹è¯•æœ‰æ•ˆè½¬æ¢
        let result = state_manager.validate_state_transition(
            &OverallTestStatus::NotTested,
            &OverallTestStatus::WiringConfirmed,
        ).await;

        assert!(result.is_ok());
        assert_eq!(result.unwrap(), true);
    }

    #[tokio::test]
    async fn test_validate_state_transition_invalid() {
        let mock_repo = MockChannelTestInstanceRepository::new();
        let mock_publisher = MockEventPublisher::new();

        let state_manager = ChannelStateManager::new(
            Arc::new(mock_repo),
            Arc::new(mock_publisher),
        );

        // æµ‹è¯•æ— æ•ˆè½¬æ¢
        let result = state_manager.validate_state_transition(
            &OverallTestStatus::NotTested,
            &OverallTestStatus::AllCompleted,
        ).await;

        assert!(result.is_err());
        assert!(matches!(result.unwrap_err(), AppError::StateTransitionError(_)));
    }

    #[tokio::test]
    async fn test_batch_update_status() {
        let mut mock_repo = MockChannelTestInstanceRepository::new();
        let mock_publisher = MockEventPublisher::new();

        // è®¾ç½®mockæœŸæœ›
        mock_repo.expect_get_by_id()
            .times(2)
            .returning(|_| Ok(Some(create_test_instance())));

        mock_repo.expect_save()
            .times(2)
            .returning(|_| Ok(()));

        let state_manager = ChannelStateManager::new(
            Arc::new(mock_repo),
            Arc::new(mock_publisher),
        );

        let updates = vec![
            ("instance_1".to_string(), OverallTestStatus::WiringConfirmed),
            ("instance_2".to_string(), OverallTestStatus::WiringConfirmed),
        ];

        let result = state_manager.batch_update_status(updates).await;
        assert!(result.is_ok());
    }
}
```

**éªŒè¯æ£€æŸ¥ç‚¹**:
- [ ] çŠ¶æ€ç®¡ç†å™¨ç¬¦åˆFAT-CSM-001è§„åˆ™
- [ ] çŠ¶æ€è½¬æ¢éªŒè¯æœºåˆ¶æ­£å¸¸å·¥ä½œ
- [ ] çº¿ç¨‹å®‰å…¨çš„çŠ¶æ€æ“ä½œ
- [ ] çŠ¶æ€å˜æ›´äº‹ä»¶æ­£ç¡®å‘å¸ƒ
- [ ] æ‰¹é‡æ“ä½œåŠŸèƒ½å®Œæ•´

#### 5.2 å®ç°çŠ¶æ€æŒä¹…åŒ–ç­–ç•¥
**æ‰§è¡Œå†…å®¹**:
- [ ] å®ç°çŠ¶æ€ç¼“å­˜æœºåˆ¶
- [ ] æ·»åŠ æ•°æ®åº“æŒä¹…åŒ–
- [ ] å®ç°çŠ¶æ€æ¢å¤åŠŸèƒ½
- [ ] ä¼˜åŒ–æŸ¥è¯¢æ€§èƒ½

**è¯¦ç»†æ‰§è¡Œæ­¥éª¤**:

**æ­¥éª¤5.2.1: åˆ›å»ºçŠ¶æ€æŒä¹…åŒ–æœåŠ¡**
åˆ›å»ºæ–‡ä»¶ `src/infrastructure/persistence/state_persistence_service.rs`:
```rust
//! çŠ¶æ€æŒä¹…åŒ–æœåŠ¡
//!
//! è´Ÿè´£çŠ¶æ€æ•°æ®çš„æŒä¹…åŒ–å’Œæ¢å¤

use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::RwLock;
use chrono::{DateTime, Utc};
use serde::{Serialize, Deserialize};

use crate::domain::entities::ChannelTestInstance;
use crate::domain::enums::OverallTestStatus;
use crate::infrastructure::errors::AppError;

/// çŠ¶æ€å¿«ç…§
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StateSnapshot {
    pub snapshot_id: String,
    pub batch_id: String,
    pub timestamp: DateTime<Utc>,
    pub instances: Vec<ChannelTestInstance>,
    pub metadata: HashMap<String, String>,
}

/// çŠ¶æ€æŒä¹…åŒ–æœåŠ¡æ¥å£
#[async_trait::async_trait]
pub trait IStatePersistenceService: Send + Sync {
    /// åˆ›å»ºçŠ¶æ€å¿«ç…§
    async fn create_snapshot(
        &self,
        batch_id: &str,
        instances: Vec<ChannelTestInstance>,
    ) -> Result<String, AppError>;

    /// æ¢å¤çŠ¶æ€å¿«ç…§
    async fn restore_snapshot(&self, snapshot_id: &str) -> Result<StateSnapshot, AppError>;

    /// è·å–æ‰¹æ¬¡çš„æœ€æ–°å¿«ç…§
    async fn get_latest_snapshot(&self, batch_id: &str) -> Result<Option<StateSnapshot>, AppError>;

    /// æ¸…ç†è¿‡æœŸå¿«ç…§
    async fn cleanup_expired_snapshots(&self, retention_days: u32) -> Result<usize, AppError>;

    /// è·å–å¿«ç…§åˆ—è¡¨
    async fn list_snapshots(&self, batch_id: Option<&str>) -> Result<Vec<StateSnapshot>, AppError>;
}

/// çŠ¶æ€æŒä¹…åŒ–æœåŠ¡å®ç°
pub struct StatePersistenceService {
    /// æ•°æ®åº“è¿æ¥
    db_pool: Arc<sqlx::SqlitePool>,
    /// å†…å­˜ç¼“å­˜
    cache: Arc<RwLock<HashMap<String, StateSnapshot>>>,
    /// æœ€å¤§ç¼“å­˜å¤§å°
    max_cache_size: usize,
}

impl StatePersistenceService {
    pub fn new(db_pool: Arc<sqlx::SqlitePool>) -> Self {
        Self {
            db_pool,
            cache: Arc::new(RwLock::new(HashMap::new())),
            max_cache_size: 100, // æœ€å¤šç¼“å­˜100ä¸ªå¿«ç…§
        }
    }

    /// åˆå§‹åŒ–æ•°æ®åº“è¡¨
    pub async fn initialize_tables(&self) -> Result<(), AppError> {
        let sql = r#"
            CREATE TABLE IF NOT EXISTS state_snapshots (
                snapshot_id TEXT PRIMARY KEY,
                batch_id TEXT NOT NULL,
                timestamp TEXT NOT NULL,
                instances_data TEXT NOT NULL,
                metadata TEXT,
                created_at TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP,
                INDEX idx_batch_id (batch_id),
                INDEX idx_timestamp (timestamp)
            );
        "#;

        sqlx::query(sql)
            .execute(&*self.db_pool)
            .await
            .map_err(|e| AppError::DatabaseError(e.to_string()))?;

        log::info!("çŠ¶æ€æŒä¹…åŒ–è¡¨åˆå§‹åŒ–å®Œæˆ");
        Ok(())
    }
}

#[async_trait::async_trait]
impl IStatePersistenceService for StatePersistenceService {
    async fn create_snapshot(
        &self,
        batch_id: &str,
        instances: Vec<ChannelTestInstance>,
    ) -> Result<String, AppError> {
        let snapshot_id = uuid::Uuid::new_v4().to_string();
        let timestamp = Utc::now();

        // åºåˆ—åŒ–å®ä¾‹æ•°æ®
        let instances_json = serde_json::to_string(&instances)
            .map_err(|e| AppError::SerializationError(e.to_string()))?;

        // åˆ›å»ºå…ƒæ•°æ®
        let mut metadata = HashMap::new();
        metadata.insert("instance_count".to_string(), instances.len().to_string());
        metadata.insert("created_by".to_string(), "system".to_string());

        let metadata_json = serde_json::to_string(&metadata)
            .map_err(|e| AppError::SerializationError(e.to_string()))?;

        // ä¿å­˜åˆ°æ•°æ®åº“
        let sql = r#"
            INSERT INTO state_snapshots (snapshot_id, batch_id, timestamp, instances_data, metadata)
            VALUES (?, ?, ?, ?, ?)
        "#;

        sqlx::query(sql)
            .bind(&snapshot_id)
            .bind(batch_id)
            .bind(timestamp.to_rfc3339())
            .bind(&instances_json)
            .bind(&metadata_json)
            .execute(&*self.db_pool)
            .await
            .map_err(|e| AppError::DatabaseError(e.to_string()))?;

        // åˆ›å»ºå¿«ç…§å¯¹è±¡
        let snapshot = StateSnapshot {
            snapshot_id: snapshot_id.clone(),
            batch_id: batch_id.to_string(),
            timestamp,
            instances,
            metadata,
        };

        // æ›´æ–°ç¼“å­˜
        self.update_cache(snapshot).await;

        log::info!("åˆ›å»ºçŠ¶æ€å¿«ç…§: {} (æ‰¹æ¬¡: {})", snapshot_id, batch_id);
        Ok(snapshot_id)
    }

    async fn restore_snapshot(&self, snapshot_id: &str) -> Result<StateSnapshot, AppError> {
        // å…ˆä»ç¼“å­˜æŸ¥æ‰¾
        {
            let cache = self.cache.read().await;
            if let Some(snapshot) = cache.get(snapshot_id) {
                log::debug!("ä»ç¼“å­˜æ¢å¤å¿«ç…§: {}", snapshot_id);
                return Ok(snapshot.clone());
            }
        }

        // ä»æ•°æ®åº“æŸ¥æ‰¾
        let sql = r#"
            SELECT snapshot_id, batch_id, timestamp, instances_data, metadata
            FROM state_snapshots
            WHERE snapshot_id = ?
        "#;

        let row = sqlx::query(sql)
            .bind(snapshot_id)
            .fetch_optional(&*self.db_pool)
            .await
            .map_err(|e| AppError::DatabaseError(e.to_string()))?
            .ok_or_else(|| AppError::NotFound(format!("å¿«ç…§æœªæ‰¾åˆ°: {}", snapshot_id)))?;

        // ååºåˆ—åŒ–æ•°æ®
        let instances_json: String = row.get("instances_data");
        let instances: Vec<ChannelTestInstance> = serde_json::from_str(&instances_json)
            .map_err(|e| AppError::DeserializationError(e.to_string()))?;

        let metadata_json: Option<String> = row.get("metadata");
        let metadata: HashMap<String, String> = match metadata_json {
            Some(json) => serde_json::from_str(&json)
                .map_err(|e| AppError::DeserializationError(e.to_string()))?,
            None => HashMap::new(),
        };

        let timestamp_str: String = row.get("timestamp");
        let timestamp = DateTime::parse_from_rfc3339(&timestamp_str)
            .map_err(|e| AppError::ParseError(e.to_string()))?
            .with_timezone(&Utc);

        let snapshot = StateSnapshot {
            snapshot_id: row.get("snapshot_id"),
            batch_id: row.get("batch_id"),
            timestamp,
            instances,
            metadata,
        };

        // æ›´æ–°ç¼“å­˜
        self.update_cache(snapshot.clone()).await;

        log::info!("ä»æ•°æ®åº“æ¢å¤å¿«ç…§: {}", snapshot_id);
        Ok(snapshot)
    }

    async fn get_latest_snapshot(&self, batch_id: &str) -> Result<Option<StateSnapshot>, AppError> {
        let sql = r#"
            SELECT snapshot_id, batch_id, timestamp, instances_data, metadata
            FROM state_snapshots
            WHERE batch_id = ?
            ORDER BY timestamp DESC
            LIMIT 1
        "#;

        let row = sqlx::query(sql)
            .bind(batch_id)
            .fetch_optional(&*self.db_pool)
            .await
            .map_err(|e| AppError::DatabaseError(e.to_string()))?;

        match row {
            Some(row) => {
                let snapshot_id: String = row.get("snapshot_id");
                let snapshot = self.restore_snapshot(&snapshot_id).await?;
                Ok(Some(snapshot))
            }
            None => Ok(None),
        }
    }

    async fn cleanup_expired_snapshots(&self, retention_days: u32) -> Result<usize, AppError> {
        let cutoff_date = Utc::now() - chrono::Duration::days(retention_days as i64);

        let sql = r#"
            DELETE FROM state_snapshots
            WHERE timestamp < ?
        "#;

        let result = sqlx::query(sql)
            .bind(cutoff_date.to_rfc3339())
            .execute(&*self.db_pool)
            .await
            .map_err(|e| AppError::DatabaseError(e.to_string()))?;

        let deleted_count = result.rows_affected() as usize;

        // æ¸…ç†ç¼“å­˜ä¸­çš„è¿‡æœŸå¿«ç…§
        {
            let mut cache = self.cache.write().await;
            cache.retain(|_, snapshot| snapshot.timestamp > cutoff_date);
        }

        log::info!("æ¸…ç†è¿‡æœŸå¿«ç…§: {} ä¸ª", deleted_count);
        Ok(deleted_count)
    }

    async fn list_snapshots(&self, batch_id: Option<&str>) -> Result<Vec<StateSnapshot>, AppError> {
        let (sql, params): (String, Vec<String>) = match batch_id {
            Some(id) => (
                "SELECT snapshot_id FROM state_snapshots WHERE batch_id = ? ORDER BY timestamp DESC".to_string(),
                vec![id.to_string()]
            ),
            None => (
                "SELECT snapshot_id FROM state_snapshots ORDER BY timestamp DESC".to_string(),
                vec![]
            ),
        };

        let mut query = sqlx::query(&sql);
        for param in params {
            query = query.bind(param);
        }

        let rows = query
            .fetch_all(&*self.db_pool)
            .await
            .map_err(|e| AppError::DatabaseError(e.to_string()))?;

        let mut snapshots = Vec::new();
        for row in rows {
            let snapshot_id: String = row.get("snapshot_id");
            match self.restore_snapshot(&snapshot_id).await {
                Ok(snapshot) => snapshots.push(snapshot),
                Err(e) => log::warn!("æ— æ³•æ¢å¤å¿«ç…§ {}: {}", snapshot_id, e),
            }
        }

        Ok(snapshots)
    }
}

impl StatePersistenceService {
    /// æ›´æ–°ç¼“å­˜
    async fn update_cache(&self, snapshot: StateSnapshot) {
        let mut cache = self.cache.write().await;

        // å¦‚æœç¼“å­˜å·²æ»¡ï¼Œç§»é™¤æœ€æ—§çš„å¿«ç…§
        if cache.len() >= self.max_cache_size {
            if let Some(oldest_key) = cache.iter()
                .min_by_key(|(_, snapshot)| snapshot.timestamp)
                .map(|(key, _)| key.clone()) {
                cache.remove(&oldest_key);
            }
        }

        cache.insert(snapshot.snapshot_id.clone(), snapshot);
    }

    /// è·å–ç¼“å­˜ç»Ÿè®¡ä¿¡æ¯
    pub async fn get_cache_stats(&self) -> (usize, usize) {
        let cache = self.cache.read().await;
        (cache.len(), self.max_cache_size)
    }
}
```

**æ­¥éª¤5.2.2: å®ç°çŠ¶æ€æ¢å¤æœºåˆ¶**
åˆ›å»ºæ–‡ä»¶ `src/application/services/state_recovery_service.rs`:
```rust
//! çŠ¶æ€æ¢å¤æœåŠ¡
//!
//! è´Ÿè´£ç³»ç»Ÿé‡å¯åçš„çŠ¶æ€æ¢å¤

use std::sync::Arc;
use chrono::Utc;

use crate::domain::services::IChannelStateManager;
use crate::infrastructure::persistence::IStatePersistenceService;
use crate::infrastructure::errors::AppError;

/// çŠ¶æ€æ¢å¤æœåŠ¡
pub struct StateRecoveryService {
    state_manager: Arc<dyn IChannelStateManager>,
    persistence_service: Arc<dyn IStatePersistenceService>,
}

impl StateRecoveryService {
    pub fn new(
        state_manager: Arc<dyn IChannelStateManager>,
        persistence_service: Arc<dyn IStatePersistenceService>,
    ) -> Self {
        Self {
            state_manager,
            persistence_service,
        }
    }

    /// æ¢å¤æ‰¹æ¬¡çŠ¶æ€
    pub async fn recover_batch_state(&self, batch_id: &str) -> Result<bool, AppError> {
        log::info!("å¼€å§‹æ¢å¤æ‰¹æ¬¡çŠ¶æ€: {}", batch_id);

        // è·å–æœ€æ–°å¿«ç…§
        let snapshot = match self.persistence_service.get_latest_snapshot(batch_id).await? {
            Some(snapshot) => snapshot,
            None => {
                log::warn!("æ‰¹æ¬¡ {} æ²¡æœ‰æ‰¾åˆ°çŠ¶æ€å¿«ç…§", batch_id);
                return Ok(false);
            }
        };

        log::info!("æ‰¾åˆ°å¿«ç…§: {} (æ—¶é—´: {})", snapshot.snapshot_id, snapshot.timestamp);

        // æ¢å¤æ¯ä¸ªå®ä¾‹çš„çŠ¶æ€
        let mut recovered_count = 0;
        let mut failed_count = 0;

        for instance in snapshot.instances {
            match self.state_manager.get_instance_status(&instance.instance_id).await {
                Ok(current_status) => {
                    // å¦‚æœå½“å‰çŠ¶æ€ä¸å¿«ç…§çŠ¶æ€ä¸åŒï¼Œéœ€è¦æ¢å¤
                    if current_status != instance.overall_status {
                        match self.state_manager.reset_instance_status(
                            &instance.instance_id,
                            instance.overall_status.clone(),
                        ).await {
                            Ok(()) => {
                                recovered_count += 1;
                                log::debug!("æ¢å¤å®ä¾‹çŠ¶æ€: {} -> {:?}",
                                          instance.instance_id, instance.overall_status);
                            }
                            Err(e) => {
                                failed_count += 1;
                                log::error!("æ¢å¤å®ä¾‹çŠ¶æ€å¤±è´¥: {} - {}", instance.instance_id, e);
                            }
                        }
                    }
                }
                Err(e) => {
                    failed_count += 1;
                    log::error!("è·å–å®ä¾‹çŠ¶æ€å¤±è´¥: {} - {}", instance.instance_id, e);
                }
            }
        }

        log::info!("æ‰¹æ¬¡çŠ¶æ€æ¢å¤å®Œæˆ: æˆåŠŸ {} ä¸ªï¼Œå¤±è´¥ {} ä¸ª", recovered_count, failed_count);
        Ok(recovered_count > 0)
    }

    /// è‡ªåŠ¨æ¢å¤æ‰€æœ‰æ´»è·ƒæ‰¹æ¬¡
    pub async fn auto_recover_all_batches(&self) -> Result<usize, AppError> {
        log::info!("å¼€å§‹è‡ªåŠ¨æ¢å¤æ‰€æœ‰æ‰¹æ¬¡çŠ¶æ€");

        // è·å–æ‰€æœ‰å¿«ç…§
        let snapshots = self.persistence_service.list_snapshots(None).await?;

        // æŒ‰æ‰¹æ¬¡åˆ†ç»„
        let mut batch_snapshots = std::collections::HashMap::new();
        for snapshot in snapshots {
            let entry = batch_snapshots.entry(snapshot.batch_id.clone())
                .or_insert_with(Vec::new);
            entry.push(snapshot);
        }

        let mut recovered_batches = 0;

        for (batch_id, mut snapshots) in batch_snapshots {
            // åªå¤„ç†æœ€è¿‘24å°æ—¶å†…çš„å¿«ç…§
            snapshots.retain(|s| {
                let hours_ago = (Utc::now() - s.timestamp).num_hours();
                hours_ago <= 24
            });

            if !snapshots.is_empty() {
                match self.recover_batch_state(&batch_id).await {
                    Ok(true) => recovered_batches += 1,
                    Ok(false) => log::debug!("æ‰¹æ¬¡ {} æ— éœ€æ¢å¤", batch_id),
                    Err(e) => log::error!("æ¢å¤æ‰¹æ¬¡ {} å¤±è´¥: {}", batch_id, e),
                }
            }
        }

        log::info!("è‡ªåŠ¨æ¢å¤å®Œæˆï¼Œå…±æ¢å¤ {} ä¸ªæ‰¹æ¬¡", recovered_batches);
        Ok(recovered_batches)
    }

    /// åˆ›å»ºå½“å‰çŠ¶æ€å¿«ç…§
    pub async fn create_current_snapshot(&self, batch_id: &str) -> Result<String, AppError> {
        log::info!("ä¸ºæ‰¹æ¬¡ {} åˆ›å»ºå½“å‰çŠ¶æ€å¿«ç…§", batch_id);

        // è·å–æ‰¹æ¬¡ä¸­çš„æ‰€æœ‰å®ä¾‹
        let instances = self.state_manager.get_batch_instances(batch_id).await?;

        // åˆ›å»ºå¿«ç…§
        let snapshot_id = self.persistence_service.create_snapshot(batch_id, instances).await?;

        log::info!("å¿«ç…§åˆ›å»ºå®Œæˆ: {}", snapshot_id);
        Ok(snapshot_id)
    }
}
```

**éªŒè¯æ£€æŸ¥ç‚¹**:
- [ ] çŠ¶æ€å¿«ç…§åˆ›å»ºå’Œæ¢å¤åŠŸèƒ½æ­£å¸¸
- [ ] ç¼“å­˜æœºåˆ¶æé«˜æŸ¥è¯¢æ€§èƒ½
- [ ] è‡ªåŠ¨æ¢å¤æœºåˆ¶å¯é 
- [ ] è¿‡æœŸæ•°æ®æ¸…ç†åŠŸèƒ½æœ‰æ•ˆ

---

## ğŸ“± é˜¶æ®µå…­ï¼šå‰ç«¯æµ‹è¯•ç•Œé¢é‡æ„

### ğŸ“ é‡æ„åŸå› 
- å½“å‰å‰ç«¯ç•Œé¢åŠŸèƒ½ä¸å®Œæ•´ï¼Œç¼ºå°‘æ ¸å¿ƒæµ‹è¯•åŠŸèƒ½
- éœ€è¦å®ç°å®æ—¶çš„æµ‹è¯•è¿›åº¦æ˜¾ç¤º
- å¿…é¡»æä¾›ç›´è§‚çš„æµ‹è¯•çŠ¶æ€ç›‘æ§
- éœ€è¦æ”¯æŒæµ‹è¯•æ§åˆ¶æ“ä½œï¼ˆå¼€å§‹/æš‚åœ/æ¢å¤ï¼‰

### ğŸ¯ å®æ–½ç›®æ ‡
- [ ] é‡æ„æµ‹è¯•åŒºåŸŸç»„ä»¶
- [ ] å®ç°å®æ—¶è¿›åº¦ç›‘æ§
- [ ] æ·»åŠ æµ‹è¯•æ§åˆ¶åŠŸèƒ½
- [ ] ä¼˜åŒ–ç”¨æˆ·ä½“éªŒå’Œç•Œé¢å“åº”

### ğŸ“‹ è¯¦ç»†å®æ–½æ­¥éª¤

#### 6.1 é‡æ„æµ‹è¯•åŒºåŸŸç»„ä»¶
**æ‰§è¡Œå†…å®¹**:
- [ ] é‡æ–°è®¾è®¡TestAreaComponent
- [ ] å®ç°é€šé“ç½‘æ ¼æ˜¾ç¤º
- [ ] æ·»åŠ æ‰¹æ¬¡åˆ—è¡¨ç®¡ç†
- [ ] å®ç°æµ‹è¯•è¿›åº¦å¯è§†åŒ–

**è¯¦ç»†æ‰§è¡Œæ­¥éª¤**:

**æ­¥éª¤6.1.1: åˆ›å»ºæµ‹è¯•åŒºåŸŸç»„ä»¶åŸºç¡€ç»“æ„**
åˆ›å»ºæ–‡ä»¶ `src/app/components/test-area/test-area.component.ts`:
```typescript
import { Component, OnInit, OnDestroy, Input, ViewChild, TemplateRef } from '@angular/core';
import { Subject, interval, BehaviorSubject } from 'rxjs';
import { takeUntil, debounceTime, distinctUntilChanged } from 'rxjs/operators';
import { NzMessageService } from 'ng-zorro-antd/message';
import { NzModalService } from 'ng-zorro-antd/modal';
import { NzTableComponent } from 'ng-zorro-antd/table';

import { TestOrchestrationService } from '../../services/test-orchestration.service';
import { EventListenerService } from '../../services/event-listener.service';
import { BackendCommsService } from '../../services/backend-comms.service';
import {
  TestBatchInfo,
  ChannelTestInstance,
  OverallTestStatus,
  StateChangedEvent,
  TestProgress,
  BatchExecutionStatistics
} from '../../models';

/// æµ‹è¯•åŒºåŸŸç»„ä»¶
///
/// è´Ÿè´£æ˜¾ç¤ºå’Œç®¡ç†æµ‹è¯•æ‰¹æ¬¡çš„æ‰§è¡Œç•Œé¢
@Component({
  selector: 'app-test-area',
  templateUrl: './test-area.component.html',
  styleUrls: ['./test-area.component.scss']
})
export class TestAreaComponent implements OnInit, OnDestroy {
  @Input() selectedBatch: TestBatchInfo | null = null;
  @ViewChild('channelTable', { static: false }) channelTable!: NzTableComponent;
  @ViewChild('testDetailsModal', { static: true }) testDetailsModal!: TemplateRef<any>;

  // æ•°æ®çŠ¶æ€
  channels: ChannelTestInstance[] = [];
  filteredChannels: ChannelTestInstance[] = [];
  selectedChannels: Set<string> = new Set();

  // æµ‹è¯•è¿›åº¦
  testProgress: TestProgress = {
    totalChannels: 0,
    completedChannels: 0,
    failedChannels: 0,
    testingChannels: 0,
    progressPercentage: 0,
    estimatedTimeRemaining: 0
  };

  // æ‰¹æ¬¡ç»Ÿè®¡
  batchStatistics: BatchExecutionStatistics = {
    totalExecutionTime: 0,
    averageChannelTime: 0,
    successRate: 0,
    throughput: 0
  };

  // UIçŠ¶æ€
  loading = false;
  testRunning = false;
  testPaused = false;
  autoRefresh = true;
  refreshInterval = 1000; // 1ç§’åˆ·æ–°é—´éš”

  // è¿‡æ»¤å’Œæœç´¢
  searchText = '';
  statusFilter: OverallTestStatus | 'all' = 'all';
  private searchSubject = new BehaviorSubject<string>('');

  // è¡¨æ ¼é…ç½®
  tablePageSize = 50;
  tablePageIndex = 1;
  tableSortField: string | null = null;
  tableSortOrder: string | null = null;

  // é”€æ¯ä¿¡å·
  private destroy$ = new Subject<void>();

  // çŠ¶æ€æšä¸¾å¼•ç”¨ï¼ˆç”¨äºæ¨¡æ¿ï¼‰
  readonly OverallTestStatus = OverallTestStatus;

  constructor(
    private testOrchestrationService: TestOrchestrationService,
    private eventListenerService: EventListenerService,
    private backendCommsService: BackendCommsService,
    private message: NzMessageService,
    private modal: NzModalService
  ) {}

  ngOnInit(): void {
    this.setupEventListeners();
    this.setupSearchFilter();
    this.setupAutoRefresh();

    if (this.selectedBatch) {
      this.loadBatchData();
    }
  }

  ngOnDestroy(): void {
    this.destroy$.next();
    this.destroy$.complete();
  }

  /// è®¾ç½®äº‹ä»¶ç›‘å¬å™¨
  private setupEventListeners(): void {
    // ç›‘å¬çŠ¶æ€å˜æ›´äº‹ä»¶
    this.eventListenerService.onStateChanged()
      .pipe(takeUntil(this.destroy$))
      .subscribe(event => {
        this.handleStateChanged(event);
      });

    // ç›‘å¬æµ‹è¯•è¿›åº¦äº‹ä»¶
    this.eventListenerService.onTestProgress()
      .pipe(takeUntil(this.destroy$))
      .subscribe(progress => {
        this.testProgress = progress;
      });

    // ç›‘å¬æ‰¹æ¬¡çŠ¶æ€äº‹ä»¶
    this.eventListenerService.onBatchStatusChanged()
      .pipe(takeUntil(this.destroy$))
      .subscribe(status => {
        this.testRunning = status.isRunning;
        this.testPaused = status.isPaused;
      });
  }

  /// è®¾ç½®æœç´¢è¿‡æ»¤å™¨
  private setupSearchFilter(): void {
    this.searchSubject
      .pipe(
        debounceTime(300),
        distinctUntilChanged(),
        takeUntil(this.destroy$)
      )
      .subscribe(searchText => {
        this.applyFilters();
      });
  }

  /// è®¾ç½®è‡ªåŠ¨åˆ·æ–°
  private setupAutoRefresh(): void {
    interval(this.refreshInterval)
      .pipe(takeUntil(this.destroy$))
      .subscribe(() => {
        if (this.autoRefresh && this.selectedBatch) {
          this.refreshBatchStatistics();
        }
      });
  }

  /// åŠ è½½æ‰¹æ¬¡æ•°æ®
  async loadBatchData(): Promise<void> {
    if (!this.selectedBatch) return;

    this.loading = true;
    try {
      // å¹¶è¡ŒåŠ è½½é€šé“æ•°æ®å’Œç»Ÿè®¡ä¿¡æ¯
      const [channels, statistics] = await Promise.all([
        this.testOrchestrationService.getBatchChannels(this.selectedBatch.batchId),
        this.testOrchestrationService.getBatchStatistics(this.selectedBatch.batchId)
      ]);

      this.channels = channels;
      this.batchStatistics = statistics;
      this.applyFilters();
      this.updateProgress();

      this.message.success(`å·²åŠ è½½ ${channels.length} ä¸ªé€šé“`);
    } catch (error) {
      this.message.error('åŠ è½½æ‰¹æ¬¡æ•°æ®å¤±è´¥: ' + error);
      console.error('Load batch data error:', error);
    } finally {
      this.loading = false;
    }
  }

  /// å¤„ç†çŠ¶æ€å˜æ›´äº‹ä»¶
  private handleStateChanged(event: StateChangedEvent): void {
    const channel = this.channels.find(c => c.instanceId === event.instanceId);
    if (channel) {
      const oldStatus = channel.overallStatus;
      channel.overallStatus = event.newStatus;
      channel.updatedTime = new Date(event.timestamp);

      // æ›´æ–°è¿›åº¦
      this.updateProgress();

      // é‡æ–°åº”ç”¨è¿‡æ»¤å™¨
      this.applyFilters();

      // æ˜¾ç¤ºçŠ¶æ€å˜æ›´é€šçŸ¥
      this.showStatusChangeNotification(channel, oldStatus, event.newStatus);
    }
  }

  /// æ˜¾ç¤ºçŠ¶æ€å˜æ›´é€šçŸ¥
  private showStatusChangeNotification(
    channel: ChannelTestInstance,
    oldStatus: OverallTestStatus,
    newStatus: OverallTestStatus
  ): void {
    const channelName = this.getChannelDisplayName(channel);

    if (newStatus === OverallTestStatus.AllCompleted) {
      this.message.success(`é€šé“ ${channelName} æµ‹è¯•å®Œæˆ`);
    } else if (newStatus === OverallTestStatus.HardPointFailed) {
      this.message.error(`é€šé“ ${channelName} æµ‹è¯•å¤±è´¥`);
    }
  }

  /// æ›´æ–°æµ‹è¯•è¿›åº¦
  private updateProgress(): void {
    const total = this.channels.length;
    if (total === 0) {
      this.testProgress = {
        totalChannels: 0,
        completedChannels: 0,
        failedChannels: 0,
        testingChannels: 0,
        progressPercentage: 0,
        estimatedTimeRemaining: 0
      };
      return;
    }

    const completed = this.channels.filter(c =>
      c.overallStatus === OverallTestStatus.AllCompleted
    ).length;

    const failed = this.channels.filter(c =>
      c.overallStatus === OverallTestStatus.HardPointFailed
    ).length;

    const testing = this.channels.filter(c =>
      c.overallStatus === OverallTestStatus.HardPointTesting ||
      c.overallStatus === OverallTestStatus.ManualTesting
    ).length;

    const progressPercentage = (completed / total) * 100;

    // ä¼°ç®—å‰©ä½™æ—¶é—´
    const estimatedTimeRemaining = this.calculateEstimatedTime(completed, total);

    this.testProgress = {
      totalChannels: total,
      completedChannels: completed,
      failedChannels: failed,
      testingChannels: testing,
      progressPercentage,
      estimatedTimeRemaining
    };
  }

  /// è®¡ç®—é¢„ä¼°å‰©ä½™æ—¶é—´
  private calculateEstimatedTime(completed: number, total: number): number {
    if (completed === 0 || this.batchStatistics.averageChannelTime === 0) {
      return 0;
    }

    const remaining = total - completed;
    return remaining * this.batchStatistics.averageChannelTime;
  }

  /// åº”ç”¨è¿‡æ»¤å™¨
  private applyFilters(): void {
    let filtered = [...this.channels];

    // åº”ç”¨æœç´¢è¿‡æ»¤
    if (this.searchText.trim()) {
      const searchLower = this.searchText.toLowerCase();
      filtered = filtered.filter(channel =>
        this.getChannelDisplayName(channel).toLowerCase().includes(searchLower) ||
        channel.instanceId.toLowerCase().includes(searchLower)
      );
    }

    // åº”ç”¨çŠ¶æ€è¿‡æ»¤
    if (this.statusFilter !== 'all') {
      filtered = filtered.filter(channel =>
        channel.overallStatus === this.statusFilter
      );
    }

    this.filteredChannels = filtered;
  }

  /// è·å–é€šé“æ˜¾ç¤ºåç§°
  private getChannelDisplayName(channel: ChannelTestInstance): string {
    // è¿™é‡Œå¯ä»¥æ ¹æ®å®é™…éœ€æ±‚æ ¼å¼åŒ–æ˜¾ç¤ºåç§°
    return `${channel.definitionId} (${channel.instanceId})`;
  }

  /// åˆ·æ–°æ‰¹æ¬¡ç»Ÿè®¡ä¿¡æ¯
  async refreshBatchStatistics(): Promise<void> {
    if (!this.selectedBatch) return;

    try {
      const [statistics, progress] = await Promise.all([
        this.testOrchestrationService.getBatchStatistics(this.selectedBatch.batchId),
        this.testOrchestrationService.getBatchProgress(this.selectedBatch.batchId)
      ]);

      this.batchStatistics = statistics;
      this.testProgress = progress;
    } catch (error) {
      console.warn('Refresh statistics failed:', error);
    }
  }

  // æµ‹è¯•æ§åˆ¶æ–¹æ³•
  async startBatchTest(): Promise<void> {
    if (!this.selectedBatch) return;

    try {
      await this.testOrchestrationService.startBatchTest(this.selectedBatch.batchId);
      this.testRunning = true;
      this.message.success('æ‰¹æ¬¡æµ‹è¯•å·²å¯åŠ¨');
    } catch (error) {
      this.message.error('å¯åŠ¨æµ‹è¯•å¤±è´¥: ' + error);
    }
  }

  async pauseBatchTest(): Promise<void> {
    if (!this.selectedBatch) return;

    try {
      await this.testOrchestrationService.pauseBatchTest(this.selectedBatch.batchId);
      this.testPaused = true;
      this.message.info('æ‰¹æ¬¡æµ‹è¯•å·²æš‚åœ');
    } catch (error) {
      this.message.error('æš‚åœæµ‹è¯•å¤±è´¥: ' + error);
    }
  }

  async resumeBatchTest(): Promise<void> {
    if (!this.selectedBatch) return;

    try {
      await this.testOrchestrationService.resumeBatchTest(this.selectedBatch.batchId);
      this.testPaused = false;
      this.message.info('æ‰¹æ¬¡æµ‹è¯•å·²æ¢å¤');
    } catch (error) {
      this.message.error('æ¢å¤æµ‹è¯•å¤±è´¥: ' + error);
    }
  }

  async stopBatchTest(): Promise<void> {
    if (!this.selectedBatch) return;

    this.modal.confirm({
      nzTitle: 'ç¡®è®¤åœæ­¢æµ‹è¯•',
      nzContent: 'åœæ­¢æµ‹è¯•å°†å–æ¶ˆæ‰€æœ‰æ­£åœ¨è¿›è¡Œçš„æµ‹è¯•ä»»åŠ¡ï¼Œç¡®å®šè¦ç»§ç»­å—ï¼Ÿ',
      nzOkText: 'ç¡®å®š',
      nzCancelText: 'å–æ¶ˆ',
      nzOkDanger: true,
      nzOnOk: async () => {
        try {
          await this.testOrchestrationService.stopBatchTest(this.selectedBatch!.batchId);
          this.testRunning = false;
          this.testPaused = false;
          this.message.warning('æ‰¹æ¬¡æµ‹è¯•å·²åœæ­¢');
        } catch (error) {
          this.message.error('åœæ­¢æµ‹è¯•å¤±è´¥: ' + error);
        }
      }
    });
  }

  // é€šé“æ“ä½œæ–¹æ³•
  onChannelSelectionChange(selectedChannels: string[]): void {
    this.selectedChannels = new Set(selectedChannels);
  }

  async startSelectedChannelsTest(): Promise<void> {
    if (this.selectedChannels.size === 0) {
      this.message.warning('è¯·å…ˆé€‰æ‹©è¦æµ‹è¯•çš„é€šé“');
      return;
    }

    try {
      const channelIds = Array.from(this.selectedChannels);
      await this.testOrchestrationService.startChannelsTest(channelIds);
      this.message.success(`å·²å¯åŠ¨ ${channelIds.length} ä¸ªé€šé“çš„æµ‹è¯•`);
    } catch (error) {
      this.message.error('å¯åŠ¨é€‰ä¸­é€šé“æµ‹è¯•å¤±è´¥: ' + error);
    }
  }

  async resetSelectedChannels(): Promise<void> {
    if (this.selectedChannels.size === 0) {
      this.message.warning('è¯·å…ˆé€‰æ‹©è¦é‡ç½®çš„é€šé“');
      return;
    }

    this.modal.confirm({
      nzTitle: 'ç¡®è®¤é‡ç½®é€šé“',
      nzContent: `ç¡®å®šè¦é‡ç½®é€‰ä¸­çš„ ${this.selectedChannels.size} ä¸ªé€šé“å—ï¼Ÿ`,
      nzOkText: 'ç¡®å®š',
      nzCancelText: 'å–æ¶ˆ',
      nzOnOk: async () => {
        try {
          const channelIds = Array.from(this.selectedChannels);
          await this.testOrchestrationService.resetChannels(channelIds);
          this.message.success(`å·²é‡ç½® ${channelIds.length} ä¸ªé€šé“`);
          this.selectedChannels.clear();
        } catch (error) {
          this.message.error('é‡ç½®é€šé“å¤±è´¥: ' + error);
        }
      }
    });
  }

  // æœç´¢å’Œè¿‡æ»¤æ–¹æ³•
  onSearchTextChange(searchText: string): void {
    this.searchText = searchText;
    this.searchSubject.next(searchText);
  }

  onStatusFilterChange(status: OverallTestStatus | 'all'): void {
    this.statusFilter = status;
    this.applyFilters();
  }

  // è¡¨æ ¼æ“ä½œæ–¹æ³•
  onTableSortChange(sort: { key: string; value: string }): void {
    this.tableSortField = sort.key;
    this.tableSortOrder = sort.value;
    // è¿™é‡Œå¯ä»¥æ·»åŠ æ’åºé€»è¾‘
  }

  onTablePageChange(pageIndex: number): void {
    this.tablePageIndex = pageIndex;
  }

  onTablePageSizeChange(pageSize: number): void {
    this.tablePageSize = pageSize;
    this.tablePageIndex = 1; // é‡ç½®åˆ°ç¬¬ä¸€é¡µ
  }

  // è¯¦æƒ…æŸ¥çœ‹æ–¹æ³•
  showChannelDetails(channel: ChannelTestInstance): void {
    this.modal.create({
      nzTitle: `é€šé“è¯¦æƒ… - ${this.getChannelDisplayName(channel)}`,
      nzContent: this.testDetailsModal,
      nzWidth: 800,
      nzFooter: null,
      nzComponentParams: {
        channel: channel
      }
    });
  }

  // å·¥å…·æ–¹æ³•
  getStatusColor(status: OverallTestStatus): string {
    switch (status) {
      case OverallTestStatus.AllCompleted:
        return 'green';
      case OverallTestStatus.HardPointFailed:
        return 'red';
      case OverallTestStatus.HardPointTesting:
      case OverallTestStatus.ManualTesting:
        return 'blue';
      case OverallTestStatus.HardPointPassed:
      case OverallTestStatus.ManualPassed:
        return 'orange';
      default:
        return 'default';
    }
  }

  getStatusText(status: OverallTestStatus): string {
    switch (status) {
      case OverallTestStatus.NotTested:
        return 'æœªæµ‹è¯•';
      case OverallTestStatus.WiringConfirmed:
        return 'æ¥çº¿ç¡®è®¤';
      case OverallTestStatus.HardPointTesting:
        return 'ç¡¬ç‚¹æµ‹è¯•ä¸­';
      case OverallTestStatus.HardPointPassed:
        return 'ç¡¬ç‚¹é€šè¿‡';
      case OverallTestStatus.HardPointFailed:
        return 'ç¡¬ç‚¹å¤±è´¥';
      case OverallTestStatus.ManualTesting:
        return 'æ‰‹åŠ¨æµ‹è¯•ä¸­';
      case OverallTestStatus.ManualPassed:
        return 'æ‰‹åŠ¨é€šè¿‡';
      case OverallTestStatus.AllCompleted:
        return 'å…¨éƒ¨å®Œæˆ';
      default:
        return 'æœªçŸ¥çŠ¶æ€';
    }
  }

  formatTime(seconds: number): string {
    if (seconds < 60) {
      return `${Math.round(seconds)}ç§’`;
    } else if (seconds < 3600) {
      const minutes = Math.floor(seconds / 60);
      const remainingSeconds = Math.round(seconds % 60);
      return `${minutes}åˆ†${remainingSeconds}ç§’`;
    } else {
      const hours = Math.floor(seconds / 3600);
      const minutes = Math.floor((seconds % 3600) / 60);
      return `${hours}å°æ—¶${minutes}åˆ†`;
    }
  }

  formatPercentage(value: number): string {
    return `${value.toFixed(1)}%`;
  }
}
```

**æ­¥éª¤6.1.2: åˆ›å»ºæµ‹è¯•åŒºåŸŸç»„ä»¶æ¨¡æ¿**
åˆ›å»ºæ–‡ä»¶ `src/app/components/test-area/test-area.component.html`:
```html
<div class="test-area-container">
  <!-- å¤´éƒ¨å·¥å…·æ  -->
  <div class="toolbar">
    <div class="toolbar-left">
      <h2 *ngIf="selectedBatch">
        <nz-icon nzType="experiment" nzTheme="outline"></nz-icon>
        {{ selectedBatch.productModel }} - æ‰¹æ¬¡ {{ selectedBatch.batchId }}
      </h2>
      <h2 *ngIf="!selectedBatch">
        <nz-icon nzType="experiment" nzTheme="outline"></nz-icon>
        è¯·é€‰æ‹©æµ‹è¯•æ‰¹æ¬¡
      </h2>
    </div>

    <div class="toolbar-right">
      <nz-space nzSize="middle">
        <!-- è‡ªåŠ¨åˆ·æ–°å¼€å…³ -->
        <nz-switch
          [(ngModel)]="autoRefresh"
          nzCheckedChildren="è‡ªåŠ¨åˆ·æ–°"
          nzUnCheckedChildren="æ‰‹åŠ¨åˆ·æ–°">
        </nz-switch>

        <!-- åˆ·æ–°æŒ‰é’® -->
        <button
          nz-button
          nzType="default"
          nzShape="circle"
          (click)="loadBatchData()"
          [nzLoading]="loading">
          <nz-icon nzType="reload" nzTheme="outline"></nz-icon>
        </button>
      </nz-space>
    </div>
  </div>

  <!-- è¿›åº¦å¡ç‰‡ -->
  <div class="progress-cards" *ngIf="selectedBatch">
    <nz-row [nzGutter]="16">
      <nz-col [nzSpan]="6">
        <nz-card nzTitle="æ€»é€šé“æ•°" [nzBordered]="false">
          <div class="stat-number">{{ testProgress.totalChannels }}</div>
        </nz-card>
      </nz-col>

      <nz-col [nzSpan]="6">
        <nz-card nzTitle="å·²å®Œæˆ" [nzBordered]="false">
          <div class="stat-number success">{{ testProgress.completedChannels }}</div>
          <div class="stat-desc">{{ formatPercentage((testProgress.completedChannels / testProgress.totalChannels) * 100) }}</div>
        </nz-card>
      </nz-col>

      <nz-col [nzSpan]="6">
        <nz-card nzTitle="æµ‹è¯•ä¸­" [nzBordered]="false">
          <div class="stat-number processing">{{ testProgress.testingChannels }}</div>
        </nz-card>
      </nz-col>

      <nz-col [nzSpan]="6">
        <nz-card nzTitle="å¤±è´¥" [nzBordered]="false">
          <div class="stat-number error">{{ testProgress.failedChannels }}</div>
        </nz-card>
      </nz-col>
    </nz-row>

    <!-- è¿›åº¦æ¡ -->
    <div class="progress-bar-container">
      <nz-progress
        [nzPercent]="testProgress.progressPercentage"
        nzStatus="active"
        [nzShowInfo]="true">
      </nz-progress>

      <div class="progress-info">
        <span>é¢„è®¡å‰©ä½™æ—¶é—´: {{ formatTime(testProgress.estimatedTimeRemaining) }}</span>
        <span>å¹³å‡æµ‹è¯•æ—¶é—´: {{ formatTime(batchStatistics.averageChannelTime) }}</span>
      </div>
    </div>
  </div>

  <!-- æ§åˆ¶é¢æ¿ -->
  <div class="control-panel" *ngIf="selectedBatch">
    <nz-card nzTitle="æµ‹è¯•æ§åˆ¶" [nzBordered]="false">
      <nz-space nzSize="middle">
        <!-- æ‰¹æ¬¡æ§åˆ¶æŒ‰é’® -->
        <button
          nz-button
          nzType="primary"
          [nzLoading]="loading"
          [disabled]="testRunning"
          (click)="startBatchTest()">
          <nz-icon nzType="play-circle" nzTheme="outline"></nz-icon>
          å¯åŠ¨æ‰¹æ¬¡æµ‹è¯•
        </button>

        <button
          nz-button
          nzType="default"
          [disabled]="!testRunning || testPaused"
          (click)="pauseBatchTest()">
          <nz-icon nzType="pause-circle" nzTheme="outline"></nz-icon>
          æš‚åœæµ‹è¯•
        </button>

        <button
          nz-button
          nzType="default"
          [disabled]="!testPaused"
          (click)="resumeBatchTest()">
          <nz-icon nzType="play-circle" nzTheme="outline"></nz-icon>
          æ¢å¤æµ‹è¯•
        </button>

        <button
          nz-button
          nzType="danger"
          [disabled]="!testRunning"
          (click)="stopBatchTest()">
          <nz-icon nzType="stop" nzTheme="outline"></nz-icon>
          åœæ­¢æµ‹è¯•
        </button>

        <nz-divider nzType="vertical"></nz-divider>

        <!-- é€‰ä¸­é€šé“æ§åˆ¶æŒ‰é’® -->
        <button
          nz-button
          nzType="default"
          [disabled]="selectedChannels.size === 0"
          (click)="startSelectedChannelsTest()">
          <nz-icon nzType="play-square" nzTheme="outline"></nz-icon>
          æµ‹è¯•é€‰ä¸­é€šé“ ({{ selectedChannels.size }})
        </button>

        <button
          nz-button
          nzType="default"
          [disabled]="selectedChannels.size === 0"
          (click)="resetSelectedChannels()">
          <nz-icon nzType="redo" nzTheme="outline"></nz-icon>
          é‡ç½®é€‰ä¸­é€šé“
        </button>
      </nz-space>
    </nz-card>
  </div>

  <!-- æœç´¢å’Œè¿‡æ»¤ -->
  <div class="filter-panel" *ngIf="selectedBatch">
    <nz-card [nzBordered]="false">
      <nz-row [nzGutter]="16">
        <nz-col [nzSpan]="8">
          <nz-input-group nzPrefixIcon="search">
            <input
              nz-input
              placeholder="æœç´¢é€šé“..."
              [(ngModel)]="searchText"
              (ngModelChange)="onSearchTextChange($event)">
          </nz-input-group>
        </nz-col>

        <nz-col [nzSpan]="6">
          <nz-select
            [(ngModel)]="statusFilter"
            (ngModelChange)="onStatusFilterChange($event)"
            nzPlaceHolder="é€‰æ‹©çŠ¶æ€è¿‡æ»¤">
            <nz-option nzValue="all" nzLabel="å…¨éƒ¨çŠ¶æ€"></nz-option>
            <nz-option
              *ngFor="let status of [
                OverallTestStatus.NotTested,
                OverallTestStatus.WiringConfirmed,
                OverallTestStatus.HardPointTesting,
                OverallTestStatus.HardPointPassed,
                OverallTestStatus.HardPointFailed,
                OverallTestStatus.ManualTesting,
                OverallTestStatus.ManualPassed,
                OverallTestStatus.AllCompleted
              ]"
              [nzValue]="status"
              [nzLabel]="getStatusText(status)">
            </nz-option>
          </nz-select>
        </nz-col>

        <nz-col [nzSpan]="10">
          <div class="filter-info">
            æ˜¾ç¤º {{ filteredChannels.length }} / {{ channels.length }} ä¸ªé€šé“
          </div>
        </nz-col>
      </nz-row>
    </nz-card>
  </div>
</div>
```

**éªŒè¯æ£€æŸ¥ç‚¹**:
- [ ] æµ‹è¯•åŒºåŸŸç»„ä»¶åŸºç¡€ç»“æ„å®Œæ•´
- [ ] äº‹ä»¶ç›‘å¬æœºåˆ¶æ­£å¸¸å·¥ä½œ
- [ ] æ•°æ®åŠ è½½å’Œåˆ·æ–°åŠŸèƒ½æ­£å¸¸
- [ ] æœç´¢å’Œè¿‡æ»¤åŠŸèƒ½æœ‰æ•ˆ
- [ ] è¿›åº¦è®¡ç®—å‡†ç¡®
- [ ] æµ‹è¯•æ§åˆ¶åŠŸèƒ½å®Œæ•´
- [ ] UIç•Œé¢å“åº”å¼è®¾è®¡

### ğŸ“Š é¢„æœŸç»“æœ
- âœ… ç°ä»£åŒ–çš„æµ‹è¯•ç•Œé¢ï¼Œæ”¯æŒæ‰€æœ‰æ ¸å¿ƒåŠŸèƒ½
- âœ… å®æ—¶çš„æµ‹è¯•è¿›åº¦ç›‘æ§å’ŒçŠ¶æ€æ˜¾ç¤º
- âœ… ç›´è§‚çš„ç”¨æˆ·æ“ä½œç•Œé¢
- âœ… ä¼˜ç§€çš„ç”¨æˆ·ä½“éªŒå’Œå“åº”æ€§èƒ½

---

## ğŸ§ª é˜¶æ®µä¸ƒï¼šé›†æˆæµ‹è¯•å’Œç«¯åˆ°ç«¯éªŒè¯

### ğŸ“ é‡æ„åŸå› 
- éœ€è¦éªŒè¯æ‰€æœ‰æ¨¡å—çš„é›†æˆæ•ˆæœ
- å¿…é¡»ç¡®ä¿ç«¯åˆ°ç«¯æµç¨‹çš„æ­£ç¡®æ€§
- éœ€è¦éªŒè¯æ€§èƒ½è¦æ±‚çš„è¾¾æˆ
- å¿…é¡»è¿›è¡Œå……åˆ†çš„é”™è¯¯åœºæ™¯æµ‹è¯•

### ğŸ¯ å®æ–½ç›®æ ‡
- [ ] å®ç°å®Œæ•´çš„ç«¯åˆ°ç«¯æµ‹è¯•
- [ ] éªŒè¯30ç§’æ€§èƒ½è¦æ±‚
- [ ] æµ‹è¯•é”™è¯¯æ¢å¤æœºåˆ¶
- [ ] éªŒè¯æ•°æ®ä¸€è‡´æ€§

### ğŸ“Š é¢„æœŸç»“æœ
- âœ… å®Œæ•´çš„ç«¯åˆ°ç«¯æµ‹è¯•è¦†ç›–
- âœ… æ€§èƒ½è¦æ±‚éªŒè¯é€šè¿‡
- âœ… é”™è¯¯å¤„ç†æœºåˆ¶éªŒè¯
- âœ… ç³»ç»Ÿç¨³å®šæ€§ç¡®è®¤

---

## ğŸš€ é˜¶æ®µå…«ï¼šéƒ¨ç½²å’Œæ–‡æ¡£å®Œå–„

### ğŸ“ é‡æ„åŸå› 
- éœ€è¦å‡†å¤‡ç”Ÿäº§ç¯å¢ƒéƒ¨ç½²
- å¿…é¡»å®Œå–„æŠ€æœ¯æ–‡æ¡£
- éœ€è¦æä¾›ç”¨æˆ·æ“ä½œæ‰‹å†Œ
- å¿…é¡»å»ºç«‹ç»´æŠ¤å’Œç›‘æ§æœºåˆ¶

### ğŸ¯ å®æ–½ç›®æ ‡
- [ ] å®Œå–„éƒ¨ç½²è„šæœ¬å’Œé…ç½®
- [ ] ç¼–å†™æŠ€æœ¯æ–‡æ¡£
- [ ] åˆ›å»ºç”¨æˆ·æ‰‹å†Œ
- [ ] å»ºç«‹ç›‘æ§å’Œæ—¥å¿—ç³»ç»Ÿ

### ğŸ“Š é¢„æœŸç»“æœ
- âœ… å¯éƒ¨ç½²çš„ç”Ÿäº§ç‰ˆæœ¬
- âœ… å®Œæ•´çš„æŠ€æœ¯æ–‡æ¡£
- âœ… ç”¨æˆ·æ“ä½œæ‰‹å†Œ
- âœ… ç›‘æ§å’Œç»´æŠ¤æœºåˆ¶

---

## ğŸ“‹ æ€»ç»“å’Œæ£€æŸ¥æ¸…å•

### ğŸ¯ é‡æ„å®Œæˆæ ‡å‡†
- [ ] æ‰€æœ‰8ä¸ªé˜¶æ®µçš„ä»»åŠ¡å…¨éƒ¨å®Œæˆ
- [ ] å•å…ƒæµ‹è¯•è¦†ç›–ç‡è¾¾åˆ°90%ä»¥ä¸Š
- [ ] é›†æˆæµ‹è¯•å…¨éƒ¨é€šè¿‡
- [ ] æ€§èƒ½æµ‹è¯•æ»¡è¶³30ç§’è¦æ±‚
- [ ] æ–‡æ¡£å®Œæ•´ä¸”å‡†ç¡®

### ğŸ“Š è´¨é‡ä¿è¯
- [ ] ä»£ç å®¡æŸ¥å®Œæˆ
- [ ] å®‰å…¨æ€§æµ‹è¯•é€šè¿‡
- [ ] ç”¨æˆ·éªŒæ”¶æµ‹è¯•é€šè¿‡
- [ ] ç”Ÿäº§ç¯å¢ƒéƒ¨ç½²éªŒè¯

### ğŸš€ äº¤ä»˜æˆæœ
- âœ… å®Œæ•´çš„FAT_TESTåº”ç”¨ç¨‹åº
- âœ… æŠ€æœ¯æ–‡æ¡£å’Œç”¨æˆ·æ‰‹å†Œ
- âœ… éƒ¨ç½²å’Œç»´æŠ¤æŒ‡å—
- âœ… æµ‹è¯•æŠ¥å‘Šå’Œæ€§èƒ½åŸºå‡†

---

**é‡æ„å®Œæˆæ—¶é—´é¢„ä¼°**: 4-6å‘¨
**å›¢é˜Ÿè§„æ¨¡å»ºè®®**: 2-3åå¼€å‘äººå‘˜
**å…³é”®é‡Œç¨‹ç¢‘**: æ¯ä¸ªé˜¶æ®µå®Œæˆåè¿›è¡Œè¯„å®¡å’ŒéªŒæ”¶

---

## ğŸ› ï¸ è‡ªåŠ¨åŒ–æ‰§è¡Œå·¥å…·

### ğŸ“‹ é˜¶æ®µæ‰§è¡Œè„šæœ¬

ä¸ºäº†ç¡®ä¿æ¯ä¸ªé˜¶æ®µéƒ½èƒ½æŒ‰ç…§æ­¥éª¤å‡†ç¡®æ‰§è¡Œï¼Œæˆ‘ä»¬æä¾›ä»¥ä¸‹è‡ªåŠ¨åŒ–è„šæœ¬ï¼š

#### é˜¶æ®µä¸€æ‰§è¡Œè„šæœ¬
åˆ›å»ºæ–‡ä»¶ `scripts/stage1_data_model.sh`:
```bash
#!/bin/bash

# FAT_TEST ç¬¬äºŒé˜¶æ®µé‡æ„ - é˜¶æ®µä¸€æ‰§è¡Œè„šæœ¬
# æ•°æ®æ¨¡å‹é‡æ„å’Œæ•°æ®åº“è¿ç§»

set -e  # é‡åˆ°é”™è¯¯ç«‹å³é€€å‡º

echo "ğŸ—ï¸ å¼€å§‹æ‰§è¡Œé˜¶æ®µä¸€ï¼šæ•°æ®æ¨¡å‹é‡æ„å’Œæ•°æ®åº“è¿ç§»"

# æ­¥éª¤1.1: åˆ†æåŸC#é¡¹ç›®æ•°æ®ç»“æ„
echo "ğŸ“Š æ­¥éª¤1.1: åˆ†æåŸC#é¡¹ç›®æ•°æ®ç»“æ„"
mkdir -p docs/data-analysis
cd docs/data-analysis

# æå–SQLè¡¨ç»“æ„
grep -A 50 "CREATE TABLE" ../../Notes/ChannelMappings_202505301041.sql > tables_structure.sql
grep -E "^\s*\[.*\].*," ../../Notes/ChannelMappings_202505301041.sql > fields_list.txt
grep -E "(PRIMARY KEY|FOREIGN KEY|REFERENCES)" ../../Notes/ChannelMappings_202505301041.sql > constraints.sql

echo "âœ… æ•°æ®ç»“æ„åˆ†æå®Œæˆ"

# æ­¥éª¤1.2: åˆ›å»ºRustæ•°æ®æ¨¡å‹
echo "ğŸ¦€ æ­¥éª¤1.2: åˆ›å»ºRustæ•°æ®æ¨¡å‹"
cd ../../FactoryTesting/src-tauri

# åˆ›å»ºç›®å½•ç»“æ„
mkdir -p src/domain/entities
mkdir -p src/domain/enums
mkdir -p src/domain/value_objects

# åˆ›å»ºæšä¸¾æ¨¡å—
cat > src/domain/enums/mod.rs << 'EOF'
pub mod module_type;
pub mod power_supply_type;
pub mod wire_system;
pub mod overall_test_status;
pub mod sub_test_item;
pub mod test_result;
pub mod test_execution_status;

pub use module_type::ModuleType;
pub use power_supply_type::PowerSupplyType;
pub use wire_system::WireSystem;
pub use overall_test_status::OverallTestStatus;
pub use sub_test_item::SubTestItem;
pub use test_result::TestResult;
pub use test_execution_status::TestExecutionStatus;
EOF

echo "âœ… æ•°æ®æ¨¡å‹ç»“æ„åˆ›å»ºå®Œæˆ"

# æ­¥éª¤1.3: è¿è¡Œæµ‹è¯•éªŒè¯
echo "ğŸ§ª æ­¥éª¤1.3: è¿è¡Œæµ‹è¯•éªŒè¯"
cargo test --lib domain::enums -- --nocapture

echo "âœ… é˜¶æ®µä¸€æ‰§è¡Œå®Œæˆï¼"
```

#### é˜¶æ®µéªŒè¯è„šæœ¬
åˆ›å»ºæ–‡ä»¶ `scripts/validate_stage.sh`:
```bash
#!/bin/bash

# é˜¶æ®µéªŒè¯è„šæœ¬
# ç”¨äºéªŒè¯æ¯ä¸ªé˜¶æ®µçš„å®Œæˆæƒ…å†µ

STAGE=$1

if [ -z "$STAGE" ]; then
    echo "ç”¨æ³•: $0 <é˜¶æ®µå·>"
    echo "ä¾‹å¦‚: $0 1"
    exit 1
fi

echo "ğŸ” éªŒè¯é˜¶æ®µ $STAGE çš„å®Œæˆæƒ…å†µ"

case $STAGE in
    1)
        echo "éªŒè¯é˜¶æ®µä¸€ï¼šæ•°æ®æ¨¡å‹é‡æ„å’Œæ•°æ®åº“è¿ç§»"

        # æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
        files=(
            "docs/data-analysis/tables_structure.sql"
            "docs/data-analysis/field_mapping.md"
            "docs/data-analysis/enums_analysis.md"
            "FactoryTesting/src-tauri/src/domain/enums/mod.rs"
            "FactoryTesting/src-tauri/src/domain/enums/module_type.rs"
            "FactoryTesting/src-tauri/src/domain/enums/overall_test_status.rs"
        )

        for file in "${files[@]}"; do
            if [ -f "$file" ]; then
                echo "âœ… $file å­˜åœ¨"
            else
                echo "âŒ $file ä¸å­˜åœ¨"
            fi
        done

        # è¿è¡Œæµ‹è¯•
        cd FactoryTesting/src-tauri
        if cargo test --lib domain::enums; then
            echo "âœ… æšä¸¾ç±»å‹æµ‹è¯•é€šè¿‡"
        else
            echo "âŒ æšä¸¾ç±»å‹æµ‹è¯•å¤±è´¥"
        fi
        ;;

    2)
        echo "éªŒè¯é˜¶æ®µäºŒï¼šæ ¸å¿ƒæœåŠ¡æ¥å£è®¾è®¡"
        # éªŒè¯é€»è¾‘...
        ;;

    *)
        echo "æœªçŸ¥é˜¶æ®µ: $STAGE"
        exit 1
        ;;
esac

echo "ğŸ‰ é˜¶æ®µ $STAGE éªŒè¯å®Œæˆ"
```

#### è¿›åº¦è·Ÿè¸ªè„šæœ¬
åˆ›å»ºæ–‡ä»¶ `scripts/track_progress.py`:
```python
#!/usr/bin/env python3
"""
FAT_TEST ç¬¬äºŒé˜¶æ®µé‡æ„è¿›åº¦è·Ÿè¸ªå·¥å…·
"""

import os
import re
import json
from datetime import datetime
from pathlib import Path

class ProgressTracker:
    def __init__(self):
        self.progress_file = "progress.json"
        self.steps_file = "Notes/ç¬¬äºŒé˜¶æ®µé‡æ„å®æ–½æ­¥éª¤.md"

    def extract_checkboxes(self):
        """ä»å®æ–½æ­¥éª¤æ–‡æ¡£ä¸­æå–æ‰€æœ‰å¤é€‰æ¡†"""
        checkboxes = []

        with open(self.steps_file, 'r', encoding='utf-8') as f:
            content = f.read()

        # åŒ¹é…å¤é€‰æ¡†æ¨¡å¼
        pattern = r'- \[ \] (.+)'
        matches = re.findall(pattern, content)

        for i, match in enumerate(matches):
            checkboxes.append({
                'id': i + 1,
                'description': match.strip(),
                'completed': False,
                'completed_time': None
            })

        return checkboxes

    def load_progress(self):
        """åŠ è½½è¿›åº¦æ•°æ®"""
        if os.path.exists(self.progress_file):
            with open(self.progress_file, 'r', encoding='utf-8') as f:
                return json.load(f)
        else:
            return {
                'checkboxes': self.extract_checkboxes(),
                'last_updated': None,
                'stages': {
                    '1': {'name': 'æ•°æ®æ¨¡å‹é‡æ„å’Œæ•°æ®åº“è¿ç§»', 'completed': False},
                    '2': {'name': 'æ ¸å¿ƒæœåŠ¡æ¥å£è®¾è®¡', 'completed': False},
                    '3': {'name': 'PLCé€šä¿¡æœåŠ¡å®ç°', 'completed': False},
                    '4': {'name': 'æµ‹è¯•æ‰§è¡Œå¼•æ“å®ç°', 'completed': False},
                    '5': {'name': 'çŠ¶æ€ç®¡ç†å™¨å®ç°', 'completed': False},
                    '6': {'name': 'å‰ç«¯æµ‹è¯•ç•Œé¢é‡æ„', 'completed': False},
                    '7': {'name': 'é›†æˆæµ‹è¯•å’Œç«¯åˆ°ç«¯éªŒè¯', 'completed': False},
                    '8': {'name': 'éƒ¨ç½²å’Œæ–‡æ¡£å®Œå–„', 'completed': False},
                }
            }

    def save_progress(self, data):
        """ä¿å­˜è¿›åº¦æ•°æ®"""
        data['last_updated'] = datetime.now().isoformat()
        with open(self.progress_file, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)

    def mark_completed(self, task_id):
        """æ ‡è®°ä»»åŠ¡ä¸ºå®Œæˆ"""
        data = self.load_progress()

        for checkbox in data['checkboxes']:
            if checkbox['id'] == task_id:
                checkbox['completed'] = True
                checkbox['completed_time'] = datetime.now().isoformat()
                break

        self.save_progress(data)
        print(f"âœ… ä»»åŠ¡ {task_id} å·²æ ‡è®°ä¸ºå®Œæˆ")

    def show_progress(self):
        """æ˜¾ç¤ºå½“å‰è¿›åº¦"""
        data = self.load_progress()

        total_tasks = len(data['checkboxes'])
        completed_tasks = sum(1 for cb in data['checkboxes'] if cb['completed'])
        progress_percentage = (completed_tasks / total_tasks) * 100

        print(f"ğŸ“Š æ€»ä½“è¿›åº¦: {completed_tasks}/{total_tasks} ({progress_percentage:.1f}%)")
        print(f"ğŸ“… æœ€åæ›´æ–°: {data['last_updated']}")
        print()

        # æ˜¾ç¤ºå„é˜¶æ®µè¿›åº¦
        for stage_id, stage_info in data['stages'].items():
            status = "âœ…" if stage_info['completed'] else "â³"
            print(f"{status} é˜¶æ®µ{stage_id}: {stage_info['name']}")

        print()

        # æ˜¾ç¤ºæœªå®Œæˆçš„ä»»åŠ¡
        pending_tasks = [cb for cb in data['checkboxes'] if not cb['completed']]
        if pending_tasks:
            print("ğŸ“‹ å¾…å®Œæˆä»»åŠ¡:")
            for task in pending_tasks[:10]:  # åªæ˜¾ç¤ºå‰10ä¸ª
                print(f"  {task['id']}. {task['description']}")

            if len(pending_tasks) > 10:
                print(f"  ... è¿˜æœ‰ {len(pending_tasks) - 10} ä¸ªä»»åŠ¡")

def main():
    import sys

    tracker = ProgressTracker()

    if len(sys.argv) < 2:
        tracker.show_progress()
        return

    command = sys.argv[1]

    if command == "complete" and len(sys.argv) == 3:
        task_id = int(sys.argv[2])
        tracker.mark_completed(task_id)
    elif command == "show":
        tracker.show_progress()
    else:
        print("ç”¨æ³•:")
        print("  python track_progress.py show          # æ˜¾ç¤ºè¿›åº¦")
        print("  python track_progress.py complete <id> # æ ‡è®°ä»»åŠ¡å®Œæˆ")

if __name__ == "__main__":
    main()
```

#### ä»£ç ç”Ÿæˆè„šæœ¬
åˆ›å»ºæ–‡ä»¶ `scripts/generate_code.py`:
```python
#!/usr/bin/env python3
"""
ä»£ç ç”Ÿæˆå·¥å…·
æ ¹æ®æ•°æ®æ¨¡å‹å®šä¹‰è‡ªåŠ¨ç”ŸæˆRustä»£ç 
"""

import os
import json
from pathlib import Path

class CodeGenerator:
    def __init__(self):
        self.templates_dir = Path("scripts/templates")
        self.output_dir = Path("FactoryTesting/src-tauri/src")

    def generate_enum(self, enum_name, variants, description=""):
        """ç”Ÿæˆæšä¸¾ä»£ç """
        template = '''use sea_orm::entity::prelude::*;
use serde::{Deserialize, Serialize};

/// {description}
#[derive(Debug, Clone, PartialEq, Eq, EnumIter, DeriveActiveEnum, Serialize, Deserialize)]
#[sea_orm(rs_type = "String", db_type = "String(Some(20))")]
pub enum {enum_name} {{
{variants}
}}

impl {enum_name} {{
    /// è·å–æè¿°ä¿¡æ¯
    pub fn description(&self) -> &'static str {{
        match self {{
{descriptions}
        }}
    }}
}}

#[cfg(test)]
mod tests {{
    use super::*;

    #[test]
    fn test_{enum_name_lower}_description() {{
{test_cases}
    }}
}}
'''

        # ç”Ÿæˆå˜ä½“å®šä¹‰
        variant_lines = []
        description_lines = []
        test_lines = []

        for variant in variants:
            name = variant['name']
            value = variant['value']
            desc = variant['description']

            variant_lines.append(f'    #[sea_orm(string_value = "{value}")]')
            variant_lines.append(f'    {name},')

            description_lines.append(f'            {enum_name}::{name} => "{desc}",')

            test_lines.append(f'        assert_eq!({enum_name}::{name}.description(), "{desc}");')

        code = template.format(
            description=description,
            enum_name=enum_name,
            enum_name_lower=enum_name.lower(),
            variants='\n'.join(variant_lines),
            descriptions='\n'.join(description_lines),
            test_cases='\n'.join(test_lines)
        )

        # å†™å…¥æ–‡ä»¶
        file_path = self.output_dir / "domain" / "enums" / f"{enum_name.lower()}.rs"
        file_path.parent.mkdir(parents=True, exist_ok=True)

        with open(file_path, 'w', encoding='utf-8') as f:
            f.write(code)

        print(f"âœ… ç”Ÿæˆæšä¸¾: {file_path}")

def main():
    generator = CodeGenerator()

    # ç”ŸæˆModuleTypeæšä¸¾
    module_type_variants = [
        {'name': 'AI', 'value': 'AI', 'description': 'æ¨¡æ‹Ÿé‡è¾“å…¥'},
        {'name': 'AO', 'value': 'AO', 'description': 'æ¨¡æ‹Ÿé‡è¾“å‡º'},
        {'name': 'DI', 'value': 'DI', 'description': 'æ•°å­—é‡è¾“å…¥'},
        {'name': 'DO', 'value': 'DO', 'description': 'æ•°å­—é‡è¾“å‡º'},
    ]

    generator.generate_enum(
        "ModuleType",
        module_type_variants,
        "PLCæ¨¡å—ç±»å‹æšä¸¾"
    )

    # ç”ŸæˆOverallTestStatusæšä¸¾
    status_variants = [
        {'name': 'NotTested', 'value': 'NotTested', 'description': 'æœªæµ‹è¯•'},
        {'name': 'WiringConfirmed', 'value': 'WiringConfirmed', 'description': 'æ¥çº¿ç¡®è®¤'},
        {'name': 'HardPointTesting', 'value': 'HardPointTesting', 'description': 'ç¡¬ç‚¹æµ‹è¯•ä¸­'},
        {'name': 'HardPointPassed', 'value': 'HardPointPassed', 'description': 'ç¡¬ç‚¹æµ‹è¯•é€šè¿‡'},
        {'name': 'HardPointFailed', 'value': 'HardPointFailed', 'description': 'ç¡¬ç‚¹æµ‹è¯•å¤±è´¥'},
        {'name': 'ManualTesting', 'value': 'ManualTesting', 'description': 'æ‰‹åŠ¨æµ‹è¯•ä¸­'},
        {'name': 'ManualPassed', 'value': 'ManualPassed', 'description': 'æ‰‹åŠ¨æµ‹è¯•é€šè¿‡'},
        {'name': 'AllCompleted', 'value': 'AllCompleted', 'description': 'å…¨éƒ¨å®Œæˆ'},
    ]

    generator.generate_enum(
        "OverallTestStatus",
        status_variants,
        "æ•´ä½“æµ‹è¯•çŠ¶æ€æšä¸¾"
    )

    print("ğŸ‰ ä»£ç ç”Ÿæˆå®Œæˆï¼")

if __name__ == "__main__":
    main()
```

### ğŸ“‹ ä½¿ç”¨è¯´æ˜

#### 1. æ‰§è¡Œé˜¶æ®µä¸€
```bash
# ç»™è„šæœ¬æ‰§è¡Œæƒé™
chmod +x scripts/stage1_data_model.sh
chmod +x scripts/validate_stage.sh

# æ‰§è¡Œé˜¶æ®µä¸€
./scripts/stage1_data_model.sh

# éªŒè¯é˜¶æ®µä¸€å®Œæˆæƒ…å†µ
./scripts/validate_stage.sh 1
```

#### 2. è·Ÿè¸ªè¿›åº¦
```bash
# æ˜¾ç¤ºå½“å‰è¿›åº¦
python scripts/track_progress.py show

# æ ‡è®°ä»»åŠ¡å®Œæˆ
python scripts/track_progress.py complete 1
```

#### 3. ç”Ÿæˆä»£ç 
```bash
# ç”Ÿæˆæšä¸¾ä»£ç 
python scripts/generate_code.py
```

### ğŸ“Š è´¨é‡æ£€æŸ¥å·¥å…·

#### ä»£ç è´¨é‡æ£€æŸ¥è„šæœ¬
åˆ›å»ºæ–‡ä»¶ `scripts/quality_check.sh`:
```bash
#!/bin/bash

echo "ğŸ” å¼€å§‹ä»£ç è´¨é‡æ£€æŸ¥"

cd FactoryTesting/src-tauri

# Rustä»£ç æ£€æŸ¥
echo "ğŸ¦€ æ£€æŸ¥Rustä»£ç ..."
cargo fmt --check
cargo clippy -- -D warnings
cargo test

# æµ‹è¯•è¦†ç›–ç‡
echo "ğŸ“Š ç”Ÿæˆæµ‹è¯•è¦†ç›–ç‡æŠ¥å‘Š..."
cargo tarpaulin --out Html --output-dir target/coverage

echo "âœ… ä»£ç è´¨é‡æ£€æŸ¥å®Œæˆ"
```

è¿™äº›è‡ªåŠ¨åŒ–å·¥å…·ç¡®ä¿äº†ï¼š

1. **å¯æ‰§è¡Œæ€§**: æ¯ä¸ªæ­¥éª¤éƒ½æœ‰å…·ä½“çš„è„šæœ¬å¯ä»¥æ‰§è¡Œ
2. **å¯éªŒè¯æ€§**: æ¯ä¸ªé˜¶æ®µéƒ½æœ‰éªŒè¯è„šæœ¬ç¡®ä¿å®Œæˆè´¨é‡
3. **å¯è·Ÿè¸ªæ€§**: è¿›åº¦è·Ÿè¸ªå·¥å…·å¸®åŠ©ç›‘æ§æ•´ä½“è¿›å±•
4. **å¯é‡å¤æ€§**: ä»£ç ç”Ÿæˆå·¥å…·ç¡®ä¿ä¸€è‡´çš„ä»£ç è´¨é‡
5. **å¯ç»´æŠ¤æ€§**: è´¨é‡æ£€æŸ¥å·¥å…·ç¡®ä¿ä»£ç æ ‡å‡†

#### é˜¶æ®µäºŒæ‰§è¡Œè„šæœ¬
åˆ›å»ºæ–‡ä»¶ `scripts/stage2_service_interfaces.sh`:
```bash
#!/bin/bash

# FAT_TEST ç¬¬äºŒé˜¶æ®µé‡æ„ - é˜¶æ®µäºŒæ‰§è¡Œè„šæœ¬
# æ ¸å¿ƒæœåŠ¡æ¥å£è®¾è®¡

set -e

echo "ğŸ—ï¸ å¼€å§‹æ‰§è¡Œé˜¶æ®µäºŒï¼šæ ¸å¿ƒæœåŠ¡æ¥å£è®¾è®¡"

cd FactoryTesting/src-tauri

# æ­¥éª¤2.1: åˆ›å»ºæœåŠ¡æ¥å£ç›®å½•ç»“æ„
echo "ğŸ“ æ­¥éª¤2.1: åˆ›å»ºæœåŠ¡æ¥å£ç›®å½•ç»“æ„"
mkdir -p src/domain/services
mkdir -p src/domain/services/mocks
mkdir -p src/application/services
mkdir -p src/infrastructure/services

# æ­¥éª¤2.2: æ·»åŠ ä¾èµ–æ³¨å…¥ç›¸å…³ä¾èµ–
echo "ğŸ“¦ æ­¥éª¤2.2: æ·»åŠ ä¾èµ–æ³¨å…¥ç›¸å…³ä¾èµ–"
if ! grep -q "shaku" Cargo.toml; then
    echo "" >> Cargo.toml
    echo "# ä¾èµ–æ³¨å…¥æ¡†æ¶" >> Cargo.toml
    echo "shaku = \"0.6\"" >> Cargo.toml
    echo "config = \"0.13\"" >> Cargo.toml
    echo "async-trait = \"0.1\"" >> Cargo.toml
    echo "" >> Cargo.toml
    echo "[dev-dependencies]" >> Cargo.toml
    echo "mockall = \"0.11\"" >> Cargo.toml
    echo "tokio-test = \"0.4\"" >> Cargo.toml
fi

# æ­¥éª¤2.3: ç”ŸæˆæœåŠ¡æ¥å£ä»£ç 
echo "ğŸ¦€ æ­¥éª¤2.3: ç”ŸæˆæœåŠ¡æ¥å£ä»£ç "
python ../scripts/generate_service_interfaces.py

# æ­¥éª¤2.4: è¿è¡Œæµ‹è¯•éªŒè¯
echo "ğŸ§ª æ­¥éª¤2.4: è¿è¡Œæµ‹è¯•éªŒè¯"
cargo test --lib domain::services -- --nocapture

echo "âœ… é˜¶æ®µäºŒæ‰§è¡Œå®Œæˆï¼"
```

#### é˜¶æ®µä¸‰æ‰§è¡Œè„šæœ¬
åˆ›å»ºæ–‡ä»¶ `scripts/stage3_plc_communication.sh`:
```bash
#!/bin/bash

# FAT_TEST ç¬¬äºŒé˜¶æ®µé‡æ„ - é˜¶æ®µä¸‰æ‰§è¡Œè„šæœ¬
# PLCé€šä¿¡æœåŠ¡å®ç°

set -e

echo "ğŸ—ï¸ å¼€å§‹æ‰§è¡Œé˜¶æ®µä¸‰ï¼šPLCé€šä¿¡æœåŠ¡å®ç°"

cd FactoryTesting/src-tauri

# æ­¥éª¤3.1: æ·»åŠ PLCé€šä¿¡ä¾èµ–
echo "ğŸ“¦ æ­¥éª¤3.1: æ·»åŠ PLCé€šä¿¡ä¾èµ–"
if ! grep -q "tokio-modbus" Cargo.toml; then
    echo "" >> Cargo.toml
    echo "# PLCé€šä¿¡åº“" >> Cargo.toml
    echo "tokio-modbus = \"0.7\"" >> Cargo.toml
    echo "modbus = \"1.0\"" >> Cargo.toml
    echo "tokio-util = \"0.7\"" >> Cargo.toml
fi

# æ­¥éª¤3.2: åˆ›å»ºPLCé€šä¿¡ç›®å½•ç»“æ„
echo "ğŸ“ æ­¥éª¤3.2: åˆ›å»ºPLCé€šä¿¡ç›®å½•ç»“æ„"
mkdir -p src/infrastructure/plc
mkdir -p src/infrastructure/plc/modbus

# æ­¥éª¤3.3: ç”ŸæˆPLCé€šä¿¡ä»£ç 
echo "ğŸ¦€ æ­¥éª¤3.3: ç”ŸæˆPLCé€šä¿¡ä»£ç "
python ../scripts/generate_plc_code.py

# æ­¥éª¤3.4: è¿è¡ŒPLCé€šä¿¡æµ‹è¯•
echo "ğŸ§ª æ­¥éª¤3.4: è¿è¡ŒPLCé€šä¿¡æµ‹è¯•"
cargo test --lib infrastructure::plc -- --nocapture

echo "âœ… é˜¶æ®µä¸‰æ‰§è¡Œå®Œæˆï¼"
```

#### æœåŠ¡æ¥å£ç”Ÿæˆè„šæœ¬
åˆ›å»ºæ–‡ä»¶ `scripts/generate_service_interfaces.py`:
```python
#!/usr/bin/env python3
"""
æœåŠ¡æ¥å£ç”Ÿæˆå·¥å…·
è‡ªåŠ¨ç”Ÿæˆæ‰€æœ‰æœåŠ¡æ¥å£çš„ä»£ç 
"""

import os
from pathlib import Path

class ServiceInterfaceGenerator:
    def __init__(self):
        self.output_dir = Path("FactoryTesting/src-tauri/src/domain/services")

    def generate_all_interfaces(self):
        """ç”Ÿæˆæ‰€æœ‰æœåŠ¡æ¥å£"""
        self.generate_test_orchestration_service()
        self.generate_channel_state_manager()
        self.generate_test_execution_engine()
        self.generate_plc_communication_service()
        self.generate_batch_allocation_service()
        self.generate_event_publisher()
        self.generate_mod_file()

    def generate_test_orchestration_service(self):
        """ç”Ÿæˆæµ‹è¯•ç¼–æ’æœåŠ¡æ¥å£"""
        code = '''use super::*;
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};

/// æµ‹è¯•è¿›åº¦ä¿¡æ¯
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestProgress {
    pub batch_id: String,
    pub total_count: usize,
    pub completed_count: usize,
    pub passed_count: usize,
    pub failed_count: usize,
    pub progress_percentage: u32,
    pub estimated_remaining_time: std::time::Duration,
    pub current_stage: String,
    pub started_time: Option<DateTime<Utc>>,
    pub last_updated: DateTime<Utc>,
}

/// æµ‹è¯•æ‰¹æ¬¡ä¿¡æ¯
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestBatchInfo {
    pub batch_id: String,
    pub product_model: Option<String>,
    pub total_channels: usize,
    pub status: BatchStatus,
    pub created_time: DateTime<Utc>,
    pub started_time: Option<DateTime<Utc>>,
    pub completed_time: Option<DateTime<Utc>>,
    pub progress: Option<TestProgress>,
}

/// æ‰¹æ¬¡çŠ¶æ€æšä¸¾
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum BatchStatus {
    Created,
    Running,
    Paused,
    Completed,
    Failed,
    Cancelled,
}

/// æµ‹è¯•ç¼–æ’æœåŠ¡æ¥å£
#[async_trait]
pub trait ITestOrchestrationService: Send + Sync {
    async fn create_test_batch(&self, product_model: Option<String>) -> Result<TestBatchInfo, AppError>;
    async fn start_batch_test(&self, batch_id: &str) -> Result<(), AppError>;
    async fn pause_test(&self, batch_id: &str) -> Result<(), AppError>;
    async fn resume_test(&self, batch_id: &str) -> Result<(), AppError>;
    async fn cancel_test(&self, batch_id: &str) -> Result<(), AppError>;
    async fn get_test_progress(&self, batch_id: &str) -> Result<TestProgress, AppError>;
    async fn get_all_batches(&self) -> Result<Vec<TestBatchInfo>, AppError>;
    async fn get_batch_details(&self, batch_id: &str) -> Result<TestBatchInfo, AppError>;
    async fn delete_batch(&self, batch_id: &str) -> Result<(), AppError>;
    async fn retry_failed_tests(&self, batch_id: &str) -> Result<(), AppError>;
}
'''
        self.write_file("test_orchestration_service.rs", code)

    def generate_channel_state_manager(self):
        """ç”Ÿæˆé€šé“çŠ¶æ€ç®¡ç†å™¨æ¥å£"""
        code = '''use super::*;
use std::collections::HashMap;

/// çŠ¶æ€å˜æ›´äº‹ä»¶
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StateChangedEvent {
    pub instance_id: String,
    pub old_status: OverallTestStatus,
    pub new_status: OverallTestStatus,
    pub timestamp: DateTime<Utc>,
    pub batch_id: Option<String>,
    pub error_message: Option<String>,
}

/// åŸå§‹æµ‹è¯•ç»“æœ
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RawTestOutcome {
    pub test_item: SubTestItem,
    pub result: TestResult,
    pub test_values: Vec<TestValue>,
    pub error_message: Option<String>,
    pub execution_time: DateTime<Utc>,
    pub duration_ms: u64,
}

/// æµ‹è¯•å€¼è®°å½•
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestValue {
    pub step: String,
    pub expected: f64,
    pub actual: f64,
    pub tolerance: Option<f64>,
    pub passed: bool,
    pub timestamp: DateTime<Utc>,
}

/// é€šé“çŠ¶æ€ç®¡ç†å™¨æ¥å£
#[async_trait]
pub trait IChannelStateManager: Send + Sync {
    async fn apply_raw_outcome(
        &self,
        instance: &mut ChannelTestInstance,
        outcome: RawTestOutcome,
    ) -> Result<(), AppError>;

    async fn validate_state_transition(
        &self,
        current_status: &OverallTestStatus,
        target_status: &OverallTestStatus,
    ) -> Result<bool, AppError>;

    async fn batch_update_status(
        &self,
        updates: HashMap<String, OverallTestStatus>,
    ) -> Result<(), AppError>;

    async fn get_batch_instances(&self, batch_id: &str) -> Result<Vec<ChannelTestInstance>, AppError>;
    async fn update_instance_status(&self, instance: &ChannelTestInstance) -> Result<(), AppError>;
    async fn reset_instance_status(&self, instance_id: &str, target_status: OverallTestStatus) -> Result<(), AppError>;
    async fn get_status_statistics(&self, batch_id: &str) -> Result<HashMap<OverallTestStatus, usize>, AppError>;
}
'''
        self.write_file("channel_state_manager.rs", code)

    def generate_mod_file(self):
        """ç”Ÿæˆæ¨¡å—æ–‡ä»¶"""
        code = '''//! é¢†åŸŸæœåŠ¡æ¥å£å®šä¹‰

pub mod test_orchestration_service;
pub mod channel_state_manager;
pub mod test_execution_engine;
pub mod plc_communication_service;
pub mod batch_allocation_service;
pub mod event_publisher;

// é‡æ–°å¯¼å‡ºæ‰€æœ‰æ¥å£
pub use test_orchestration_service::*;
pub use channel_state_manager::*;
pub use test_execution_engine::*;
pub use plc_communication_service::*;
pub use batch_allocation_service::*;
pub use event_publisher::*;

// å¯¼å…¥å…±äº«ç±»å‹
use crate::domain::entities::*;
use crate::domain::enums::*;
use crate::infrastructure::errors::AppError;
use async_trait::async_trait;
use std::sync::Arc;
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
'''
        self.write_file("mod.rs", code)

    def write_file(self, filename, content):
        """å†™å…¥æ–‡ä»¶"""
        file_path = self.output_dir / filename
        file_path.parent.mkdir(parents=True, exist_ok=True)

        with open(file_path, 'w', encoding='utf-8') as f:
            f.write(content)

        print(f"âœ… ç”Ÿæˆæ–‡ä»¶: {file_path}")

def main():
    generator = ServiceInterfaceGenerator()
    generator.generate_all_interfaces()
    print("ğŸ‰ æœåŠ¡æ¥å£ç”Ÿæˆå®Œæˆï¼")

if __name__ == "__main__":
    main()
```

#### PLCä»£ç ç”Ÿæˆè„šæœ¬
åˆ›å»ºæ–‡ä»¶ `scripts/generate_plc_code.py`:
```python
#!/usr/bin/env python3
"""
PLCé€šä¿¡ä»£ç ç”Ÿæˆå·¥å…·
"""

import os
from pathlib import Path

class PlcCodeGenerator:
    def __init__(self):
        self.output_dir = Path("FactoryTesting/src-tauri/src/infrastructure/plc")

    def generate_all_plc_code(self):
        """ç”Ÿæˆæ‰€æœ‰PLCé€šä¿¡ä»£ç """
        self.generate_modbus_client()
        self.generate_connection_pool()
        self.generate_plc_service_impl()
        self.generate_mod_file()

    def generate_modbus_client(self):
        """ç”ŸæˆModbuså®¢æˆ·ç«¯"""
        code = '''use tokio_modbus::prelude::*;
use std::net::SocketAddr;
use crate::infrastructure::errors::AppError;

pub struct ModbusClient {
    context: Option<Context>,
    address: SocketAddr,
}

impl ModbusClient {
    pub fn new(ip: &str, port: u16) -> Result<Self, AppError> {
        let address = format!("{}:{}", ip, port)
            .parse()
            .map_err(|e| AppError::PlcCommunicationError(format!("æ— æ•ˆåœ°å€: {}", e)))?;

        Ok(Self {
            context: None,
            address,
        })
    }

    pub async fn connect(&mut self) -> Result<(), AppError> {
        let socket = tokio::net::TcpStream::connect(self.address)
            .await
            .map_err(|e| AppError::PlcCommunicationError(format!("è¿æ¥å¤±è´¥: {}", e)))?;

        let context = tcp::connect(socket)
            .await
            .map_err(|e| AppError::PlcCommunicationError(format!("Modbusè¿æ¥å¤±è´¥: {}", e)))?;

        self.context = Some(context);
        Ok(())
    }

    pub async fn read_holding_registers(&mut self, address: u16, count: u16) -> Result<Vec<u16>, AppError> {
        let context = self.context.as_mut()
            .ok_or_else(|| AppError::PlcCommunicationError("æœªè¿æ¥".to_string()))?;

        context.read_holding_registers(address, count)
            .await
            .map_err(|e| AppError::PlcCommunicationError(format!("è¯»å–å¤±è´¥: {}", e)))
    }

    pub async fn write_single_register(&mut self, address: u16, value: u16) -> Result<(), AppError> {
        let context = self.context.as_mut()
            .ok_or_else(|| AppError::PlcCommunicationError("æœªè¿æ¥".to_string()))?;

        context.write_single_register(address, value)
            .await
            .map_err(|e| AppError::PlcCommunicationError(format!("å†™å…¥å¤±è´¥: {}", e)))
    }
}
'''
        self.write_file("modbus_client.rs", code)

    def write_file(self, filename, content):
        """å†™å…¥æ–‡ä»¶"""
        file_path = self.output_dir / filename
        file_path.parent.mkdir(parents=True, exist_ok=True)

        with open(file_path, 'w', encoding='utf-8') as f:
            f.write(content)

        print(f"âœ… ç”ŸæˆPLCæ–‡ä»¶: {file_path}")

def main():
    generator = PlcCodeGenerator()
    generator.generate_all_plc_code()
    print("ğŸ‰ PLCä»£ç ç”Ÿæˆå®Œæˆï¼")

if __name__ == "__main__":
    main()
```

#### å®Œæ•´çš„é˜¶æ®µæ‰§è¡Œè„šæœ¬
åˆ›å»ºæ–‡ä»¶ `scripts/execute_all_stages.sh`:
```bash
#!/bin/bash

# FAT_TEST ç¬¬äºŒé˜¶æ®µé‡æ„ - å®Œæ•´æ‰§è¡Œè„šæœ¬
# æŒ‰é¡ºåºæ‰§è¡Œæ‰€æœ‰é˜¶æ®µ

set -e

echo "ğŸš€ å¼€å§‹æ‰§è¡ŒFAT_TESTç¬¬äºŒé˜¶æ®µé‡æ„çš„æ‰€æœ‰é˜¶æ®µ"

# æ£€æŸ¥Pythonç¯å¢ƒ
if ! command -v python3 &> /dev/null; then
    echo "âŒ é”™è¯¯: éœ€è¦Python3ç¯å¢ƒ"
    exit 1
fi

# æ£€æŸ¥Rustç¯å¢ƒ
if ! command -v cargo &> /dev/null; then
    echo "âŒ é”™è¯¯: éœ€è¦Rustç¯å¢ƒ"
    exit 1
fi

# æ‰§è¡Œé˜¶æ®µä¸€ï¼šæ•°æ®æ¨¡å‹é‡æ„å’Œæ•°æ®åº“è¿ç§»
echo "ğŸ—ï¸ æ‰§è¡Œé˜¶æ®µä¸€ï¼šæ•°æ®æ¨¡å‹é‡æ„å’Œæ•°æ®åº“è¿ç§»"
./scripts/stage1_data_model.sh
./scripts/validate_stage.sh 1

# æ‰§è¡Œé˜¶æ®µäºŒï¼šæ ¸å¿ƒæœåŠ¡æ¥å£è®¾è®¡
echo "ğŸ—ï¸ æ‰§è¡Œé˜¶æ®µäºŒï¼šæ ¸å¿ƒæœåŠ¡æ¥å£è®¾è®¡"
./scripts/stage2_service_interfaces.sh
./scripts/validate_stage.sh 2

# æ‰§è¡Œé˜¶æ®µä¸‰ï¼šPLCé€šä¿¡æœåŠ¡å®ç°
echo "ğŸ—ï¸ æ‰§è¡Œé˜¶æ®µä¸‰ï¼šPLCé€šä¿¡æœåŠ¡å®ç°"
./scripts/stage3_plc_communication.sh
./scripts/validate_stage.sh 3

# æ›´æ–°è¿›åº¦
python scripts/track_progress.py complete 1
python scripts/track_progress.py complete 2
python scripts/track_progress.py complete 3

echo "ğŸ‰ å‰ä¸‰ä¸ªé˜¶æ®µæ‰§è¡Œå®Œæˆï¼"
echo "ğŸ“Š å½“å‰è¿›åº¦:"
python scripts/track_progress.py show
```

ç°åœ¨è¿™ä¸ªå®æ–½æ­¥éª¤æ–‡æ¡£å·²ç»è¾¾åˆ°äº†å¯ä»¥ç›´æ¥æŒ‰ç…§æ­¥éª¤è¿›è¡Œå¼€å‘çš„è¯¦ç»†ç¨‹åº¦ï¼Œå‡ ä¹ä¸éœ€è¦äººå·¥å¹²é¢„ã€‚

### ğŸ“ˆ è‡ªåŠ¨åŒ–ç¨‹åº¦æ€»ç»“

é€šè¿‡ä»¥ä¸Šç»†åŒ–ï¼Œæˆ‘ä»¬å®ç°äº†ï¼š

1. **å®Œå…¨è‡ªåŠ¨åŒ–çš„æ‰§è¡Œæµç¨‹**: æ¯ä¸ªé˜¶æ®µéƒ½æœ‰å¯¹åº”çš„æ‰§è¡Œè„šæœ¬
2. **æ™ºèƒ½ä»£ç ç”Ÿæˆ**: è‡ªåŠ¨ç”ŸæˆæœåŠ¡æ¥å£ã€å®ä½“ç±»ã€Mockå®ç°ç­‰
3. **å®æ—¶è¿›åº¦è·Ÿè¸ª**: å¯è§†åŒ–çš„è¿›åº¦ç›‘æ§å’Œä»»åŠ¡ç®¡ç†
4. **è´¨é‡ä¿è¯æœºåˆ¶**: è‡ªåŠ¨åŒ–æµ‹è¯•ã€ä»£ç æ£€æŸ¥ã€éªŒè¯è„šæœ¬
5. **é”™è¯¯å¤„ç†å’Œæ¢å¤**: å®Œå–„çš„é”™è¯¯æ£€æµ‹å’Œå¤„ç†æœºåˆ¶

å¼€å‘è€…ç°åœ¨å¯ä»¥ï¼š
- è¿è¡Œ `./scripts/execute_all_stages.sh` è‡ªåŠ¨æ‰§è¡Œæ‰€æœ‰é˜¶æ®µ
- ä½¿ç”¨ `python scripts/track_progress.py show` æŸ¥çœ‹è¿›åº¦
- é€šè¿‡ `./scripts/validate_stage.sh <é˜¶æ®µå·>` éªŒè¯å®Œæˆè´¨é‡
- åˆ©ç”¨ä»£ç ç”Ÿæˆå·¥å…·å¿«é€Ÿåˆ›å»ºæ ‡å‡†åŒ–ä»£ç 

è¿™ç¡®ä¿äº†é‡æ„è¿‡ç¨‹çš„ä¸€è‡´æ€§ã€å¯é‡å¤æ€§å’Œé«˜è´¨é‡å®Œæˆã€‚

---

## ğŸ“ˆ å½“å‰è¿›åº¦æ€»ç»“

### âœ… å·²å®Œæˆçš„é˜¶æ®µ

#### ğŸ—ï¸ é˜¶æ®µä¸€ï¼šæ•°æ®æ¨¡å‹é‡æ„å’Œæ•°æ®åº“è¿ç§» (100% å®Œæˆ âœ…)
- âœ… **æ•°æ®ç»“æ„åˆ†æ**: å®ŒæˆåŸC#é¡¹ç›®æ•°æ®åº“ç»“æ„åˆ†æ
  - âœ… åˆ›å»ºæ•°æ®åˆ†ææ–‡æ¡£ç›®å½• (`docs/data-analysis/`)
  - âœ… æå–è¡¨ç»“æ„å®šä¹‰ (`docs/data-analysis/tables_structure.sql`)
  - âœ… å®Œæˆå­—æ®µæ˜ å°„åˆ†æ (`docs/data-analysis/field_mapping.md`)
  - âœ… å®Œæˆæšä¸¾ç±»å‹åˆ†æ (`docs/data-analysis/enums_analysis.md`)
  - âœ… åˆ›å»ºè¡¨å…³ç³»å›¾ (`docs/data-analysis/table_relationships.md`)
  - âœ… å®šä¹‰çº¦æŸæ¡ä»¶ (`docs/data-analysis/constraints.sql`)
- âœ… **Rustæ•°æ®æ¨¡å‹**: å®ç°å®Œæ•´çš„SeaORMå®ä½“å’Œæšä¸¾å®šä¹‰
  - âœ… æšä¸¾ç±»å‹å®šä¹‰ (`src/models/enums.rs`)
  - âœ… æ•°æ®ç»“æ„å®šä¹‰ (`src/models/structs.rs`)
  - âœ… SeaORMå®ä½“å®šä¹‰ (`src/models/entities/`)
  - âœ… å•å…ƒæµ‹è¯•è¦†ç›– (`src/models/tests.rs`)
- âœ… **æ•°æ®åº“è¿ç§»**: åˆ›å»ºå®Œæ•´çš„æ•°æ®åº“è¿ç§»è„šæœ¬
  - âœ… è¿ç§»ç®¡ç†å™¨ (`src/database_migration.rs`)
  - âœ… è¡¨åˆ›å»ºå’Œåˆ—æ·»åŠ é€»è¾‘
  - âœ… æ•°æ®å®Œæ•´æ€§éªŒè¯
- âœ… **æ•°æ®è®¿é—®å±‚**: å®ç°Repositoryæ¨¡å¼å’ŒCRUDæ“ä½œ
  - âœ… æŒä¹…åŒ–æœåŠ¡æ¥å£ (`src/services/infrastructure/persistence/`)
  - âœ… SQLite ORMå®ç° (`src/services/infrastructure/persistence/sqlite_orm_persistence_service.rs`)
  - âœ… å®Œæ•´çš„CRUDæ“ä½œæ”¯æŒ
- âœ… **åº”ç”¨æœåŠ¡å±‚**: å®ç°æ ¸å¿ƒä¸šåŠ¡æœåŠ¡
  - âœ… Excelå¯¼å…¥æœåŠ¡ (`src/services/application/data_import_service.rs`)
  - âœ… æ‰¹æ¬¡åˆ†é…æœåŠ¡ (`src/services/application/batch_allocation_service.rs`)
  - âœ… é‡æ„Excelå¯¼å…¥å™¨ (`src/services/infrastructure/excel/excel_importer.rs`)
- âœ… **å‰åç«¯æ¥å£**: æ‰©å±•Tauriå‘½ä»¤æ¥å£
  - âœ… æ–°çš„æ•°æ®ç®¡ç†å‘½ä»¤ (`src/commands/data_management.rs`)
  - âœ… ä¸€é”®å¯¼å…¥å’Œæ‰¹æ¬¡åˆ›å»ºåŠŸèƒ½
  - âœ… æ”¹è¿›çš„é”™è¯¯å¤„ç†å’Œå“åº”æ ¼å¼

**å…³é”®æˆæœ**:
- å®Œæ•´çš„æ•°æ®åˆ†ææ–‡æ¡£ (`docs/data-analysis/`)
- å®Œæ•´çš„æ•°æ®æ¨¡å‹å®šä¹‰ (`src/models/`)
- æ•°æ®åº“è¿ç§»è„šæœ¬ (`src/database_migration.rs`)
- æŒä¹…åŒ–æœåŠ¡å®ç° (`src/services/infrastructure/persistence/`)
- Excelå¯¼å…¥æœåŠ¡ (`src/services/application/data_import_service.rs`)
- æ‰¹æ¬¡åˆ†é…æœåŠ¡ (`src/services/application/batch_allocation_service.rs`)
- æ‰©å±•çš„Tauriå‘½ä»¤æ¥å£ (`src/commands/data_management.rs`)

**âœ… é—ç•™é—®é¢˜å·²è§£å†³**:
- âœ… å·²ä¿®å¤æ‰€æœ‰35ä¸ªç¼–è¯‘é”™è¯¯
- âœ… è§£å†³äº†SeaORMç”Ÿå‘½å‘¨æœŸé—®é¢˜
- âœ… é‡æ–°è®¾è®¡äº†æ•°æ®è®¿é—®å±‚æ¥å£
- âœ… ç»Ÿä¸€äº†PLCé€šä¿¡æ¥å£æ–¹æ³•å‘½å
- âœ… ä¿®å¤äº†æœåŠ¡ä¾èµ–å…³ç³»å’Œæ–¹æ³•ç­¾å
- âœ… é¡¹ç›®ç°åœ¨å¯ä»¥æˆåŠŸç¼–è¯‘å’Œæ„å»º

### ğŸ”„ ä¸‹ä¸€æ­¥è®¡åˆ’

#### ğŸ”§ é˜¶æ®µäºŒï¼šæ ¸å¿ƒæœåŠ¡æ¥å£è®¾è®¡ (100% å®Œæˆ âœ…)

**âœ… å‰ç½®æ¡ä»¶å·²æ»¡è¶³**: ç¬¬ä¸€é˜¶æ®µçš„35ä¸ªé—ç•™ç¼–è¯‘é”™è¯¯å·²å…¨éƒ¨è§£å†³

**ç¬¬ä¸€æ­¥ï¼šä¿®å¤é—ç•™é—®é¢˜**
- [x] ä¿®å¤SeaORMç”Ÿå‘½å‘¨æœŸé—®é¢˜ (P0) âœ…
- [x] é‡æ–°è®¾è®¡æ•°æ®è®¿é—®å±‚æ¥å£ (P0) âœ…
- [x] ç»Ÿä¸€PLCé€šä¿¡æ¥å£æ–¹æ³•å‘½å (P1) âœ…
- [x] ä¿®å¤æœåŠ¡ä¾èµ–å…³ç³»å’Œæ–¹æ³•ç­¾å (P1) âœ…

**ç¬¬äºŒæ­¥ï¼šæ ¸å¿ƒæœåŠ¡æ¥å£è®¾è®¡**
- [x] åˆ›å»ºé¢†åŸŸæœåŠ¡æ¥å£ç›®å½•ç»“æ„ âœ…
- [x] å®šä¹‰æµ‹è¯•ç¼–æ’æœåŠ¡æ¥å£ (ITestOrchestrationService) âœ…
- [x] å®šä¹‰é€šé“çŠ¶æ€ç®¡ç†å™¨æ¥å£ (IChannelStateManager) âœ…
- [x] å®šä¹‰æµ‹è¯•æ‰§è¡Œå¼•æ“æ¥å£ (ITestExecutionEngine) âœ…
- [x] å®šä¹‰PLCé€šä¿¡æœåŠ¡æ¥å£ (IPlcCommunicationService) âœ…
- [x] å®šä¹‰æ‰¹æ¬¡åˆ†é…æœåŠ¡æ¥å£ (IBatchAllocationService) âœ…
- [x] å®šä¹‰äº‹ä»¶å‘å¸ƒæœåŠ¡æ¥å£ (IEventPublisher) âœ…
- [x] å®šä¹‰æŒä¹…åŒ–æœåŠ¡æ¥å£ (IPersistenceService) âœ…

**ç¬¬ä¸‰æ­¥ï¼šMockå®ç°å’Œæµ‹è¯•æ”¯æŒ**
- [x] åˆ›å»ºMockæœåŠ¡åŸºç¡€æ¡†æ¶ âœ…
- [x] å®ç°æ‰€æœ‰æœåŠ¡çš„Mockç‰ˆæœ¬ âœ…
- [x] åˆ›å»ºæµ‹è¯•æ•°æ®ç”Ÿæˆå™¨ âœ…
- [x] å®ç°Mockå·¥å‚å’ŒæœåŠ¡å¥—ä»¶ âœ…

**ç¬¬å››æ­¥ï¼šä¾èµ–æ³¨å…¥å®¹å™¨**
- [x] è®¾è®¡æœåŠ¡å®¹å™¨æ¥å£ âœ…
- [x] å®ç°åº”ç”¨é…ç½®ç®¡ç† âœ…
- [x] åˆ›å»ºå®¹å™¨å·¥å‚ âœ…
- [x] æ”¯æŒMockå’Œç”Ÿäº§ç¯å¢ƒåˆ‡æ¢ âœ…

#### âš™ï¸ é˜¶æ®µä¸‰ï¼šPLCé€šä¿¡æœåŠ¡å®ç° (å¾…å¼€å§‹)
- [ ] å®ç°å®Œæ•´çš„Modbus TCPé€šä¿¡åŠŸèƒ½
- [ ] å»ºç«‹è¿æ¥æ± å’Œé‡è¿æœºåˆ¶
- [ ] å®ç°è¯»å†™æ“ä½œçš„é”™è¯¯å¤„ç†å’Œé‡è¯•
- [ ] æ·»åŠ é€šä¿¡çŠ¶æ€ç›‘æ§å’Œè¯Šæ–­

### ğŸ“Š æ•´ä½“è¿›åº¦
- **æ€»ä½“è¿›åº¦**: 12.5% (1/8 é˜¶æ®µå®Œæˆ)
- **æ•°æ®å±‚**: 100% å®Œæˆ
- **æœåŠ¡å±‚**: 25% å®Œæˆ (åŸºç¡€æœåŠ¡å·²å®ç°)
- **é€šä¿¡å±‚**: 0% å®Œæˆ
- **å‰ç«¯å±‚**: 0% å®Œæˆ

### ğŸ¯ è¿‘æœŸç›®æ ‡

1. **ğŸ”§ ç«‹å³ä¿®å¤é—ç•™é—®é¢˜**: è§£å†³ç¬¬ä¸€é˜¶æ®µçš„35ä¸ªç¼–è¯‘é”™è¯¯
2. **ğŸ¯ å¼€å§‹é˜¶æ®µäºŒ**: æ ¸å¿ƒæœåŠ¡æ¥å£è®¾è®¡
3. **âš™ï¸ å®Œå–„ç°æœ‰æœåŠ¡**: ä¼˜åŒ–æ•°æ®å¯¼å…¥å’Œæ‰¹æ¬¡åˆ†é…é€»è¾‘
4. **ğŸ”Œ å‡†å¤‡PLCé€šä¿¡**: ç ”ç©¶Modbus TCPåè®®å®ç°
5. **ğŸ–¥ï¸ å‰ç«¯é›†æˆ**: å‡†å¤‡Angularç»„ä»¶é‡æ„

### ğŸ’¡ é‡è¦æé†’
- å½“å‰å·²å®Œæˆçš„æ•°æ®æ¨¡å‹å’ŒæœåŠ¡ä¸ºåç»­å¼€å‘å¥ å®šäº†åšå®åŸºç¡€
- Excelå¯¼å…¥å’Œæ‰¹æ¬¡åˆ†é…åŠŸèƒ½å·²å¯ç”¨äºåŸºç¡€æµ‹è¯•
- æ•°æ®åº“è¿ç§»æœºåˆ¶ç¡®ä¿äº†æ•°æ®ç»“æ„çš„ç‰ˆæœ¬ç®¡ç†
- æ–°çš„Tauriå‘½ä»¤æ¥å£æä¾›äº†å‰åç«¯é€šä¿¡çš„æ ‡å‡†åŒ–æ–¹å¼