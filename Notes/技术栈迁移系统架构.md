# 技术栈迁移系统架构设计 (FAT_TEST 项目)

## 1. 引言与背景

本文档旨在为 FAT_TEST 项目从现有 C# WPF 技术栈迁移至 `Rust + Angular + Tauri` 技术栈提供一套详细的系统架构设计方案。

**迁移的主要驱动因素包括：**

*   **现有 `ViewModel` 过于臃肿**：`DataEditViewModel` 承担了过多的职责，包括UI逻辑、业务流程编排、状态管理等，导致代码难以维护、扩展和测试。
*   **职责划分不清**：服务层之间存在部分职责重叠，数据模型与业务逻辑耦合较紧。
*   **性能瓶颈**：现有架构在处理大量数据和高并发测试时面临性能挑战。
*   **技术栈现代化**：期望利用 Rust 的高性能、高并发和内存安全特性优化后端逻辑，利用 Angular 构建现代化的Web前端用户界面，并通过 Tauri 实现跨平台桌面应用打包。

**重构目标：**

*   **清晰的职责分离**：遵循SOLID原则，将业务逻辑、应用逻辑、领域逻辑和基础设施明确划分。
*   **高内聚、低耦合**：模块化设计，减少各组件之间的依赖。
*   **提升系统性能与可扩展性**：充分发挥新技术栈的优势。
*   **提高可维护性与可测试性**：代码结构清晰，易于理解、修改和单元测试。
*   **平滑迁移**：提取现有系统的核心业务逻辑，确保在新架构中完整实现并优化。

## 2. 总体架构设计

系统将采用分层架构，并明确划分前端（Angular + Tauri）和后端（Rust）的职责。

```mermaid
graph TD
    subgraph 前端 (Angular + Tauri Desktop App)
        direction LR
        A_View[View (Angular Components)] --> A_ViewModel[ViewModel/Component Logic (Angular Services/Components)]
        A_ViewModel --> A_UIInteraction[UI Interaction Service (Angular/Tauri)]
        A_ViewModel --> A_StateManagement[Frontend State Management (e.g., NgRx, Akita - Optional)]
        A_ViewModel --> TauriBridge[Tauri IPC Bridge]
    end

    subgraph 后端 (Rust Core Logic)
        direction LR
        subgraph Application Layer
            R_TestOrchestration[Test Orchestration Service]
            R_DataManagement[Data Management Service]
            R_ManualTest[Manual Test Service]
            R_ChannelConfig[Channel Configuration Service]
        end

        subgraph Domain Layer
            R_ChannelState[Channel State Manager]
            R_TestExecution[Test Execution Engine]
            R_StepExecutor[Specific Test Step Executors]
            R_Statistics[Statistics Service]
            R_TestRecord[Test Record Service]
            R_Models[Core Domain Models (Structs)]
        end

        subgraph Infrastructure Layer
            R_PLC[PLC/Hardware Interaction Service]
            R_Persistence[Persistence Service (DB/File)]
        end

        R_TestOrchestration --> R_TestExecution
        R_TestOrchestration --> R_ChannelConfig
        R_TestOrchestration --> R_DataManagement
        R_TestOrchestration --> R_ChannelState
        R_TestOrchestration --> R_Statistics
        R_TestOrchestration --> R_TestRecord
        R_ManualTest --> R_StepExecutor
        R_ManualTest --> R_ChannelState
        R_TestExecution --> R_StepExecutor
        R_TestExecution --> R_ChannelState
        R_TestExecution --> R_PLC
        R_StepExecutor --> R_PLC
        R_ChannelState --> R_Models
        R_DataManagement --> R_Persistence
        R_TestRecord --> R_Persistence
        R_ChannelConfig --> R_Persistence
    end

    TauriBridge --- R_TestOrchestration
    TauriBridge --- R_DataManagement
    TauriBridge --- R_ManualTest
    TauriBridge --- R_ChannelConfig
    TauriBridge --- R_Statistics
    TauriBridge --- R_TestRecord

    A_UIInteraction -.-> TauriBridge  // UI 服务可能通过 Tauri 调用原生对话框等

    classDef frontend fill:#D6EAF8,stroke:#3498DB,stroke-width:2px;
    classDef backend fill:#D1F2EB,stroke:#1ABC9C,stroke-width:2px;
    class A_View,A_ViewModel,A_UIInteraction,A_StateManagement,TauriBridge frontend;
    class R_TestOrchestration,R_DataManagement,R_ManualTest,R_ChannelConfig,R_ChannelState,R_TestExecution,R_StepExecutor,R_Statistics,R_TestRecord,R_Models,R_PLC,R_Persistence backend;
```

**核心组件职责概述：**

*   **前端 (Angular + Tauri)**:
    *   **View (Angular Components)**: 用户界面元素和布局。
    *   **ViewModel/Component Logic**: 处理用户输入，调用后端服务，管理视图状态。
    *   **UI Interaction Service**: 封装对话框、通知等UI交互。
    *   **Frontend State Management (可选)**: 管理复杂前端状态。
    *   **Tauri IPC Bridge**: Angular 与 Rust 后端通过 Tauri 的 Inter-Process Communication (IPC) 机制进行通信。

*   **后端 (Rust Core Logic)**:
    *   **Application Layer**: 编排领域服务以完成特定应用场景（用例）。
        *   `Test Orchestration Service`: 负责整个测试流程的启动、监控、协调。
        *   `Data Management Service`: 负责数据的导入、导出、转换。
        *   `Manual Test Service`: 处理手动测试请求。
        *   `Channel Configuration Service`: 管理测试点配置。
    *   **Domain Layer**: 包含核心业务逻辑和领域对象。
        *   `Channel State Manager`: **唯一负责修改核心通道状态的地方**。根据业务规则和测试结果更新状态。
        *   `Test Execution Engine`: 负责具体测试任务（步骤）的并发执行和生命周期管理。
        *   `Specific Test Step Executors`: 实现原子化的测试步骤逻辑（如AI点硬采、DI点报警测试）。
        *   `Statistics Service`: 计算测试相关的统计数据。
        *   `Test Record Service`: 管理测试历史记录的存储和查询。
        *   `Core Domain Models`: 纯数据结构 (Rust structs)，定义业务实体如通道、测试结果等。
    *   **Infrastructure Layer**: 提供与外部系统（硬件、数据库、文件系统）交互的能力。
        *   `PLC/Hardware Interaction Service`: 封装与PLC或其他测试硬件的通信。
        *   `Persistence Service`: 抽象数据持久化操作（数据库、文件等）。

## 3. 核心数据模型 (Rust Structs / TypeScript Interfaces)

以下数据模型是系统的核心，将在Rust后端定义为struct，并在Angular前端可能需要对应的TypeScript接口进行数据交换。

### 3.1. 枚举类型 (Enums)

```rust
// Rust Enum Examples
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)] // Serialize/Deserialize for IPC
pub enum OverallTestStatus {
    NotTested,
    Skipped,
    WiringConfirmed, // 接线已确认，等待开始硬点或手动测试
    HardPointTesting,
    HardPointTestCompleted,
    ManualTesting,
    TestCompletedPassed,
    TestCompletedFailed,
    Retesting,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum SubTestStatus {
    NotTested,
    Testing,
    Passed,
    Failed,
    NotApplicable, // 不适用
    Skipped,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum ModuleType {
    AI,       // Analog Input
    AO,       // Analog Output
    DI,       // Digital Input
    DO,       // Digital Output
    AINone,   // Analog Input (无源，特殊处理逻辑)
    AONone,   // Analog Output (无源)
    DINone,   // Digital Input (无源)
    DONone,   // Digital Output (无源)
    // ... 其他特定模块类型
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum PointDataType {
    Bool,
    Float,
    Int,
    // ... 其他数据类型
}

// 对应原 ChannelMapping.cs 中的各种子测试项
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)] // Eq, Hash for use as HashMap key
pub enum SubTestItem {
    // 通用
    HardPoint,      // 硬点回路测试 (核心)
    TrendCheck,     // 趋势检查 (AI/AO)
    ReportCheck,    // 报表检查 (AI/AO)
    
    // AI 特有
    LowLowAlarm,    // 低低报
    LowAlarm,       // 低报
    HighAlarm,      // 高报
    HighHighAlarm,  // 高高报
    AlarmValueSetting, // 报警值设定整体状态 (AI)
    MaintenanceFunction, // 维护功能 (AI/AO)

    // DI/DO 特有
    StateDisplay,   // 状态显示/回读 (DI/DO)

    // AO 特有 (可能包含在HardPoint内或单独列出)
    // Output0Percent,
    // Output25Percent,
    // ... Output100Percent
}
```

### 3.2. 核心实体模型

#### 3.2.1. `ChannelPointDefinition` (通道点位定义)

描述一个测试点的静态配置信息，通常从Excel或配置文件导入，在测试任务开始后基本不变。

```rust
// Rust Struct Example
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChannelPointDefinition {
    pub id: String, // 唯一标识符 (e.g., GUID string)
    pub tag: String, // 位号
    pub variable_name: String, // 变量名 (HMI)
    pub variable_description: String, // 变量描述

    pub station_name: String, // 站名
    pub module_name: String,  // 模块名
    pub module_type: ModuleType, // 模块类型 (AI, DI, etc.)
    pub channel_tag_in_module: String, // 在模块内的通道号/标签

    pub data_type: PointDataType, // 数据类型 (Bool, Float)
    pub power_supply_type: String, // 供电类型 (e.g., "有源", "无源")
    pub wire_system: String,      // 线制 (e.g., "2线制", "4线制")
    
    // PLC 相关地址信息
    pub plc_absolute_address: Option<String>, // PLC绝对地址 (if any)
    pub plc_communication_address: String, // PLC通信地址 (核心)

    // 量程信息 (主要用于 AI/AO)
    pub range_lower_limit: Option<f32>,
    pub range_upper_limit: Option<f32>,
    pub engineering_unit: Option<String>, // 工程单位 (e.g., "mA", "V", "°C")

    // 报警设定点信息 (主要用于 AI)
    // (地址 + 设定值)
    pub sll_set_value: Option<f32>,
    pub sll_set_point_address: Option<String>, // 低低报设定值写入地址
    pub sll_feedback_address: Option<String>,  // 低低报状态读取地址

    pub sl_set_value: Option<f32>,
    pub sl_set_point_address: Option<String>,
    pub sl_feedback_address: Option<String>,

    pub sh_set_value: Option<f32>,
    pub sh_set_point_address: Option<String>,
    pub sh_feedback_address: Option<String>,

    pub shh_set_value: Option<f32>,
    pub shh_set_point_address: Option<String>,
    pub shh_feedback_address: Option<String>,

    // 维护模式相关 (主要用于 AI)
    pub maintenance_value_set_point_address: Option<String>,
    pub maintenance_enable_switch_point_address: Option<String>,

    // 其他配置信息
    pub access_property: Option<String>, // 读写属性
    pub save_history: Option<bool>,    // 是否保存历史
    pub power_failure_protection: Option<bool>, // 是否掉电保护

    // 测试台架（硬接线）相关配置 (如果与被测PLC地址不同)
    pub test_rig_plc_address: Option<String>, // 测试台架上对应的PLC地址
}
```

#### 3.2.2. `ChannelTestInstance` (通道测试实例)

代表一个 `ChannelPointDefinition` 在某次特定测试执行（如一个批次）中的实例，包含其动态状态和最终结果。

```rust
// Rust Struct Example
use std::collections::HashMap;
use chrono::{DateTime, Utc};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChannelTestInstance {
    pub instance_id: String, // 本次测试实例的唯一ID (e.g., GUID string)
    pub definition_id: String, // 关联的 ChannelPointDefinition.id
    pub test_batch_id: String, // 所属测试批次ID

    // 运行时状态 (由 ChannelStateManager 管理)
    pub overall_status: OverallTestStatus,
    pub current_step_details: Option<String>, // 当前正在执行的测试步骤描述
    pub error_message: Option<String>,      // 最近的错误信息
    
    pub start_time: Option<DateTime<Utc>>,
    pub last_updated_time: DateTime<Utc>,
    pub final_test_time: Option<DateTime<Utc>>,
    pub total_test_duration_ms: Option<i64>,

    // 各子测试项的状态和结果
    // Key: SubTestItem enum, Value: SubTestExecutionResult
    pub sub_test_results: HashMap<SubTestItem, SubTestExecutionResult>,

    // 硬接线测试中的特定数据 (AI/AO)
    pub hardpoint_readings: Option<Vec<AnalogReadingPoint>>, // e.g., 0%, 25%, 50%, 75%, 100% 的设定值和实际读值
    // DI/DO 硬接线可能只需要一个最终状态

    // 手动测试时的临时输入/输出值 (如果需要在前端显示)
    pub manual_test_current_value_input: Option<String>,
    pub manual_test_current_value_output: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SubTestExecutionResult {
    pub status: SubTestStatus,
    pub details: Option<String>,         // 详细信息或错误消息
    pub expected_value: Option<String>,
    pub actual_value: Option<String>,
    pub timestamp: DateTime<Utc>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AnalogReadingPoint {
    pub set_percentage: f32, // e.g., 0.0, 0.25, 0.5, 0.75, 1.0
    pub set_value_eng: f32,  // 对应的工程单位设定值
    pub expected_reading_raw: Option<f32>, // 期望的PLC原始读值 (if applicable)
    pub actual_reading_raw: Option<f32>,   // 实际的PLC原始读值
    pub actual_reading_eng: Option<f32>,  // 转换后的工程单位读值
    pub status: SubTestStatus, // 该点的测试状态
}
```

#### 3.2.3. `TestBatchInfo` (测试批次信息)

```rust
// Rust Struct Example
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestBatchInfo {
    pub batch_id: String, // 批次唯一ID (e.g., GUID string or "产品型号_序列号_日期")
    pub product_model: Option<String>,
    pub serial_number: Option<String>,
    pub customer_name: Option<String>,
    pub creation_time: DateTime<Utc>,
    pub status_summary: Option<String>, // e.g., "进行中", "已完成 - 50/52 通过"
    // 可包含一些统计信息
    pub total_points: u32,
    pub tested_points: u32,
    pub passed_points: u32,
    pub failed_points: u32,
}
```

#### 3.2.4. `RawTestOutcome` (原始测试结果)

由 `SpecificTestStepExecutor` 执行后返回的原始数据，供 `ChannelStateManager` 处理。

```rust
// Rust Struct Example
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RawTestOutcome {
    pub channel_instance_id: String,
    pub sub_test_item: SubTestItem, // 本次执行的是哪个子测试项
    pub success: bool,              // 本次操作是否成功
    pub raw_value_read: Option<String>, // 从PLC读取的原始值 (if any)
    pub eng_value_calculated: Option<String>, // 计算得到的工程单位值 (if any)
    pub message: Option<String>,        // 附加信息或错误细节
    pub timestamp: DateTime<Utc>,
    // 特定测试可能需要更多字段
    // e.g., for multi-point analog test:
    pub analog_reading_point: Option<AnalogReadingPoint>, 
}
```

---

## 4. 后端服务接口与职责 (Rust)

后端服务将采用分层设计，主要包括应用服务层、领域服务层和基础设施层。所有服务接口的设计应考虑异步执行 (`async/await` in Rust)，并明确错误处理机制 (e.g., using `Result<T, E>`).

### 4.1. 应用服务层 (Application Layer)

应用服务层负责编排领域服务以完成特定的用户场景或用例。它们是前端通过Tauri IPC调用的主要入口点。

#### 4.1.1. `DataManagementService` (数据管理服务)

*   **职责**: 处理测试数据的导入、导出和转换。
*   **Rust Trait (Interface) 定义**: (示例)
    ```rust
    use crate::models::{ChannelPointDefinition, TestBatchInfo, ChannelTestInstance};
    use crate::error::AppError; // 自定义错误类型
    use std::path::PathBuf;

    #[async_trait::async_trait] // 使用 async_trait 宏来支持 trait 中的异步方法
    pub trait IDataManagementService: Send + Sync {
        /// 从指定路径的Excel文件导入点位配置数据。
        /// 返回点位定义列表和可能的批次信息。
        async fn import_channel_definitions_from_excel(
            &self,
            file_path: PathBuf
        ) -> Result<(Vec<ChannelPointDefinition>, Option<TestBatchInfo>), AppError>;

        /// 导出指定批次的测试结果到Excel文件。
        async fn export_test_results_to_excel(
            &self,
            batch_id: &str,
            instances: Vec<ChannelTestInstance>,
            target_file_path: PathBuf
        ) -> Result<(), AppError>;

        /// 加载已保存的测试点配置。
        async fn load_channel_definitions(&self, config_name: &str) -> Result<Vec<ChannelPointDefinition>, AppError>;
        
        /// 保存当前测试点配置。
        async fn save_channel_definitions(&self, config_name: &str, definitions: &[ChannelPointDefinition]) -> Result<(), AppError>;

        // 其他可能的方法：从API导入，转换数据格式等
    }
    ```
*   **主要交互**: `PersistenceService` (读写配置文件/数据), `ChannelStateManager` (可能调用其初始化方法，或服务自身处理基于 `ChannelPointDefinition` 创建 `ChannelTestInstance` 的初始状态)。

#### 4.1.2. `ChannelConfigurationService` (通道配置服务)

*   **职责**: 管理 `ChannelPointDefinition` 的 CRUD 操作（如果需要独立于导入/导出的配置管理），提供查询和筛选功能。
*   **Rust Trait 定义**: (示例)
    ```rust
    use crate::models::ChannelPointDefinition;
    use crate::error::AppError;

    #[async_trait::async_trait]
    pub trait IChannelConfigurationService: Send + Sync {
        async fn get_all_definitions(&self) -> Result<Vec<ChannelPointDefinition>, AppError>;
        async fn get_definition_by_id(&self, id: &str) -> Result<Option<ChannelPointDefinition>, AppError>;
        async fn add_definition(&self, definition: ChannelPointDefinition) -> Result<String, AppError>; // returns ID
        async fn update_definition(&self, definition: ChannelPointDefinition) -> Result<(), AppError>;
        async fn delete_definition(&self, id: &str) -> Result<(), AppError>;
        // async fn find_definitions_by_module_type(&self, module_type: ModuleType) -> Result<Vec<ChannelPointDefinition>, AppError>;
    }
    ```
*   **主要交互**: `PersistenceService`。

#### 4.1.3. `TestOrchestrationService` (测试编排服务)

*   **职责**: 核心应用服务，负责整个测试流程的启动、监控、协调和管理。
*   **Rust Trait 定义**: (示例)
    ```rust
    use crate::models::{TestBatchInfo, ChannelPointDefinition, ChannelTestInstance};
    use crate::error::AppError;

    #[async_trait::async_trait]
    pub trait ITestOrchestrationService: Send + Sync {
        /// 创建一个新的测试批次。
        async fn create_test_batch(
            &self, 
            product_model: Option<String>, 
            serial_number: Option<String>
        ) -> Result<TestBatchInfo, AppError>;

        /// 为指定批次加载并准备测试实例。
        /// definitions_ids: 要测试的点位定义ID列表。如果为空，则可能测试该批次关联的所有已配置点位。
        async fn prepare_test_instances_for_batch(
            &self, 
            batch_id: &str, 
            definition_ids: Vec<String>
        ) -> Result<Vec<ChannelTestInstance>, AppError>; // 返回准备好的测试实例列表
        
        /// 确认指定批次的接线已完成。
        async fn confirm_wiring_for_batch(&self, batch_id: &str) -> Result<(), AppError>;

        /// 启动指定批次中所有准备好的（或特定筛选条件的）测试实例。
        async fn start_tests_for_batch(
            &self, 
            batch_id: &str, 
            // instance_ids_to_test: Option<Vec<String>> // 可选，如果只想启动部分
        ) -> Result<(), AppError>;

        /// 暂停指定批次的所有测试。
        async fn pause_tests_for_batch(&self, batch_id: &str) -> Result<(), AppError>;

        /// 继续指定批次的所有测试。
        async fn resume_tests_for_batch(&self, batch_id: &str) -> Result<(), AppError>;

        /// 停止/取消指定批次的所有测试。
        async fn stop_tests_for_batch(&self, batch_id: &str) -> Result<(), AppError>;

        /// 重测指定的单个测试实例。
        async fn retest_channel_instance(&self, instance_id: &str) -> Result<(), AppError>;

        /// 跳过指定的单个测试实例。
        async fn skip_channel_instance(&self, instance_id: &str, reason: String) -> Result<(), AppError>;

        /// 获取指定批次的当前状态和所有测试实例信息。
        async fn get_batch_status_and_instances(
            &self, 
            batch_id: &str
        ) -> Result<(TestBatchInfo, Vec<ChannelTestInstance>), AppError>;

        /// 获取单个测试实例的详细信息。
        async fn get_channel_instance_details(&self, instance_id: &str) -> Result<Option<ChannelTestInstance>, AppError>;
    }
    ```
*   **主要交互**: `ChannelConfigurationService`, `TestExecutionEngine`, `ChannelStateManager`, `StatisticsService`, `TestRecordService`, `NotificationService` (用于向前端发送实时更新事件，如进度、状态变化)。

#### 4.1.4. `ManualTestService` (手动测试服务)

*   **职责**: 处理用户发起的手动单点、单项测试操作。
*   **Rust Trait 定义**: (示例)
    ```rust
    use crate::models::{RawTestOutcome, SubTestItem};
    use crate::error::AppError;

    #[async_trait::async_trait]
    pub trait IManualTestService: Send + Sync {
        /// 执行一个手动子测试项。
        /// channel_instance_id: 要操作的通道测试实例ID。
        /// item: 要测试的具体子项 (e.g., SubTestItem::HighAlarm)。
        /// params: 执行该测试项可能需要的参数 (e.g., 对于AI输出测试，可能是要设定的值)。
        async fn execute_manual_sub_test(
            &self, 
            channel_instance_id: &str, 
            item: SubTestItem, 
            params: Option<serde_json::Value> // 使用serde_json::Value传递灵活参数
        ) -> Result<RawTestOutcome, AppError>;
        
        /// 读取通道的当前值 (用于手动测试界面显示)。
        async fn read_current_value(&self, channel_instance_id: &str, item_to_read: Option<SubTestItem>) -> Result<String, AppError>;

        /// 向通道写入一个值 (用于手动测试，如AO输出或DO置位)。
        async fn write_value_manual(&self, channel_instance_id: &str, value_to_write: String) -> Result<(), AppError>;
    }
    ```
*   **主要交互**: `SpecificTestStepExecutor` (或其一部分逻辑), `ChannelStateManager` (更新状态), `PLCCommunicationService`。

---

### 4.2. 领域服务层 (Domain Layer)

领域服务层封装了核心业务规则和逻辑。它们通常被应用服务层调用。

#### 4.2.1. `ChannelStateManager` (通道状态管理器)

*   **职责**: **唯一负责修改 `ChannelTestInstance` 核心状态的地方**。根据业务规则和 `RawTestOutcome` 更新状态。不包含I/O或UI逻辑。符合 FAT-CSM-001, FAT-CSM-002 规则。
*   **Rust Trait 定义**: (示例)
    ```rust
    use crate::models::{ChannelTestInstance, ChannelPointDefinition, RawTestOutcome, SubTestItem, TestBatchInfo};
    use crate::error::AppError;
    use chrono::{DateTime, Utc};

    // 这个服务通常是同步的，因为它主要处理内存中数据的状态转换逻辑
    // 但如果某些状态评估需要异步查表（例如从一个配置服务实时获取规则），则可以是异步的
    // 为保持一致性，接口方法可以设计为 async，具体实现决定是否真的需要 await
    #[async_trait::async_trait]
    pub trait IChannelStateManager: Send + Sync {
        /// 基于点位定义和批次信息，初始化一个新的 ChannelTestInstance。
        async fn initialize_channel_test_instance(
            &self, 
            definition: &ChannelPointDefinition, 
            batch_id: &str,
            instance_id: String // 由调用方（如OrchestrationService）生成
        ) -> Result<ChannelTestInstance, AppError>;

        /// 应用原始测试结果来更新 ChannelTestInstance 的状态。
        /// 这是核心的状态转换入口。
        async fn apply_raw_outcome(
            &self, 
            instance: &mut ChannelTestInstance, // 直接修改传入的实例
            outcome: RawTestOutcome
        ) -> Result<(), AppError>;

        /// 将 ChannelTestInstance 标记为"已跳过"。
        async fn mark_as_skipped(
            &self, 
            instance: &mut ChannelTestInstance, 
            reason: String, 
            skip_time: DateTime<Utc>
        ) -> Result<(), AppError>;

        /// 为接线确认准备状态。
        async fn prepare_for_wiring_confirmation(
            &self, 
            instance: &mut ChannelTestInstance, 
            confirm_time: DateTime<Utc>
        ) -> Result<(), AppError>;
        
        /// 标记硬点测试开始。
        async fn begin_hard_point_test(
            &self, 
            instance: &mut ChannelTestInstance, 
            start_time: DateTime<Utc>
        ) -> Result<(), AppError>;

        /// 标记手动测试某个子项开始。
        async fn begin_manual_sub_test(
            &self, 
            instance: &mut ChannelTestInstance, 
            item: SubTestItem, 
            start_time: DateTime<Utc>
        ) -> Result<(), AppError>;

        /// 为重测重置 ChannelTestInstance 的相关状态。
        async fn reset_for_retest(
            &self, 
            instance: &mut ChannelTestInstance 
        ) -> Result<(), AppError>;
        
        // 注意：EvaluateOverallStatus 应该是 apply_raw_outcome 内部调用的逻辑，
        // 而不是一个公开的接口方法，以确保状态评估总是在原始结果应用后发生。
    }
    ```
*   **主要交互**: `TestExecutionEngine`, `ManualTestService`, `TestOrchestrationService` (通过它们获取 `ChannelTestInstance` 的可变引用并应用更改)。
*   **事件发布 (`FAT-EVT-001`)**: 此服务本身不发布事件。状态变更后，调用它的应用层服务（如 `TestOrchestrationService`）负责发布相应的事件通知前端或其他模块。

#### 4.2.2. `TestExecutionEngine` (测试执行引擎)

*   **职责**: 负责具体测试任务（由多个 `SpecificTestStepExecutor` 组成）的并发执行、生命周期管理（暂停、继续、停止）。符合 FAT-TTM-001 (调用 `IChannelStateManager`) 的要求，通过将原始结果传递给状态管理器。
*   **Rust Trait 定义**: (示例)
    ```rust
    use crate::models::{ChannelTestInstance, ChannelPointDefinition, RawTestOutcome};
    use crate::error::AppError;
    use tokio::sync::mpsc::Sender; // 用于将 RawTestOutcome 发送给处理单元（可能是OrchestrationService或一个专门的消费者）

    #[async_trait::async_trait]
    pub trait ITestExecutionEngine: Send + Sync {
        /// 提交一个测试实例到执行队列。
        /// `outcome_sender`: 一个 MPSC sender，用于将每个子测试步骤的 `RawTestOutcome` 发送出去进行处理。
        async fn submit_test_instance(
            &self, 
            instance: ChannelTestInstance, // 传入实例的拷贝或相关信息
            definition: ChannelPointDefinition, // 对应的点位定义
            outcome_sender: Sender<Result<RawTestOutcome, AppError>>
        ) -> Result<(), AppError>; // 返回task_id或其他引用

        /// 暂停与特定实例ID（或任务ID）关联的所有活动测试步骤。
        async fn pause_instance_execution(&self, instance_id: &str) -> Result<(), AppError>;

        /// 继续与特定实例ID关联的所有暂停的测试步骤。
        async fn resume_instance_execution(&self, instance_id: &str) -> Result<(), AppError>;

        /// 停止/取消与特定实例ID关联的所有测试步骤。
        async fn stop_instance_execution(&self, instance_id: &str) -> Result<(), AppError>;
        
        /// 设置最大并发测试数。
        async fn set_max_concurrent_tests(&self, max_concurrent: usize) -> Result<(), AppError>;
    }
    ```
*   **主要交互**: `TestOrchestrationService` (接收测试任务), `SpecificTestStepExecutor` (创建和管理它们), `PLCCommunicationService` (传递给执行器), `ChannelStateManager` (通过 `outcome_sender` 间接交互，由 `TestOrchestrationService` 接收 `RawTestOutcome` 后调用 `ChannelStateManager`)。

#### 4.2.3. `ISpecificTestStepExecutor` (特定测试步骤执行器)

*   **职责**: 实现单一、原子的测试步骤逻辑（例如AI点硬采的一个百分比点，或DI点报警测试的信号触发与确认）。与PLC/硬件交互，返回 `RawTestOutcome`。符合 FAT-CTK-001 规则。
*   **Rust Trait 定义**: (示例 - 可能有多种具体的执行器 trait 或一个通用的)
    ```rust
    use crate::models::{ChannelTestInstance, ChannelPointDefinition, RawTestOutcome, SubTestItem};
    use crate::error::AppError;
    use crate::services::plc::IPlcCommunicationService; // 基础设施层的PLC服务
    use std::sync::Arc;

    #[async_trait::async_trait]
    pub trait ISpecificTestStepExecutor: Send + Sync {
        /// 执行特定的测试步骤。
        async fn execute(
            &self,
            instance: &ChannelTestInstance, // 当前测试实例的只读引用
            definition: &ChannelPointDefinition, // 点位定义的只读引用
            plc_service_test_rig: Arc<dyn IPlcCommunicationService>, // 测试台架PLC服务
            plc_service_target: Arc<dyn IPlcCommunicationService>  // 被测系统PLC服务
        ) -> Result<RawTestOutcome, AppError>;

        /// 返回此执行器处理的 SubTestItem 类型。
        fn item_type(&self) -> SubTestItem;
    }
    ```
    *   **具体实现示例**: `AIHardPointPercentExecutor`, `DIAlarmTriggerExecutor`, `AIManualReadExecutor` 等。
    *   `TestExecutionEngine` 会根据 `ChannelPointDefinition` 的类型和测试阶段，选择并实例化合适的 `ISpecificTestStepExecutor` 序列。
*   **主要交互**: `PLCCommunicationService`。

#### 4.2.4. `StatisticsService` (统计服务)

*   **职责**: 根据一批 `ChannelTestInstance` 的测试结果计算统计数据。
*   **Rust Trait 定义**: (示例)
    ```rust
    use crate::models::{ChannelTestInstance, TestBatchInfo};
    use crate::error::AppError;

    #[async_trait::async_trait]
    pub trait IStatisticsService: Send + Sync {
        /// 计算并更新 TestBatchInfo 中的统计摘要。
        async fn calculate_batch_statistics(
            &self, 
            batch_info: &mut TestBatchInfo, 
            instances: &[ChannelTestInstance]
        ) -> Result<(), AppError>;
        
        // 可能还有其他统计方法，如生成特定格式的报告数据结构
    }
    ```
*   **主要交互**: `TestOrchestrationService`, `TestRecordService` (可能需要读取历史数据进行对比统计)。

#### 4.2.5. `TestRecordService` (测试记录服务)

*   **职责**: 负责测试批次信息 (`TestBatchInfo`) 和详细测试实例结果 (`ChannelTestInstance`) 的持久化存储和检索。
*   **Rust Trait 定义**: (示例)
    ```rust
    use crate::models::{TestBatchInfo, ChannelTestInstance};
    use crate::error::AppError;

    #[async_trait::async_trait]
    pub trait ITestRecordService: Send + Sync {
        async fn save_test_batch_info(&self, batch_info: &TestBatchInfo) -> Result<(), AppError>;
        async fn get_test_batch_info(&self, batch_id: &str) -> Result<Option<TestBatchInfo>, AppError>;
        async fn get_all_test_batch_infos(&self) -> Result<Vec<TestBatchInfo>, AppError>;
        async fn delete_test_batch_info(&self, batch_id: &str) -> Result<(), AppError>;

        async fn save_channel_test_instance(&self, instance: &ChannelTestInstance) -> Result<(), AppError>;
        async fn save_channel_test_instances(&self, instances: &[ChannelTestInstance]) -> Result<(), AppError>;
        async fn get_channel_test_instances_for_batch(&self, batch_id: &str) -> Result<Vec<ChannelTestInstance>, AppError>;
        async fn get_channel_test_instance(&self, instance_id: &str) -> Result<Option<ChannelTestInstance>, AppError>;
    }
    ```
*   **主要交互**: `PersistenceService`, `TestOrchestrationService`。

---

### 4.3. 基础设施层 (Infrastructure Layer)

基础设施层提供与外部系统（如PLC、数据库、文件系统）交互的具体实现。

#### 4.3.1. `PLCCommunicationService` (PLC 通信服务)

*   **职责**: 封装与PLC硬件（测试台架PLC和被测系统PLC）的底层通信协议（如Modbus TCP, OPC UA等）。提供读取和写入PLC点位的能力。
*   **Rust Trait 定义**: (示例 - 保持与现有 `IPlcCommunication` 类似的功能)
    ```rust
    use crate::error::AppError;
    use serde_json::Value as JsonValue; // 用于灵活传递不同类型的值

    pub struct PlcTag {
        pub address: String, // 点位地址
        pub data_type: String, // e.g., "bool", "f32", "u16"
    }

    #[async_trait::async_trait]
    pub trait IPlcCommunicationService: Send + Sync {
        async fn connect(&self) -> Result<(), AppError>;
        async fn disconnect(&self) -> Result<(), AppError>;
        async fn is_connected(&self) -> Result<bool, AppError>;

        async fn read_bool(&self, address: &str) -> Result<bool, AppError>;
        async fn read_f32(&self, address: &str) -> Result<f32, AppError>;
        async fn read_u16(&self, address: &str) -> Result<u16, AppError>;
        // ... 其他特定类型的读取方法

        async fn write_bool(&self, address: &str, value: bool) -> Result<(), AppError>;
        async fn write_f32(&self, address: &str, value: f32) -> Result<(), AppError>;
        async fn write_u16(&self, address: &str, value: u16) -> Result<(), AppError>;
        // ... 其他特定类型的写入方法

        /// 批量读取多个点位
        async fn read_multiple_tags(&self, tags: &[PlcTag]) -> Result<Vec<JsonValue>, AppError>;
        /// 批量写入多个点位
        async fn write_multiple_tags(&self, tags: &[(PlcTag, JsonValue)]) -> Result<(), AppError>;
    }
    ```
*   **主要交互**: `TestExecutionEngine`, `SpecificTestStepExecutor`, `ManualTestService`。
*   **实现**: 将会有针对不同PLC或通信协议的具体实现 (e.g., `ModbusTcpPlcService`, `OpcUaPlcService`)。配置信息（IP地址、端口等）将从外部传入。

#### 4.3.2. `PersistenceService` (持久化服务)

*   **职责**: 抽象数据的存储和检索操作。可以是基于文件系统 (JSON, CSV, SQLite) 或更复杂的数据库。
*   **Rust Trait 定义**: (示例 - 根据实际需求细化)
    ```rust
    use serde::{Serialize, de::DeserializeOwned};
    use crate::error::AppError;
    use std::path::PathBuf;

    #[async_trait::async_trait]
    pub trait IPersistenceService: Send + Sync {
        /// 保存可序列化的数据到指定集合/表和键。
        async fn save_document<T: Serialize + Send + Sync>(
            &self, 
            collection_name: &str, 
            document_id: &str, 
            document: &T
        ) -> Result<(), AppError>;

        /// 加载指定集合/表和键的数据。
        async fn load_document<T: DeserializeOwned + Send + Sync>(
            &self, 
            collection_name: &str, 
            document_id: &str
        ) -> Result<Option<T>, AppError>;
        
        /// 加载指定集合/表的所有文档。
        async fn load_all_documents_in_collection<T: DeserializeOwned + Send + Sync>(
            &self, 
            collection_name: &str
        ) -> Result<Vec<T>, AppError>;

        /// 删除指定集合/表和键的文档。
        async fn delete_document(
            &self, 
            collection_name: &str, 
            document_id: &str
        ) -> Result<(), AppError>;

        /// 检查文档是否存在。
        async fn document_exists(
            &self, 
            collection_name: &str, 
            document_id: &str
        ) -> Result<bool, AppError>;

        // 针对文件存储的特定方法 (如果需要)
        async fn save_to_file(&self, file_path: PathBuf, content: &[u8]) -> Result<(), AppError>; 
        async fn load_from_file(&self, file_path: PathBuf) -> Result<Vec<u8>, AppError>;
    }
    ```
*   **主要交互**: `DataManagementService`, `ChannelConfigurationService`, `TestRecordService`。
*   **实现**: 可以有 `JsonFilePersistenceService`, `SqlitePersistenceService`, `PostgresPersistenceService` 等实现。

---

## 5. 前后端通信 (Tauri IPC & Events)

### 5.1. Tauri IPC (Inter-Process Communication)

Angular 前端将通过 Tauri 提供的 `invoke` 命令与 Rust 后端应用服务进行异步调用。

*   **Rust 端**: 使用 `#[tauri::command]` 宏标记需要暴露给前端的函数。这些函数通常是应用服务层方法的包装器。
    ```rust
    // main.rs or a dedicated commands.rs module
    // (假设 AppState 包含了所有服务实例的 Arc<Mutex<...>> 或 Arc<dyn ITrait>)
    
    #[tauri::command]
    async fn create_test_batch_cmd(
        product_model: Option<String>, 
        serial_number: Option<String>,
        state: tauri::State<'_, AppState> // 注入应用状态，其中包含服务实例
    ) -> Result<TestBatchInfo, String> { // 返回 Result<T, String> 给前端处理错误
        let service = state.test_orchestration_service.lock().unwrap(); // 或其他获取服务的方式
        service.create_test_batch(product_model, serial_number)
            .await
            .map_err(|e| e.to_string()) // 将 AppError 转换为 String 给前端
    }

    #[tauri::command]
    async fn get_batch_status_cmd(
        batch_id: String,
        state: tauri::State<'_, AppState>
    ) -> Result<(TestBatchInfo, Vec<ChannelTestInstance>), String> {
        let service = state.test_orchestration_service.lock().unwrap();
        service.get_batch_status_and_instances(&batch_id)
            .await
            .map_err(|e| e.to_string())
    }
    // ... 其他命令
    ```

*   **Angular 端**: 使用 Tauri API (`@tauri-apps/api/tauri`) 的 `invoke` 函数调用Rust命令。
    ```typescript
    // Angular Service Example
    import { invoke } from '@tauri-apps/api/tauri';

    async createTestBatch(productModel?: string, serialNumber?: string): Promise<TestBatchInfo> {
        try {
            return await invoke('create_test_batch_cmd', { productModel, serialNumber });
        } catch (error) {
            console.error('Error creating test batch:', error);
            throw error; // or handle more gracefully
        }
    }

    async getBatchStatus(batchId: string): Promise<[TestBatchInfo, ChannelTestInstance[]]> {
        try {
            return await invoke('get_batch_status_cmd', { batchId });
        } catch (error) {
            console.error('Error getting batch status:', error);
            throw error;
        }
    }
    ```

### 5.2. Rust 到 Angular 的事件通知

对于需要从后端向前端推送的实时更新（如测试进度、状态变更），可以使用 Tauri 的事件系统。

*   **Rust 端**: 在应用服务（如 `TestOrchestrationService`）中，当发生重要状态变更时，通过 `tauri::Window` 或 `tauri::AppHandle` 的 `emit` 方法发送事件。
    ```rust
    // 在 TestOrchestrationService 的某个方法内部，当状态更新后
    // self.app_handle.emit_all("test_progress_update", progress_payload).unwrap();
    // self.app_handle.emit_all("channel_state_changed", channel_instance_payload).unwrap();
    
    // Payload 示例
    #[derive(Clone, serde::Serialize)]
    struct TestProgressPayload {
        batch_id: String,
        overall_progress: f32, // 0.0 to 1.0
        message: String,
    }

    #[derive(Clone, serde::Serialize)]
    struct ChannelStateChangedPayload {
        batch_id: String,
        instance: ChannelTestInstance, // 更新后的实例数据
    }
    ```

*   **Angular 端**: 使用 Tauri API (`@tauri-apps/api/event`) 的 `listen` 函数监听来自Rust的事件。
    ```typescript
    // Angular Component or Service
    import { listen } from '@tauri-apps/api/event';

    ngOnInit() {
        this.listenForTestProgress();
        this.listenForChannelStateChanges();
    }

    async listenForTestProgress() {
        const unlisten = await listen<TestProgressPayload>('test_progress_update', (event) => {
            console.log('Test Progress Update:', event.payload);
            // Update UI based on event.payload
            // this.batchProgress[event.payload.batch_id] = event.payload.overall_progress;
        });
        // Call unlisten() when component is destroyed or no longer needed
    }

    async listenForChannelStateChanges() {
        const unlisten = await listen<ChannelStateChangedPayload>('channel_state_changed', (event) => {
            console.log('Channel State Changed:', event.payload);
            // Update the specific channel instance in the UI
            // this.updateChannelInstanceInView(event.payload.instance);
        });
    }
    ```

## 6. 错误处理与自定义错误类型

*   **Rust 端**: 定义一个统一的 `AppError` 枚举，封装不同模块和操作可能产生的错误类型。
    ```rust
    use thiserror::Error; // 使用 thiserror 宏简化错误类型定义

    #[derive(Error, Debug, Clone, Serialize)] // Clone & Serialize for sending to frontend if needed
    pub enum AppError {
        #[error("IO Error: {0}")]
        IoError(String),

        #[error("Persistence Error: {0}")]
        PersistenceError(String),

        #[error("PLC Communication Error: {0}")]
        PlcCommunicationError(String),

        #[error("Configuration Error: {0}")]
        ConfigurationError(String),

        #[error("Invalid Input: {0}")]
        InvalidInputError(String),

        #[error("Not Found: {0} not found")]
        NotFoundError(String),

        #[error("Test Execution Error: {0}")]
        TestExecutionError(String),

        #[error("State Transition Error: {0}")]
        StateTransitionError(String),

        #[error("Service Error: {0}")]
        InternalServiceError(String),
        
        #[error("Tauri API Error: {0}")]
        TauriError(String),
    }

    // Helper for converting other errors to AppError
    impl From<std::io::Error> for AppError {
        fn from(err: std::io::Error) -> Self {
            AppError::IoError(err.to_string())
        }
    }
    // ... impl From for other common error types (e.g., serde_json::Error)
    ```
    所有服务接口方法应返回 `Result<T, AppError>`。
    在 Tauri command 函数中，将 `AppError` 转换为 `String` 返回给前端，前端可以据此显示用户友好的错误信息。

*   **Angular 端**: 在调用 `invoke` 后，捕获可能发生的错误，并根据错误信息或类型进行相应的UI反馈。

## 7. 关键业务流程示例

下面通过几个关键业务流程示例，说明各服务如何协同工作。

### 7.1. 流程1: 导入点位表并启动测试

1.  **前端 (Angular)**: 用户选择 Excel 点位表文件，点击"导入并开始测试"按钮。
    *   调用 `DataManagementService` (Angular) 的 `uploadAndImportExcel(file)` 方法。
2.  **前端 `DataManagementService` (Angular)**:
    *   (可选) 将文件内容通过Tauri IPC发送给后端，或者让后端直接读取Tauri可访问路径下的文件。
    *   调用 Tauri command `import_excel_and_prepare_batch_cmd(filePath, productModel, serialNumber)`。
3.  **后端 `import_excel_and_prepare_batch_cmd` (Rust Tauri Command)**:
    *   调用 `IDataManagementService` (Rust) 的 `import_channel_definitions_from_excel(filePath)`。
    *   **`IDataManagementService` (Rust)**:
        *   读取并解析Excel文件。
        *   将每行数据转换为临时的 `ExcelPointData` 结构。
        *   为每个 `ExcelPointData` 创建一个 `ChannelPointDefinition` 对象 (可能需要一些转换和验证逻辑)。
        *   (可选) 调用 `IChannelConfigurationService` 保存这些 `ChannelPointDefinition`。
        *   返回 `Vec<ChannelPointDefinition>` 和从Excel中提取的 `TestBatchInfo`（如果存在）。
    *   调用 `ITestOrchestrationService` (Rust) 的 `create_test_batch(...)` 使用提取的批次信息或新信息创建批次，获得 `batch_id`。
    *   调用 `ITestOrchestrationService` (Rust) 的 `prepare_test_instances_for_batch(batch_id, definition_ids)`。
    *   **`ITestOrchestrationService` (Rust)**:
        *   遍历 `definition_ids` (或所有相关的 `ChannelPointDefinition`)。
        *   为每个 `definition`，调用 `IChannelStateManager` (Rust) 的 `initialize_channel_test_instance(definition, batch_id, new_instance_id())` 来创建一个新的 `ChannelTestInstance` 并设置其初始状态。
        *   收集所有创建的 `ChannelTestInstance`。
        *   (可选) 调用 `ITestRecordService` 保存这些初始的 `ChannelTestInstance` 和 `TestBatchInfo`。
        *   返回准备好的 `Vec<ChannelTestInstance>` 给Tauri Command。
    *   Tauri Command 返回成功信息及 `batch_id` 和 `Vec<ChannelTestInstance>` 给前端。
4.  **前端 (Angular)**: 收到成功响应。
    *   UI显示点位列表和批次信息。
    *   用户确认接线完成，点击"开始测试"。
    *   调用 `TestOrchestrationService` (Angular) 的 `confirmWiringAndStartTests(batch_id)`。
5.  **前端 `TestOrchestrationService` (Angular)**:
    *   调用 Tauri command `confirm_wiring_cmd(batch_id)`。
    *   成功后，调用 Tauri command `start_tests_for_batch_cmd(batch_id)`。
6.  **后端 `confirm_wiring_cmd` (Rust Tauri Command)**:
    *   调用 `ITestOrchestrationService` (Rust) 的 `confirm_wiring_for_batch(batch_id)`。
    *   **`ITestOrchestrationService` (Rust)**:
        *   获取该批次的所有 `ChannelTestInstance`。
        *   对每个 `instance`，调用 `IChannelStateManager` (Rust) 的 `prepare_for_wiring_confirmation(instance, now())` 更新状态。
        *   向前端发送 `BatchStatusUpdated` 事件 (包含更新后的 `TestBatchInfo` 和 `ChannelTestInstance` 列表)。
7.  **后端 `start_tests_for_batch_cmd` (Rust Tauri Command)**:
    *   调用 `ITestOrchestrationService` (Rust) 的 `start_tests_for_batch(batch_id)`。
    *   **`ITestOrchestrationService` (Rust)**:
        *   获取该批次下所有状态为 `WiringConfirmed` (或类似) 的 `ChannelTestInstance` 及其对应的 `ChannelPointDefinition`。
        *   创建一个 MPSC channel (`tx`, `rx`) 用于接收 `RawTestOutcome`。
        *   启动一个异步任务来消费 `rx` 中的 `RawTestOutcome`：
            *   循环 `rx.recv().await`。
            *   对于每个收到的 `outcome`，获取对应的 `ChannelTestInstance` (可能需要 `Mutex` 保护的共享状态)。
            *   调用 `IChannelStateManager` (Rust) 的 `apply_raw_outcome(&mut instance, outcome)` 更新状态。
            *   调用 `ITestRecordService` (Rust) 的 `save_channel_test_instance(&instance)`。
            *   向前端发送 `ChannelStateChanged` 事件 (`instance_id`, 更新后的 `instance` 数据)。
            *   当所有测试完成后或特定条件下，更新并发送 `BatchStatusUpdated` 事件。
        *   对于每个要测试的 `(instance, definition)` 对，调用 `ITestExecutionEngine` (Rust) 的 `submit_test_instance(instance, definition, tx.clone())`。
        *   `ITestExecutionEngine` 内部：
            *   根据 `definition.module_type` 和测试阶段，创建一系列 `ISpecificTestStepExecutor`。
            *   使用信号量等并发控制机制，在 `tokio::spawn` 中执行每个 `step_executor.execute(...)`。
            *   将 `step_executor` 返回的 `RawTestOutcome` 通过 `tx` 发送出去。
8.  **前端 (Angular)**: 持续监听 `ChannelStateChanged` 和 `BatchStatusUpdated` 事件，并实时更新UI界面。

### 7.2. 流程2: 执行单个手动测试项 (如AI高报测试)

1.  **前端 (Angular)**: 用户在某个AI点位的详情界面，点击"测试高报"按钮。
    *   调用 `ManualTestService` (Angular) 的 `executeManualAISubTest(channelInstanceId, SubTestItem.HighAlarm, params)`。
2.  **前端 `ManualTestService` (Angular)**:
    *   调用 Tauri command `execute_manual_sub_test_cmd(channelInstanceId, SubTestItem.HighAlarm, params)`。
3.  **后端 `execute_manual_sub_test_cmd` (Rust Tauri Command)**:
    *   调用 `IManualTestService` (Rust) 的 `execute_manual_sub_test(channelInstanceId, SubTestItem.HighAlarm, params)`。
    *   **`IManualTestService` (Rust)**:
        *   获取 `ChannelTestInstance` 和 `ChannelPointDefinition`。
        *   (可选) 调用 `IChannelStateManager` (Rust) 的 `begin_manual_sub_test(&mut instance, SubTestItem.HighAlarm, now())` 更新状态为手动测试中。
        *   向前端发送 `ChannelStateChanged` 事件 (状态变为手动测试中)。
        *   选择/创建一个合适的 `ISpecificTestStepExecutor` (e.g., `AIHighAlarmTestExecutor`)。
        *   调用 `executor.execute(...)`，传入必要的PLC服务实例和参数。
        *   `executor` 执行与PLC的交互（如设置高报值，读取报警状态）。
        *   `executor` 返回 `RawTestOutcome`。
        *   `IManualTestService` 收到 `RawTestOutcome`。
        *   调用 `IChannelStateManager` (Rust) 的 `apply_raw_outcome(&mut instance, outcome)` 来根据此 `RawTestOutcome` 更新最终的子测试状态和整体状态。
        *   调用 `ITestRecordService` (Rust) 保存更新后的 `instance`。
        *   向前端发送 `ChannelStateChanged` 事件 (包含最终测试结果)。
        *   返回最终的 `RawTestOutcome` (或简化的结果) 给Tauri Command。
4.  **前端 (Angular)**: 接收到命令的直接结果，并通过事件监听器更新UI。

## 8. 总结与后续步骤

本文档提出的分层架构旨在解决现有系统的问题，并为向 `Rust + Angular + Tauri` 技术栈的迁移提供一个清晰的指导。通过明确服务职责、细化数据模型和定义清晰的交互流程，新系统有望在性能、可维护性和可扩展性方面得到显著提升。

**后续步骤建议：**

1.  **原型验证**: 针对一两个核心流程（如AI点硬点测试），快速搭建一个包含前后端通信、核心服务和PLC交互的最小可行原型 (MVP)，以验证架构的可行性和关键技术点。
2.  **详细设计**: 对每个服务的具体实现逻辑、数据持久化方案（选择数据库或文件存储策略）、并发模型细节（`TestExecutionEngine`）进行更详细的设计。
3.  **Rust后端开发**: 优先实现基础设施层 (PLC通信、持久化抽象) 和核心领域服务 (`ChannelStateManager`, `TestExecutionEngine` 的骨架)。
4.  **Tauri集成与API定义**: 逐步定义和实现Tauri commands，确保前后端数据结构一致。
5.  **Angular前端开发**: 根据API和服务，开始构建用户界面组件和服务。
6.  **持续集成与测试**: 尽早引入单元测试、集成测试，并建立CI/CD流程。
7.  **分阶段迁移**: 如果可行，考虑将现有系统的功能模块分阶段迁移到新架构中，而不是一次性全盘重构，以降低风险。

此架构是一个演进的蓝图，在实际开发过程中，可根据具体遇到的问题和需求进行调整和优化。
