# FAT_TEST 项目整体理解文档

## 📋 项目概述

FAT_TEST（Factory Acceptance Test）是一个专业的工厂验收测试桌面应用程序，主要用于工业控制系统的硬点通道测试和手动功能验证。项目正在从传统的 **C# WPF** 技术栈迁移到现代化的 **Rust + Angular + Tauri** 技术栈。

### 🎯 项目目标
- **自动化测试**: 实现PLC硬点通道的自动化批量测试
- **手动验证**: 提供上位机功能的手动测试界面
- **数据管理**: 完整的测试数据导入、存储和报告生成
- **多协议支持**: 支持Modbus TCP、Siemens S7、OPC UA等工业通信协议

## 🔄 技术栈迁移分析

### 重构前技术栈 (C# WPF)
```
┌─────────────────────────────────────┐
│           C# WPF 应用程序            │
├─────────────────────────────────────┤
│ 表现层: WPF + XAML + MVVM          │
│ 业务层: C# 业务逻辑                 │
│ 数据层: Entity Framework Core      │
│ 通信层: Modbus TCP 库              │
│ 数据库: SQLite                     │
└─────────────────────────────────────┘
```

**技术特点**:
- **框架**: WPF + .NET 6+
- **架构模式**: MVVM (Model-View-ViewModel)
- **数据访问**: Entity Framework Core + SQLite
- **PLC通信**: 仅支持 Modbus TCP
- **UI组件**: 原生WPF控件
- **部署**: Windows桌面应用

### 重构后技术栈 (Rust + Angular + Tauri)
```
┌─────────────────────────────────────┐
│         Tauri 桌面应用程序           │
├─────────────────────────────────────┤
│ 前端: Angular 18+ + NG-ZORRO       │
│ 后端: Rust + Tauri 2.x             │
│ 异步: tokio 运行时                  │
│ 数据: SeaORM + SQLite              │
│ 通信: 多协议支持                    │
└─────────────────────────────────────┘
```

**技术优势**:
- **性能**: Rust的零成本抽象和内存安全
- **现代化**: Angular的组件化和响应式设计
- **跨平台**: Tauri的跨平台支持
- **扩展性**: 支持多种PLC通信协议
- **维护性**: 更好的代码组织和测试覆盖

## 🏗️ 核心业务流程详解

### 1. 数据导入和准备阶段
```
Excel点表导入 → 数据验证 → 通道定义创建 → 测试PLC配置 → 批次自动分配
```

**详细流程**:
1. **Excel点表导入**: 用户导入包含被测PLC通道信息的Excel文件
2. **数据验证**: 验证点表格式、字段完整性和数据有效性
3. **通道定义创建**: 根据点表创建ChannelPointDefinition实例
4. **测试PLC配置**: 配置测试PLC的通道信息和通信参数
5. **批次自动分配**: 根据匹配规则自动分配测试批次

### 2. 硬点通道自动测试阶段
```
选择测试批次 → 建立PLC连接 → 创建并发测试任务 → 执行硬点测试 → 收集测试结果 → 状态持久化
```

**测试类型详解**:

#### DI (数字量输入) 测试
- **测试逻辑**: 测试PLC的DO通道输出 → 被测PLC的DI通道检测
- **测试步骤**:
  1. 测试PLC DO通道输出低电平
  2. 检查被测PLC DI通道是否显示"断开"
  3. 等待信号稳定
  4. 测试PLC DO通道输出高电平
  5. 检查被测PLC DI通道是否显示"接通"
  6. 等待信号稳定
  7. 测试PLC DO通道输出低电平
  8. 检查被测PLC DI通道是否显示"断开"

#### DO (数字量输出) 测试
- **测试逻辑**: 被测PLC的DO通道输出 → 测试PLC的DI通道检测
- **测试步骤**:
- 1. 被测PLC DO通道输出低电平
  2. 检查测试PLC DO通道是否显示"断开"
  3. 等待信号稳定
  4. 被测PLC DO通道输出高电平
  5. 检查测试PLC DI通道是否显示"接通"
  6. 等待信号稳定
  7. 被测PLC DO通道输出低电平
  8. 检查测试PLC DI通道是否显示"断开"

#### AI (模拟量输入) 测试
- **测试逻辑**: 测试PLC的AO通道输出 → 被测PLC的AI通道采集
- **测试步骤**:
  1. 测试PLC AO按序输出: 0%, 25%, 50%, 75%, 100%
  2. 被测PLC AI采集对应数值
  3. 验证采集值与期望值的偏差在允许范围内

#### AO (模拟量输出) 测试
- **测试逻辑**: 被测PLC的AO通道输出 → 测试PLC的AI通道采集
- **测试步骤**:
  1. 被测PLC AO按序输出: 0%, 25%, 50%, 75%, 100%
  2. 测试PLC AI采集对应数值
  3. 验证采集值与期望值的偏差在允许范围内

### 3. 手动测试阶段
```
硬点测试通过 → 启用手动测试 → 报警上下限测试 → 显示值验证 → 趋势图检查 → 报表功能验证 → 维护开关测试
```

**手动测试项目**:
- **报警功能**: 高高报警、高报警、低报警、低低报警
- **显示功能**: 数值显示、状态显示
- **趋势功能**: 历史趋势
- **报表功能**: 报表生成
- **维护功能**: 维护开关

### 4. 批次分配逻辑详解

#### 分配规则矩阵
```
测试PLC类型    →    被测PLC类型
AI有源        →    AO无源
AI无源        →    AO有源
DI有源        →    DO无源
DI无源        →    DO有源
DO有源        →    DI无源
DO无源        →    DI有源
```

#### 分配算法示例
- 测试PLC有16个AI有源通道，被测PLC有18个AO无源通道
- 前16个AO无源通道分配到第一批次
- 剩余2个AO无源通道分配到下一批次
- 按照"填空"方式进行分配，确保资源最大化利用

## 📊 数据模型深度分析

### 核心实体关系

```text
ChannelPointDefinition (通道点位定义)
    ↓ 1:N
ChannelTestInstance (通道测试实例)
    ↓ 1:N
SubTestExecutionResult (子测试执行结果)

TestBatchInfo (测试批次信息)
    ↓ 1:N
ChannelTestInstance (通道测试实例)

PlcConnectionConfig (PLC连接配置)
    ↓ 1:N
ChannelPointDefinition (通道点位定义)
```

### 详细数据模型分析

#### 1. ChannelPointDefinition (通道点位定义)

**核心字段**:

- `id`: 唯一标识符 (String)
- `tag`: 位号标识 (String)
- `variable_name`: 变量名称 (String)
- `module_type`: 模块类型 (AI/AO/DI/DO)
- `plc_communication_address`: PLC通信地址 (String)
- `power_supply_type`: 供电类型 (有源/无源)
- `range_lower_limit`: 量程下限 (f64)
- `range_upper_limit`: 量程上限 (f64)
- `variable_description`: 变量描述 (String)
- `wire_system`: 接线制式 (二线制/四线制)

**业务含义**: 描述一个测试点的静态配置信息，通常从Excel点表导入

#### 2. ChannelTestInstance (通道测试实例)

**核心字段**:

- `instance_id`: 测试实例唯一ID (String)
- `definition_id`: 关联的通道定义ID (String)
- `overall_status`: 整体测试状态 (OverallTestStatus枚举)
- `test_batch`: 所属测试批次 (String)
- `created_time`: 创建时间 (DateTime)
- `updated_time`: 更新时间 (DateTime)
- `sub_test_results`: 子测试结果集合 (HashMap)

**状态枚举**:

```rust
pub enum OverallTestStatus {
    NotTested,           // 未测试
    WiringConfirmed,     // 接线确认
    HardPointTesting,    // 硬点测试中
    HardPointPassed,     // 硬点测试通过
    HardPointFailed,     // 硬点测试失败
    ManualTesting,       // 手动测试中
    ManualPassed,        // 手动测试通过
    AllCompleted,        // 全部完成
}
```

#### 3. SubTestExecutionResult (子测试执行结果)

**核心字段**:

- `test_item`: 测试项目类型 (SubTestItem枚举)
- `status`: 执行状态 (TestExecutionStatus枚举)
- `result`: 测试结果 (Pass/Fail/NotTested)
- `error_message`: 错误信息 (Option<String>)
- `execution_time`: 执行时间 (DateTime)
- `test_values`: 测试数值记录 (Vec<TestValue>)

**子测试项目枚举**:

```rust
pub enum SubTestItem {
    HardPoint,           // 硬点测试
    HighHighAlarm,       // 高高报警
    HighAlarm,           // 高报警
    LowAlarm,            // 低报警
    LowLowAlarm,         // 低低报警
    ShowValue,           // 显示值
    TrendCheck,          // 趋势检查
    ReportCheck,         // 报表检查
    MaintenanceFunction, // 维护功能
}
```

## 🏛️ 系统架构设计

### 分层架构图

```text
┌─────────────────────────────────────────────────────────┐
│                   表现层 (Presentation)                  │
│  Angular Components + NG-ZORRO + ECharts              │
├─────────────────────────────────────────────────────────┤
│                   应用层 (Application)                   │
│  Tauri Commands + Event Handlers + State Management   │
├─────────────────────────────────────────────────────────┤
│                    领域层 (Domain)                      │
│  Business Logic + Domain Services + Entities          │
├─────────────────────────────────────────────────────────┤
│                  基础设施层 (Infrastructure)              │
│  Database Access + PLC Communication + File I/O      │
└─────────────────────────────────────────────────────────┘
```

### 核心服务架构

#### 1. 测试编排服务 (TestOrchestrationService)

**职责**: 统筹整个测试流程的执行

**核心方法**:

- `create_test_batch()`: 创建测试批次
- `start_batch_test()`: 启动批次测试
- `pause_test()`: 暂停测试
- `resume_test()`: 恢复测试
- `get_test_progress()`: 获取测试进度

#### 2. 通道状态管理器 (ChannelStateManager)

**职责**: 管理测试实例的状态转换 (符合FAT-CSM-001规则)

**核心方法**:

- `apply_raw_outcome()`: 应用测试结果并更新状态
- `validate_state_transition()`: 验证状态转换合法性
- `get_instance_status()`: 获取实例状态
- `batch_update_status()`: 批量更新状态

#### 3. 测试执行引擎 (TestExecutionEngine)

**职责**: 管理并发测试任务的执行 (符合FAT-TTM-001规则)

**核心方法**:

- `submit_test_tasks()`: 提交测试任务
- `execute_concurrent_tests()`: 执行并发测试
- `monitor_task_progress()`: 监控任务进度
- `handle_task_failure()`: 处理任务失败

#### 4. PLC通信服务 (PlcCommunicationService)

**职责**: 提供统一的PLC通信接口

**支持协议**:

- Modbus TCP
- Siemens S7 (计划支持)
- OPC UA (计划支持)

**核心方法**:

- `connect()`: 建立连接
- `read_bool()`: 读取布尔值
- `write_bool()`: 写入布尔值
- `read_f32()`: 读取浮点数
- `write_f32()`: 写入浮点数

## 🔄 状态管理机制

### 状态转换图

```text
NotTested → WiringConfirmed → HardPointTesting → HardPointPassed → ManualTesting → AllCompleted
    ↓              ↓               ↓                ↓                ↓
    ↓              ↓               ↓         HardPointFailed         ↓
    ↓              ↓               ↓                ↓                ↓
    ↓              ↓               ↓                ↓         ManualPassed
    ↓              ↓               ↓                ↓                ↓
    └──────────────┴───────────────┴────────────────┴────────────────┘
                                (可以重新开始测试)
```

### 状态持久化策略

**持久化时机**:

1. **批次硬点测试完成**: 将整个批次的所有通道状态持久化到数据库
2. **手动测试完成**: 单个通道手动测试完成时更新该通道状态
3. **应用关闭**: 保存当前所有状态以支持恢复功能

**恢复机制**:

- 应用启动时提供"继续上次测试"功能
- 从数据库恢复所有测试数据并重建内存状态
- 支持断点续传，避免重复测试

## 🚀 并发控制设计

### 并发模型

**并发粒度**: 以通道为单位进行并发

**并发控制**:

```rust
pub struct TestExecutionEngine {
    // 控制最大并发数 (默认88个，对应测试PLC通道数)
    concurrency_semaphore: Arc<Semaphore>,
    // 任务执行器池
    executors: HashMap<SubTestItem, Arc<dyn ISpecificTestStepExecutor>>,
    // PLC通信服务
    plc_service: Arc<dyn IPlcCommunicationService>,
}
```

**执行流程**:

1. 获取信号量许可
2. 创建通道测试任务
3. 串行执行该通道的所有子测试项
4. 收集测试结果
5. 释放信号量许可

### 性能要求

**时间目标**: 30秒内完成当前批次的硬点通道测试

**性能计算**:

- 测试PLC通道数: 88个
- 默认并发数: 88个 (1:1对应)
- 单通道测试时间: ≤30秒
- 批次测试时间: ≤30秒 (并行执行)

**性能优化策略**:

- 使用tokio异步运行时
- PLC通信连接池
- 内存状态管理，减少数据库访问
- 前端状态更新防抖

## 🔌 PLC通信协议支持

### Modbus TCP (已实现)

**特点**:

- 基于TCP/IP的工业通信协议
- 支持读写保持寄存器、线圈等
- 广泛应用于工业自动化

**实现库**: `tokio-modbus`

### Siemens S7 (计划实现)

**特点**:

- 西门子PLC专用协议
- 支持S7-300/400/1200/1500系列
- 高性能、高可靠性

**实现方案**: 使用`s7comm` crate或FFI调用

### OPC UA (计划实现)

**特点**:

- 现代工业通信标准
- 支持安全认证和加密
- 跨平台、跨厂商

**实现库**: `opcua-client`

## 📱 前端架构设计

### Angular组件架构

```text
AppComponent
├── NavigationComponent (导航栏 + PLC状态显示)
├── DashboardComponent (仪表板)
├── TestPlcConfigComponent (测试PLC配置)
├── DataManagementComponent (数据管理)
├── TestAreaComponent (测试区域)
│   ├── BatchListComponent (批次列表)
│   ├── ChannelGridComponent (通道网格)
│   └── TestProgressComponent (测试进度)
└── ReportsComponent (报告管理)
```

### 状态管理

**前端状态同步**:

- 使用Tauri的事件系统 (`emit`/`listen`)
- 实时更新测试进度和状态
- 防抖机制避免频繁更新

**状态更新频率**:

- 测试状态变更: 实时推送
- 进度更新: 每秒1次
- PLC通信状态: 每5秒检查一次

### UI组件库

**NG-ZORRO组件使用**:

- `nz-table`: 通道数据表格
- `nz-progress`: 测试进度条
- `nz-badge`: 状态指示器
- `nz-modal`: 配置对话框
- `nz-notification`: 消息通知

**ECharts图表**:

- 测试进度饼图
- 通道状态分布图
- 历史测试趋势图

## 🗄️ 数据库设计

### 表结构设计 (基于原C#项目)

**主要表**:

1. `channel_point_definitions`: 通道点位定义
2. `channel_test_instances`: 通道测试实例
3. `test_batches`: 测试批次信息
4. `plc_connection_configs`: PLC连接配置
5. `test_results`: 测试结果记录
6. `system_settings`: 系统配置

**关键字段映射** (C# → Rust):

- `Id` → `id`
- `ChannelTag` → `channel_tag`
- `ModuleType` → `module_type`
- `PlcCommunicationAddress` → `plc_communication_address`
- `OverallStatus` → `overall_status`
- `TestBatch` → `test_batch`

### SeaORM集成

**实体定义**:

```rust
#[derive(Clone, Debug, PartialEq, DeriveEntityModel)]
#[sea_orm(table_name = "channel_point_definitions")]
pub struct Model {
    #[sea_orm(primary_key, auto_increment = false)]
    pub id: String,
    pub tag: String,
    pub variable_name: String,
    pub module_type: String,
    pub plc_communication_address: String,
    // ... 其他字段
}
```

**数据访问层**:

- Repository模式封装数据访问
- 事务支持确保数据一致性
- 连接池管理提升性能

## 🔧 配置管理

### 配置类型

**系统配置**:

- 最大并发测试数
- 测试间隔时间
- 超时设置
- 日志级别

**PLC通信配置**:

- IP地址和端口
- 连接超时
- 重试次数
- 协议参数

**测试参数配置**:

- 偏差允许范围
- 测试步骤间隔
- 报警阈值设定

### 热更新机制

**更新流程**:

1. 用户在配置界面修改参数
2. 前端调用后端配置更新API
3. 后端验证配置有效性
4. 更新数据库配置记录
5. 通知相关服务模块重新加载配置
6. PLC连接配置变更时重新建立连接

**约束条件**:

- PLC配置只能在断开连接时修改
- 系统配置修改后立即生效
- 配置变更不需要审计日志

## 🔍 监控和诊断

### 关键监控指标

**PLC通信状态**:

- 测试PLC连接状态
- 被测PLC连接状态
- 通信延迟和错误率
- 连接重试次数

**测试执行状态**:

- 当前并发测试数
- 测试队列长度
- 平均测试时间
- 成功/失败率

**系统资源状态**:

- 内存使用情况
- CPU使用率
- 数据库连接数
- 文件I/O状态

### 状态显示

**导航栏状态区域**:

- PLC连接状态指示灯
- 当前测试进度
- 系统运行状态
- 错误告警提示

**实时监控**:

- 每5秒更新PLC通信状态
- 实时显示测试进度
- 异常情况立即告警

## 🧪 测试策略

### 单元测试

**覆盖率目标**: 90%

**重点测试模块**:

- 状态管理器的状态转换逻辑
- 批次分配算法
- PLC通信协议实现
- 数据验证和转换

**测试工具**:

- Rust: `tokio-test`, `mockall`
- Angular: `Jasmine`, `Karma`

### 集成测试

**测试场景**:

- 完整的测试流程端到端测试
- PLC通信集成测试
- 数据库操作集成测试
- 前后端通信集成测试

### 性能测试

**基准测试**:

- 88个通道并发测试性能
- 大批量数据导入性能
- 前端UI响应性能
- 内存使用和泄漏测试

## 🚀 扩展性设计

### 软点测试扩展

**软点 vs 硬点**:

- **硬点**: PLC的物理I/O通道
- **软点**: PLC内部的中间变量和逻辑点

**扩展方案**:

- 扩展`ModuleType`枚举支持软点类型
- 新增软点测试执行器
- 复用现有的PLC通信基础设施

### 跳过测试功能

**业务场景**:

- 模块未到货，跳过整个模块的测试
- 特定通道故障，跳过单个通道测试
- 调试阶段，选择性执行测试

**实现方案**:

- 在`ChannelTestInstance`中添加`skip_reason`字段
- 测试执行时检查跳过标记
- 报告中明确标注跳过项目和原因

### 协议扩展

**插件化设计**:

```rust
pub trait PlcProtocolPlugin: Send + Sync {
    fn protocol_name(&self) -> &str;
    fn create_client(&self, config: &PlcConfig) -> Box<dyn PlcClient>;
}
```

**动态加载**:

- 支持运行时加载新的协议插件
- 配置驱动的协议选择
- 向后兼容现有协议

## 📋 总结

FAT_TEST项目是一个复杂的工业测试系统，涉及多个技术领域：

**技术亮点**:

- 现代化的Rust + Angular + Tauri技术栈
- 高并发的异步测试执行
- 多协议PLC通信支持
- 完整的状态管理和数据持久化
- 用户友好的现代化界面

**业务价值**:

- 自动化硬点通道测试，提升效率
- 标准化测试流程，保证质量
- 完整的测试记录和报告
- 支持大规模工业项目验收

**架构优势**:

- 分层架构，职责清晰
- 事件驱动，松耦合设计
- 可扩展的插件化架构
- 高性能的并发处理

项目已完成基础架构搭建，正在进入第二阶段的深度重构，重点完善测试执行引擎、状态管理机制和用户体验优化。